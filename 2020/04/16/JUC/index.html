<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JUC详解 | Hexo</title>
  <meta name="keywords" content=" JavaSe , JUC ">
  <meta name="description" content="JUC详解 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 你好，新世">
<meta property="og:type" content="article">
<meta property="og:title" content="Hello World">
<meta property="og:url" content="http://yoursite.com/2020/04/16/hello-world/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 你好，新世">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-16T04:01:55.065Z">
<meta property="article:modified_time" content="2020-04-16T09:38:58.424Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/yelog" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="facebook" href="https://www.facebook.com/faker.tops" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-facebook"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
        <a title="instagram" href="https://www.facebook.com/faker.tops" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-instagram"></use>
                </svg>
            
        </a>
        
    
        
        <a title="reddit" href="https://www.reddit.com/user/yelog/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-reddit"></use>
                </svg>
            
        </a>
        
    
        
        <a title="weibo" href="http://weibo.com/u/2307534817" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-weibo"></use>
                </svg>
            
        </a>
        
    
        
        <a title="jianshu" href="https://www.jianshu.com/u/ff56736de7cf" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-jianshu"></use>
                </svg>
            
        </a>
        
    
        
        <a title="zhihu" href="https://www.zhihu.com/people/jaytp/activities" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-zhihu"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="oschina" href="https://my.oschina.net/yelog" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-oschina"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="email" href="mailto:jaytp@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
        <a title="kugou" href="https://www.kugou.com/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-kugou"></use>
                </svg>
            
        </a>
        
    
        
        <a title="neteasemusic" href="https://music.163.com/#/user/home?id=88151013" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(3)</small></div></li>
    
        
            
            <li><div data-rel="Java基础">Java基础<small>(2)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="3">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode === 13){return false;}">
        <input id="local-search-input" class="search" type="text" placeholder="Search..." />
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color2">JavaSe</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">JUC</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">设计模式</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class=""
           href="/2020/04/16/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2020-04-16 12:01:55">2020/04/16</span>
        </a>
        
        <a  class="Java基础 "
           href="/2020/04/16/JUC/"
           data-tag="JavaSe,JUC"
           data-author="" >
            <span class="post-title" title="JUC详解">JUC详解</span>
            <span class="post-date" title="2020-04-16 00:00:00">2020/04/16</span>
        </a>
        
        <a  class="Java基础 "
           href="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag="JavaSe,设计模式"
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <span class="post-date" title="2020-04-16 00:00:00">2020/04/16</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-JUC" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">JUC详解</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a  data-rel="Java基础">Java基础</a>
            
        </span>
        
        
        <span class="tag">
            
            <a class="color2">JavaSe</a>
            
            <a class="color4">JUC</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-04-16 17:47:58'>2020-04-16 00:00</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章-JUC"><span class="toc-text">第一章 JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、JUC是什么"><span class="toc-text">1、JUC是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、进程-线程？-并发-并行？"><span class="toc-text">2、进程&#x2F;线程？  并发&#x2F;并行？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-、进程-线程是什么？"><span class="toc-text">(1)、进程&#x2F;线程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-、进程-线程例子？"><span class="toc-text">(2)、进程&#x2F;线程例子？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-、什么是并发？什么是并行？"><span class="toc-text">(3)、什么是并发？什么是并行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-、线程状态"><span class="toc-text">(4)、线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-、wait-sleep的区别？"><span class="toc-text">(5)、wait&#x2F;sleep的区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章-Lock接口"><span class="toc-text">第二章 Lock接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、创建线程的方式"><span class="toc-text">1、创建线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-、类直接继承Thread"><span class="toc-text">(1)、类直接继承Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-、new-Thread"><span class="toc-text">(2)、new Thread();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-、第三种"><span class="toc-text">(3)、第三种</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、复习Synchronized（卖票练习1）"><span class="toc-text">2、复习Synchronized（卖票练习1）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、Lock接口"><span class="toc-text">3、Lock接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-、Lock是什么"><span class="toc-text">(1)、Lock是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-、ReentrantLock可重复锁"><span class="toc-text">(2)、ReentrantLock可重复锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-、synchronized与Lock的区别"><span class="toc-text">(3)、synchronized与Lock的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#公平锁与非公平锁"><span class="toc-text">公平锁与非公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可重入锁"><span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#死锁"><span class="toc-text">死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、Lock卖票改进（卖票练习2）"><span class="toc-text">4、Lock卖票改进（卖票练习2）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-Java8之lambda表达式复习"><span class="toc-text">第三章 Java8之lambda表达式复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、什么是Lambda"><span class="toc-text">1、什么是Lambda</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、Lambda表达式接口实现语法"><span class="toc-text">2、Lambda表达式接口实现语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、Lambda卖票改进（卖票练习2）"><span class="toc-text">3、Lambda卖票改进（卖票练习2）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、详解Lambda表达式接口实现"><span class="toc-text">4、详解Lambda表达式接口实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-线程间通信"><span class="toc-text">第四章 线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、生产者消费者问题"><span class="toc-text">1、生产者消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、java8新版实现生产者消费者问题"><span class="toc-text">2、java8新版实现生产者消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、线程间精准通知顺序访问"><span class="toc-text">3、线程间精准通知顺序访问</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章-8锁问题"><span class="toc-text">第五章 8锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、锁的8个问题"><span class="toc-text">1、锁的8个问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、8锁分析"><span class="toc-text">2、8锁分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-多线程集合类"><span class="toc-text">第六章 多线程集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、ArrayList不安全"><span class="toc-text">1、ArrayList不安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、解决办法"><span class="toc-text">2、解决办法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-、Vector"><span class="toc-text">(1)、Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-、Collections"><span class="toc-text">(2)、Collections</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-、写时复制"><span class="toc-text">(3)、写时复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、多说一点集合类"><span class="toc-text">3、多说一点集合类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章-Callable接口"><span class="toc-text">第七章 Callable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、Callable接口介绍"><span class="toc-text">1、Callable接口介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、与runnable接口对比"><span class="toc-text">2、与runnable接口对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、怎么用？"><span class="toc-text">3、怎么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、FutureTask"><span class="toc-text">4、FutureTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-、是什么"><span class="toc-text">(1)、是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-、原理"><span class="toc-text">(2)、原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-、代码"><span class="toc-text">(3)、代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章-JUC强大的辅助类讲解"><span class="toc-text">第八章 JUC强大的辅助类讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、CountDownLatch-减少计数"><span class="toc-text">1、CountDownLatch 减少计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、CyclicBarrier-循环栅栏"><span class="toc-text">2、CyclicBarrier 循环栅栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、Semaphore-信号灯（PV原语操作）"><span class="toc-text">3、Semaphore 信号灯（PV原语操作）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、ReentrantReadWriteLock读写锁"><span class="toc-text">4、ReentrantReadWriteLock读写锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第九章-阻塞队列"><span class="toc-text">第九章 阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、阻塞队列是什么"><span class="toc-text">1、阻塞队列是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、阻塞队列的用处"><span class="toc-text">2、阻塞队列的用处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、架构梳理-种类分析"><span class="toc-text">3、架构梳理 种类分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、BlockingQueue核心方法API"><span class="toc-text">4、BlockingQueue核心方法API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十章-ThreadPool线程池"><span class="toc-text">第十章 ThreadPool线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、为什么用线程池"><span class="toc-text">1、为什么用线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、线程池如何使用"><span class="toc-text">2、线程池如何使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-、架构说明"><span class="toc-text">(1)、架构说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-、线程池三大实现"><span class="toc-text">(2)、线程池三大实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、ThreadPoolExecutor底层原理"><span class="toc-text">3、ThreadPoolExecutor底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-、三大实现都是ThreadPoolExecutor"><span class="toc-text">(1)、三大实现都是ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-、ThreadPoolExecutor-七大参数"><span class="toc-text">(2)、ThreadPoolExecutor 七大参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-、线程池底层工作原理"><span class="toc-text">(3)、线程池底层工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-、线程池的拒绝策略"><span class="toc-text">(4)、线程池的拒绝策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、手写线程池"><span class="toc-text">4、手写线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-、超级大坑"><span class="toc-text">(1)、超级大坑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-、手写线程池"><span class="toc-text">(2)、手写线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#合理配置线程池的最大数量"><span class="toc-text">合理配置线程池的最大数量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-、拒绝策略"><span class="toc-text">(3)、拒绝策略</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-JUC"><a href="#第一章-JUC" class="headerlink" title="第一章 JUC"></a>第一章 JUC</h1><h2 id="1、JUC是什么"><a href="#1、JUC是什么" class="headerlink" title="1、JUC是什么"></a>1、JUC是什么</h2><p>java.util.concurrent在并发编程中使用的工具类,主要由以下3个包组成</p>
<img src="/2020/04/16/JUC/QQ截图20200220203545.png" style="zoom:150%;">



<h2 id="2、进程-线程？-并发-并行？"><a href="#2、进程-线程？-并发-并行？" class="headerlink" title="2、进程/线程？  并发/并行？"></a>2、进程/线程？  并发/并行？</h2><h3 id="1-、进程-线程是什么？"><a href="#1-、进程-线程是什么？" class="headerlink" title="(1)、进程/线程是什么？"></a>(1)、进程/线程是什么？</h3><p>进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>
<p>线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p>
<h3 id="2-、进程-线程例子？"><a href="#2-、进程-线程例子？" class="headerlink" title="(2)、进程/线程例子？"></a>(2)、进程/线程例子？</h3><p>线程依附于进程进行一些操作</p>
<p>使用QQ，查看进程一定有一个QQ.exe的进程，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。 QQ就是一个进程  </p>
<p>大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。  </p>
<p>word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个线程：容灾备份，语法检查</p>
<h3 id="3-、什么是并发？什么是并行？"><a href="#3-、什么是并发？什么是并行？" class="headerlink" title="(3)、什么是并发？什么是并行？"></a>(3)、什么是并发？什么是并行？</h3><p><strong>并发：同一时刻多个线程在访问同一个资源，多个线程对一个点</strong><br>      例子：小米9今天上午10点，限量抢购<br>            春运抢票<br>            电商秒杀…<br><strong>并行：多项工作一起执行，之后再汇总</strong><br>      例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p>
<h3 id="4-、线程状态"><a href="#4-、线程状态" class="headerlink" title="(4)、线程状态"></a>(4)、线程状态</h3><p>Thread.State的java源码，共如下几个状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,(新建)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,（准备就绪）</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,（阻塞）</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,（不见不散）【一直等，没有时间限制】</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,（过时不候）【比如说就等<span class="number">10</span>s中，有时间限制】</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;(终结)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-、wait-sleep的区别？"><a href="#5-、wait-sleep的区别？" class="headerlink" title="(5)、wait/sleep的区别？"></a>(5)、wait/sleep的区别？</h3><p>功能都是当前线程暂停，有什么区别？</p>
<p>wait放开手去睡，放开手里的锁</p>
<p>sleep握紧手去睡，醒了手里还有锁</p>
<h1 id="第二章-Lock接口"><a href="#第二章-Lock接口" class="headerlink" title="第二章 Lock接口"></a>第二章 Lock接口</h1><h2 id="1、创建线程的方式"><a href="#1、创建线程的方式" class="headerlink" title="1、创建线程的方式"></a>1、创建线程的方式</h2><h3 id="1-、类直接继承Thread"><a href="#1-、类直接继承Thread" class="headerlink" title="(1)、类直接继承Thread"></a>(1)、类直接继承Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure>
<p>java是单继承，资源宝贵，要用接口方式</p>
<p><font color="red">不能这样写</font></p>
<h3 id="2-、new-Thread"><a href="#2-、new-Thread" class="headerlink" title="(2)、new Thread();"></a>(2)、new Thread();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line"> t1.start();</span><br></pre></td></tr></table></figure>
<p>这样写太low了<br><font color="red">不要这样写</font></p>
<h3 id="3-、第三种"><a href="#3-、第三种" class="headerlink" title="(3)、第三种"></a>(3)、第三种</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">//具体业务逻辑的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br></pre></td></tr></table></figure>




<h2 id="2、复习Synchronized（卖票练习1）"><a href="#2、复习Synchronized（卖票练习1）" class="headerlink" title="2、复习Synchronized（卖票练习1）"></a>2、复习Synchronized（卖票练习1）</h2><p>核心思想，线程操作（暴露接口）资源类</p>
<p><strong>使用synchronized同步锁</strong></p>
<p>首先创建资源类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"卖出第"</span> + number-- + <span class="string">"张票,还剩"</span> + number + <span class="string">"张"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">                    ticket.saleTicket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">                    ticket.saleTicket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">                    ticket.saleTicket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、Lock接口"><a href="#3、Lock接口" class="headerlink" title="3、Lock接口"></a>3、Lock接口</h2><h3 id="1-、Lock是什么"><a href="#1-、Lock是什么" class="headerlink" title="(1)、Lock是什么"></a>(1)、Lock是什么</h3><p>Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects. </p>
<p>锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。</p>
<p>Lock定义为一个接口，具体的实现由子类完成</p>
<h3 id="2-、ReentrantLock可重复锁"><a href="#2-、ReentrantLock可重复锁" class="headerlink" title="(2)、ReentrantLock可重复锁"></a>(2)、ReentrantLock可重复锁</h3><p>ReentrantLock是接口Lock的一个具体实现类，可重复使用的锁</p>
<p>使用模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// ... method body</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-、synchronized与Lock的区别"><a href="#3-、synchronized与Lock的区别" class="headerlink" title="(3)、synchronized与Lock的区别"></a>(3)、synchronized与Lock的区别</h3><p>两者区别：</p>
<ol>
<li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li>
<li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li>
<li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li>
<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li>
<li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</li>
<li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。反正Lock比synchronized牛逼就完事了。</li>
</ol>
<h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p>层次: java层次</p>
<p>前提: 线程等待时会被挂起，轮到他时会被唤醒</p>
<ul>
<li><p>公平锁： 新进程发出请求，如果此时一个线程正持有锁，或有其他线程正在等待队列中等待这个锁，那么新的线程将被放入到队列中被挂起。相当于一堆嗜睡的低血糖病人排队看医生，进去的病人门一关，外面的人便排队候着打瞌睡，轮到他时再醒醒进去</p>
</li>
<li><p>非公平锁: 新进程发出请求，如果此时一个线程正持有锁，新的线程将被放入到队列中被挂起，但如果发出请求的同时该锁变成可用状态，那么这个线程会跳过队列中所有的等待线程而获得锁。相当于排队看医生，进去的病人门一关，外面的人便排队候着打瞌睡，这时新人来了，碰巧门一开，外面的人还没完全醒来，他就乘机冲了进去。</p>
</li>
</ul>
<p>非公平锁性能高于公平锁性能的原因：</p>
<p>在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。相当于人从被叫醒要完全醒过来需要时间。</p>
<p>假设线程A持有一个锁，并且线程B请求这个锁。由于锁被A持有，因此B将被挂起。当A释放锁时，B将被唤醒，因此B会再次尝试获取这个锁。与此同时，如果线程C也请求这个锁，那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样就是一种双赢的局面：B获得锁的时刻并没有推迟，C更早的获得了锁，并且吞吐量也提高了。</p>
<p>当持有锁的时间相对较长或者请求锁的平均时间间隔较长，应该使用公平锁。在这些情况下，插队带来的吞吐量提升（当锁处于可用状态时，线程却还处于被唤醒的过程中）可能不会出现。</p>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>
<p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p>
<p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p>
<p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p>
<p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p>
<p>要点：</p>
<ul>
<li>可重入锁的一个优点是可一定程度避免死锁</li>
<li>AQS通过控制status状态来判断锁的状态，对于非可重入锁状态不是0则去阻塞；对于可重入锁如果是0则执行，非0则判断当前线程是否是获取到这个锁的线程，是的话把status状态＋1，释放的时候，只有status为0，才将锁释放。</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"获得"</span>+lockA);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"获得"</span>+lockB);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeathLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA = <span class="string">"lockA"</span>;</span><br><span class="line">        String lockB = <span class="string">"lockB"</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldThread(lockA, lockB), <span class="string">"threadAAA"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldThread(lockB, lockA), <span class="string">"threadBBB"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/16/JUC/QQ%E6%88%AA%E5%9B%BE20200403180852.png" alt></p>
<p><strong>排查流程</strong></p>
<p>首先使用jsp -l命令查看是哪个进程惹事注意，（不加-l，不显示类的全路径，增加排查难度）</p>
<img src="/2020/04/16/JUC/QQ截图20200403181044.png" style="zoom:80%;">

<img src="/2020/04/16/JUC/QQ截图20200403181757.png" style="zoom:80%;">

<p>主要是下面这一段代码，检测出了死锁</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"threadBBB":</span><br><span class="line">  waiting to lock monitor 0x0000000003308fa8 (object 0x000000076b6a08e8, a java.lang.String),</span><br><span class="line">  which is held by "threadAAA"</span><br><span class="line">"threadAAA":</span><br><span class="line">  waiting to lock monitor 0x000000000330b8e8 (object 0x000000076b6a0920, a java.lang.String),</span><br><span class="line">  which is held by "threadBBB"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"threadBBB":</span><br><span class="line">        at lzw.juc.lock.death.HoldThread.run(HoldThread.java:27)</span><br><span class="line">        - waiting to lock &lt;0x000000076b6a08e8&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x000000076b6a0920&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">"threadAAA":</span><br><span class="line">        at lzw.juc.lock.death.HoldThread.run(HoldThread.java:27)</span><br><span class="line">        - waiting to lock &lt;0x000000076b6a0920&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x000000076b6a08e8&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p>也可以使用jconsole命令,会弹出这个可视化工具，一键自动检测</p>
<img src="/2020/04/16/JUC/QQ截图20200403194758.png" style="zoom:80%;">

<img src="/2020/04/16/JUC/QQ截图20200403194905.png" style="zoom:80%;">






<h2 id="4、Lock卖票改进（卖票练习2）"><a href="#4、Lock卖票改进（卖票练习2）" class="headerlink" title="4、Lock卖票改进（卖票练习2）"></a>4、Lock卖票改进（卖票练习2）</h2><p><strong>版本2：使用Lock锁</strong></p>
<p>资源类改为Lock锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"卖出第"</span> + number-- + <span class="string">"张票,还剩"</span> + number + <span class="string">"张"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第三章-Java8之lambda表达式复习"><a href="#第三章-Java8之lambda表达式复习" class="headerlink" title="第三章 Java8之lambda表达式复习"></a>第三章 Java8之lambda表达式复习</h1><h2 id="1、什么是Lambda"><a href="#1、什么是Lambda" class="headerlink" title="1、什么是Lambda"></a>1、什么是Lambda</h2><p>Lambda 是一个匿名函数，我们可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<p>Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或剪头操作符。它将 Lambda 分为两个部分：<br>左侧：指定了 Lambda 表达式需要的所有参数<br>右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能</p>
<p>在上面的接口</p>
<h2 id="2、Lambda表达式接口实现语法"><a href="#2、Lambda表达式接口实现语法" class="headerlink" title="2、Lambda表达式接口实现语法"></a>2、Lambda表达式接口实现语法</h2><p>lambda表达式，如果一个接口只有一个方法(一个非default，非static方法)，我们可以把方法名省略</p>
<p><strong>写法：</strong></p>
<p><strong>照抄拷贝小括号（），写死右箭头-&gt;，落地大括号{…}</strong></p>
<h2 id="3、Lambda卖票改进（卖票练习2）"><a href="#3、Lambda卖票改进（卖票练习2）" class="headerlink" title="3、Lambda卖票改进（卖票练习2）"></a>3、Lambda卖票改进（卖票练习2）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++)&#123; ticket.saleTicket();&#125;&#125;,<span class="string">"A"</span>).start();</span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++)&#123; ticket.saleTicket();&#125;&#125;,<span class="string">"B"</span>).start();</span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++)&#123; ticket.saleTicket();&#125;&#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、详解Lambda表达式接口实现"><a href="#4、详解Lambda表达式接口实现" class="headerlink" title="4、详解Lambda表达式接口实现"></a>4、详解Lambda表达式接口实现</h2><p>lambda表达式，必须是函数式接口`@FunctionalInterface），必须只有一个方法<br>如果接口只有一个方法java默认它为函数式接口。<br>为了正确使用Lambda表达式，需要给接口加个注解（默认加）：@FunctionalInterface<br>如有两个方法，立刻报错</p>
<p>Runnable接口为什么可以用lambda表达式？ –》只有一个Run方法</p>
<p>但是</p>
<p>java8后接口里容许有接口default的实现(默认实现)<br>default int div(int x,int y) {<br>  return x/y;<br> }<br><strong>接口里default方法可以有几个？  多个</strong></p>
<p>且允许静态方法实现<br>public static int sub(int x,int y){<br>  return x-y;<br>}<br><strong>可以有几个？  多个</strong></p>
<p>但是在调用的时候要改成<code>Foo.sub</code>即可，不是接口的实现类去调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x/y;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x-y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Lambda Express-----&gt; 函数式编程</span></span><br><span class="line"><span class="comment"> * 1 拷贝小括号(形参列表)，写死右箭头 -&gt;，落地大括号 &#123;方法实现&#125;</span></span><br><span class="line"><span class="comment"> * 2 有且只有一个public方法<span class="doctag">@FunctionalInterface</span>注解增强定义</span></span><br><span class="line"><span class="comment"> * 3 default方法默认实现</span></span><br><span class="line"><span class="comment"> * 4 静态方法实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   Foo foo = (x,y)-&gt;&#123;</span><br><span class="line">   System.out.println(<span class="string">"Hello!! lambda !!"</span>);</span><br><span class="line">   <span class="keyword">return</span> x+y;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> result = foo.add(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">   System.out.println(<span class="string">"******result="</span>+result);</span><br><span class="line">   System.out.println(<span class="string">"******result div="</span>+foo.div(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line">   System.out.println(<span class="string">"******result sub="</span>+Foo.sub(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第四章-线程间通信"><a href="#第四章-线程间通信" class="headerlink" title="第四章 线程间通信"></a>第四章 线程间通信</h1><h2 id="1、生产者消费者问题"><a href="#1、生产者消费者问题" class="headerlink" title="1、生产者消费者问题"></a>1、生产者消费者问题</h2><p>两个核心思想</p>
<p>1、生产者+消费者</p>
<p>2、通知等待唤醒机制</p>
<p>Resources资源类，一个生产方法，一个消费方法，使用synchronized锁，然后产品为0生产，产品不为0消费，使用<code>this.notifyAll();</code>  唤醒线程，进行线程通信</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>两个线程之间的调度，没有问题，但是如果4个线程，两个生产，两个消费就会出现问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br><span class="line">C <span class="number">1</span></span><br><span class="line">A <span class="number">2</span></span><br><span class="line">C <span class="number">3</span></span><br><span class="line">A <span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>这个问题就是多线程之间的中断和虚假唤醒导致的，Java官方给出了解决方法</p>
<p>像在一个参数版本中，中断和虚假唤醒是可能的，并且该方法应该始终在循环中使用： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"> <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">                obj.wait();</span><br><span class="line">            ... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>所以上面的if换成while就可以了，根本原因就是if只会判断一次，而while会一直判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br><span class="line">C <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h2 id="2、java8新版实现生产者消费者问题"><a href="#2、java8新版实现生产者消费者问题" class="headerlink" title="2、java8新版实现生产者消费者问题"></a>2、java8新版实现生产者消费者问题</h2><p>在java8里使用新的Lock和Condition解决买票问题</p>
<p>Java官方解释</p>
<p>public interface Condition Condition因素出Object监视器方法（ wait ， notify和notifyAll ）成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果Lock个实现。 Lock替换synchronized方法和语句的使用， Condition取代了对象监视器方法的使用。<br>条件（也称为条件队列或条件变量 ）为一个线程暂停执行（“等待”）提供了一种方法，直到另一个线程通知某些状态现在可能为真。 因为访问此共享状态信息发生在不同的线程中，所以它必须被保护，因此某种形式的锁与该条件相关联。 等待条件的关键属性是它原子地释放相关的锁并挂起当前线程，就像Object.wait 。 </p>
<p>一个Condition实例本质上绑定到一个锁。 要获得特定Condition实例的Condition实例，请使用其newCondition()方法。 </p>
<p>例如，假设我们有一个有限的缓冲区，它支持put和take方法。 如果在一个空的缓冲区尝试一个take ，则线程将阻塞直到一个项目可用; 如果put试图在一个完整的缓冲区，那么线程将阻塞，直到空间变得可用。 我们希望在单独的等待集中等待put线程和take线程，以便我们可以在缓冲区中的项目或空间可用的时候使用仅通知单个线程的优化。 这可以使用两个Condition实例来实现。 </p>
<p>Java官方给出的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">     <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">     <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">     <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       lock.lock(); <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == items.length)</span><br><span class="line">           notFull.await();</span><br><span class="line">         items[putptr] = x;</span><br><span class="line">         <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">         ++count;</span><br><span class="line">         notEmpty.signal();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       lock.lock(); <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">           notEmpty.await();</span><br><span class="line">         Object x = items[takeptr];</span><br><span class="line">         <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">         --count;</span><br><span class="line">         notFull.signal();</span><br><span class="line">         <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对上面的资源类继续进行改进，改成Java8新的写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、线程间精准通知顺序访问"><a href="#3、线程间精准通知顺序访问" class="headerlink" title="3、线程间精准通知顺序访问"></a>3、线程间精准通知顺序访问</h2><p>要求：3个线程，顺序执行，a打印5次，b打印10次，c打印15次</p>
<p>思路</p>
<p>1、有顺序通知，需要有标识位</p>
<p>2、有一个锁Lock，3把钥匙Condition</p>
<p>3、判断标志位</p>
<p>4、输出线程名+第几次+第几轮</p>
<p>5、修改标志位，通知下一个</p>
<p>继续使用ReentrantLock可重复使用锁类和Condition钥匙</p>
<p>number定义为标记量，三把钥匙对应三个线程，完成一个线程操作后，&lt;font color=”red&gt;”精准通知下一个要唤醒的线程。使用c2.signal();  而不是上面的 signalAll();  精准通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//A 就要停止</span></span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t totalLoopNumber: "</span> + totalLoopNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3 通知</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//A 就要停止</span></span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t totalLoopNumber: "</span> + totalLoopNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3 通知</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">//A 就要停止</span></span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t totalLoopNumber: "</span> + totalLoopNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3 通知</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="第五章-8锁问题"><a href="#第五章-8锁问题" class="headerlink" title="第五章 8锁问题"></a>第五章 8锁问题</h1><h2 id="1、锁的8个问题"><a href="#1、锁的8个问题" class="headerlink" title="1、锁的8个问题"></a>1、锁的8个问题</h2><p>1 标准访问，先打印短信还是邮件<br>2 停4秒在短信方法内，先打印短信还是邮件<br>3 普通的hello方法，是先打短信还是hello<br>4 现在有两部手机，先打印短信还是邮件<br>5 两个静态同步方法，1部手机，先打印短信还是邮件<br>6 两个静态同步方法，2部手机，先打印短信还是邮件<br>7 1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件<br>8 1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------sendSMS"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"------sendEmail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------getHello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 8锁</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 1 标准访问，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 2 停4秒在短信方法内，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 3 新增普通的hello方法，是先打短信还是hello</span></span><br><span class="line"><span class="comment"> * 4 现在有两部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 5 两个静态同步方法，1部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 6 两个静态同步方法，2部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 7 1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 8 1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ---------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock_8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"AA"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">                <span class="comment">//phone.getHello();</span></span><br><span class="line">                <span class="comment">//phone2.sendEmail();</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"BB"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>1 标准访问，先打印短信还是邮件<br>2 停4秒在短信方法内，先打印短信还是邮件<br>3 普通的hello方法，是先打短信还是hello<br>4 现在有两部手机，先打印短信还是邮件<br>5 两个静态同步方法，1部手机，先打印短信还是邮件<br>6 两个静态同步方法，2部手机，先打印短信还是邮件<br>7 1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件<br>8 1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件</p>
<p> 运行答案：<br>1、短信<br>2、短信<br>3、Hello<br>4、邮件<br>5、短信<br>6、短信<br>7、邮件<br>8、邮件</p>
<h2 id="2、8锁分析"><a href="#2、8锁分析" class="headerlink" title="2、8锁分析"></a>2、8锁分析</h2><p>A 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，<font color="red">某一个时刻内，只能有唯一一个线程进入类中去访问这些synchronized方法，锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</font>，而加个普通方法后发现和同步锁无关</p>
<p>换成两个对象后，不是同一把锁了，情况立刻变化。</p>
<p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。<br>具体表现为以下3种形式。</p>
<ol>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。改Class对象的所有实例全部锁上，相当于小米公司停电，小米红米全部拉闸被锁了</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象</li>
</ol>
<p>总而言之，就是 静态同步方法会锁定整个类，普通同步方法会锁定该类的实例</p>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p>
<p>也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，<br>所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p>
<p>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p>
<h1 id="第六章-多线程集合类"><a href="#第六章-多线程集合类" class="headerlink" title="第六章 多线程集合类"></a>第六章 多线程集合类</h1><h2 id="1、ArrayList不安全"><a href="#1、ArrayList不安全" class="headerlink" title="1、ArrayList不安全"></a>1、ArrayList不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.print(Thread.currentThread().getName()+<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;list.size();j++)&#123;</span><br><span class="line">                    System.out.print(list.get(j)+<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 执行后会抛出java.util.ConcurrentModificationException异常</p>
<p>ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常并发修改异常</p>
<p><strong>原因剖析：</strong></p>
<p>查看ArrayList源码，看其中的add方法,其中并没有<code>synchronized</code>同步锁，这就从根本导致了ArrayList不安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同理 HashSet，HashMap也不安全（HashSet的add是放一个值，而HashMap是放K、V键值对）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、解决办法"><a href="#2、解决办法" class="headerlink" title="2、解决办法"></a>2、解决办法</h2><h3 id="1-、Vector"><a href="#1-、Vector" class="headerlink" title="(1)、Vector"></a>(1)、Vector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加了synchronized同步锁就完事了，但是这个Vector不常用，比较陌生，不推荐</p>
<h3 id="2-、Collections"><a href="#2-、Collections" class="headerlink" title="(2)、Collections"></a>(2)、Collections</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>Collections提供了方法synchronizedList保证list是同步线程安全的</p>
<p>这个也不常用，比较陌生，不推荐</p>
<h3 id="3-、写时复制"><a href="#3-、写时复制" class="headerlink" title="(3)、写时复制"></a>(3)、写时复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>不加锁性能提升出错误，加锁数据一致性能下降</p>
<p>A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.<br>CopyOnWriteArrayList是arraylist的一种线程安全变体，其中所有可变操作（add、set等）都是通过生成底层数组的新副本来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。添加元素后，再将原容器的引用指向新的容器setArray(newElements)。这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>可是这个效率低，每次写的时候都要复制一下，适合于读需求大，写需求小的地方</p>
<p>这个比较好，<font color="red">推荐使用，底层还是一个ArrayList，比较熟悉，推荐使用，以后单线程就用ArrayList，多线程就用CopyOnWriteArrayList</font></p>
<h2 id="3、多说一点集合类"><a href="#3、多说一点集合类" class="headerlink" title="3、多说一点集合类"></a>3、多说一点集合类</h2><p>这个不属于多线程的内容，是集合的基本知识，看到了写一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap在构建的时候，如果什么都不写，默认的初始容量是16和负载因子是0.75，当前的容量大于初始容量<em>负载因子时，即 16 \</em> 0.75=12 ，大于12时，扩容为2倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt;map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>1、为什么初始容量是16</p>
<p>当容量为2的幂时，上述n -1 对应的二进制数全为1，这样才能保证它和key的hashcode做&amp;运算后，能够均匀分布，这样才能减少hash碰撞的次数。至于默认值为什么是16，而不是2 、4、8，或者32、64、1024等，我想应该就是个折中处理，过小会导致放不下几个元素，就要进行扩容了，而扩容是一个很消耗性能的操作。取值过大的话，无疑会浪费更多的内存空间。因此在日常开发中，如果可以预估HashMap会存入节点的数量，则应该在初始化时，指定其容量。</p>
<p>2、为什么负载因子是0.75</p>
<p>也是一个综合考虑，如果设置过小，HashMap每put少量的数据，都要进行一次扩容，而扩容操作会消耗大量的性能。如果设置过大的话，如果设成1，容量还是16，假设现在数组上已经占用的15个，再要put数据进来，计算数组index时，发生hash碰撞的概率将达到15/16，这违背的HashMap减少hash碰撞的原则。</p>
<p>HashMap扩容为原来的两倍</p>
<p>ArrayList扩容为原来的1.5倍（加上原来的一半）</p>
<h1 id="第七章-Callable接口"><a href="#第七章-Callable接口" class="headerlink" title="第七章 Callable接口"></a>第七章 Callable接口</h1><h2 id="1、Callable接口介绍"><a href="#1、Callable接口介绍" class="headerlink" title="1、Callable接口介绍"></a>1、Callable接口介绍</h2><p><strong>面试题：获得多线程的方法几种？</strong><br>（1）继承thread类（2）runnable接口<br>如果只回答这两个你连被问到JUC的机会都没有 </p>
<p>第三种 Callable接口</p>
<p>Callable接口是一个函数式接口，因此可以用作lambda表达式或方法引用的赋值对象。</p>
<img src="/2020/04/16/JUC/QQ截图20200221220621.png" style="zoom:1200%;">

<h2 id="2、与runnable接口对比"><a href="#2、与runnable接口对比" class="headerlink" title="2、与runnable接口对比"></a>2、与runnable接口对比</h2><p>创建新类MyThread实现runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新类MyThread2实现callable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 面试题:callable接口与runnable接口的区别？</p>
<ol>
<li>是否有返回值</li>
<li>是否抛异常</li>
<li>落地方法不一样，一个是run，一个是call</li>
</ol>
<h2 id="3、怎么用？"><a href="#3、怎么用？" class="headerlink" title="3、怎么用？"></a>3、怎么用？</h2><img src="/2020/04/16/JUC/QQ截图20200221220912.png" style="zoom:100%;">

<p>可以看到一个很尴尬的事情，在线程的8个构造方法里面没有涉及到callable接口参数的构造方法，最常用的第三个方法也是runnable接口参数的构造方法。</p>
<p>Java官方早就知道了这个问题，所以神奇的设计模式他来了，适配器模式完美解决</p>
<p>RunnableFuture接口继承了Runnable接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>而有一个FutureTask类实现了RunnableFuture接口，且其中的构造方法涉及到了callable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">     <span class="title">public</span> <span class="title">FutureTask</span>(<span class="title">Callable</span>&lt;<span class="title">V</span>&gt; <span class="title">callable</span>) </span>&#123;</span><br><span class="line">     	<span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        	<span class="keyword">this</span>.callable = callable;</span><br><span class="line">        	<span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">   		&#125;</span><br></pre></td></tr></table></figure>

<p>所以在使用的时候，先使用FutureTask过度一下，然后就可以Thread来创建线程了</p>
<p>这就是Java多态和设计模式的妙啊</p>
<h2 id="4、FutureTask"><a href="#4、FutureTask" class="headerlink" title="4、FutureTask"></a>4、FutureTask</h2><h3 id="1-、是什么"><a href="#1-、是什么" class="headerlink" title="(1)、是什么"></a>(1)、是什么</h3><p>未来的任务，用它就干一件事，异步调用main方法就像一个冰糖葫芦，一个个方法由main串起来。<br>但解决不了一个问题：正常调用挂起堵塞问题</p>
<p> 例子：<br>（1）老师上着课，口渴了，去买水不合适，讲课线程继续，我可以单起个线程找班长帮忙买水，<br>水买回来了放桌上，我需要的时候再去get。<br>（2）4个同学，A算1+20,B算21+30,C算31*到40,D算41+50，是不是C的计算量有点大啊，<br>FutureTask单起个线程给C计算，我先汇总ABD，最后等C计算完了再汇总C，拿到最终结果<br>（3）高考：会做的先做，不会的放在后面做</p>
<h3 id="2-、原理"><a href="#2-、原理" class="headerlink" title="(2)、原理"></a>(2)、原理</h3><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，<br>当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。</p>
<p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>
<p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。 </p>
<p>只会使用计算一次，get方法放到最后</p>
<h3 id="3-、代码"><a href="#3-、代码" class="headerlink" title="(3)、代码"></a>(3)、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" come in callable"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"A"</span>).start();</span><br><span class="line">        System.out.println(<span class="string">"Main Finish"</span>);</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Main Finish</span><br><span class="line">A come in callable</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>futureTask会另开一个线程，单独计算，不影响其他线程运行</p>
<h1 id="第八章-JUC强大的辅助类讲解"><a href="#第八章-JUC强大的辅助类讲解" class="headerlink" title="第八章 JUC强大的辅助类讲解"></a>第八章 JUC强大的辅助类讲解</h1><h2 id="1、CountDownLatch-减少计数"><a href="#1、CountDownLatch-减少计数" class="headerlink" title="1、CountDownLatch 减少计数"></a>1、CountDownLatch 减少计数</h2><p>例子：CountDownLatchDemo        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//6个上自习的同学，各自离开教室的时间不一致</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName()+<span class="string">"\t 号同学离开教室"</span>);</span><br><span class="line">          &#125;, String.valueOf(i)).start();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">"\t****** 班长关门走人，main线程是班长"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span>	 号同学离开教室</span><br><span class="line"><span class="number">2</span>	 号同学离开教室</span><br><span class="line">main	****** 班长关门走人，main线程是班长</span><br><span class="line"><span class="number">3</span>	 号同学离开教室</span><br><span class="line"><span class="number">4</span>	 号同学离开教室</span><br><span class="line"><span class="number">5</span>	 号同学离开教室</span><br><span class="line"><span class="number">6</span>	 号同学离开教室</span><br></pre></td></tr></table></figure>

<p>这样的话班长关门走人了，而其他线程还在教室，这样就不对，为了方便规定线程之间的顺序，使用CountDownLatch</p>
<p><strong>原理</strong></p>
<ul>
<li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</li>
<li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</li>
<li>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。    </li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;        </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">  *  *让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</span></span><br><span class="line"><span class="comment">  * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</span></span><br><span class="line"><span class="comment">  * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 解释：6个同学陆续离开教室后值班同学才可以关门。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">         CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//6个上自习的同学，各自离开教室的时间不一致</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName()+<span class="string">"\t 号同学离开教室"</span>);</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">          &#125;, String.valueOf(i)).start();</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">"\t****** 班长关门走人，main线程是班长"</span>);</span><br><span class="line">          </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">2</span>	 号同学离开教室</span><br><span class="line"><span class="number">1</span>	 号同学离开教室</span><br><span class="line"><span class="number">3</span>	 号同学离开教室</span><br><span class="line"><span class="number">5</span>	 号同学离开教室</span><br><span class="line"><span class="number">6</span>	 号同学离开教室</span><br><span class="line"><span class="number">4</span>	 号同学离开教室</span><br><span class="line">main	****** 班长关门走人，main线程是班长</span><br></pre></td></tr></table></figure>
<p>只关心线程是否全部做完，而不管具体的顺序。</p>
<h2 id="2、CyclicBarrier-循环栅栏"><a href="#2、CyclicBarrier-循环栅栏" class="headerlink" title="2、CyclicBarrier 循环栅栏"></a>2、CyclicBarrier 循环栅栏</h2><p>例子：CyclicBarrierDemo<br>        原理</p>
<ul>
<li>CyclicBarrier</li>
<li>的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</li>
<li>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</li>
<li>直到最后一个线程到达屏障时，屏障才会开门，所有</li>
<li>被屏障拦截的线程才会继续干活。</li>
<li>线程进入屏障通过CyclicBarrier的await()方法。</li>
</ul>
<p>上面的<code>CountDownLatch</code>是所有线程都执行完后，才放行下一个要做的，做减法</p>
<p>这个<code>CyclicBarrier</code>是所有线程都到齐之后，才执行下一个要做，做加法</p>
<p>​    </p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CyclicBarrier</span></span><br><span class="line"><span class="comment"> * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</span></span><br><span class="line"><span class="comment"> * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</span></span><br><span class="line"><span class="comment"> * 直到最后一个线程到达屏障时，屏障才会开门，所有</span></span><br><span class="line"><span class="comment"> * 被屏障拦截的线程才会继续干活。</span></span><br><span class="line"><span class="comment"> * 线程进入屏障通过CyclicBarrier的await()方法。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 集齐7颗龙珠就可以召唤神龙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//CyclicBarrier(int parties, Runnable barrierAction)</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(NUMBER, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"*****集齐7颗龙珠就可以召唤神龙"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 星龙珠被收集 "</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span>	 星龙珠被收集 </span><br><span class="line"><span class="number">3</span>	 星龙珠被收集 </span><br><span class="line"><span class="number">2</span>	 星龙珠被收集 </span><br><span class="line"><span class="number">4</span>	 星龙珠被收集 </span><br><span class="line"><span class="number">6</span>	 星龙珠被收集 </span><br><span class="line"><span class="number">5</span>	 星龙珠被收集 </span><br><span class="line"><span class="number">7</span>	 星龙珠被收集 </span><br><span class="line">*****集齐<span class="number">7</span>颗龙珠就可以召唤神龙</span><br></pre></td></tr></table></figure>



<h2 id="3、Semaphore-信号灯（PV原语操作）"><a href="#3、Semaphore-信号灯（PV原语操作）" class="headerlink" title="3、Semaphore 信号灯（PV原语操作）"></a>3、Semaphore 信号灯（PV原语操作）</h2><p><strong>原理</strong></p>
<p> 在信号量上我们定义两种操作：</p>
<ul>
<li>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），</li>
<li>要么一直等下去，直到有线程释放信号量，或超时。</li>
<li>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</li>
<li>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</li>
</ul>
<p>其实就是PV原语操作</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在信号量上我们定义两种操作：</span></span><br><span class="line"><span class="comment">  * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），</span></span><br><span class="line"><span class="comment">  *     要么一直等下去，直到有线程释放信号量，或超时。</span></span><br><span class="line"><span class="comment">  * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);<span class="comment">//模拟3个停车位</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//模拟6部汽车</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> </span><br><span class="line">          &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 抢到了车位"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t------- 离开"</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span>	 抢到了车位</span><br><span class="line"><span class="number">2</span>	 抢到了车位</span><br><span class="line"><span class="number">3</span>	 抢到了车位</span><br><span class="line"><span class="number">2</span>	------- 离开</span><br><span class="line"><span class="number">4</span>	 抢到了车位</span><br><span class="line"><span class="number">4</span>	------- 离开</span><br><span class="line"><span class="number">5</span>	 抢到了车位</span><br><span class="line"><span class="number">1</span>	------- 离开</span><br><span class="line"><span class="number">3</span>	------- 离开</span><br><span class="line"><span class="number">6</span>	 抢到了车位</span><br><span class="line"><span class="number">6</span>	------- 离开</span><br><span class="line"><span class="number">5</span>	------- 离开</span><br></pre></td></tr></table></figure>

<p>就是PV原语操作，抢资源 -1，为0等待，释放资源+1</p>
<h2 id="4、ReentrantReadWriteLock读写锁"><a href="#4、ReentrantReadWriteLock读写锁" class="headerlink" title="4、ReentrantReadWriteLock读写锁"></a>4、ReentrantReadWriteLock读写锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在写"</span> + key);</span><br><span class="line">        <span class="comment">//暂停一会儿线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 写完了"</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在读"</span> + key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        result = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 读完了"</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(num + <span class="string">""</span>, num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span>	 正在写<span class="number">1</span></span><br><span class="line"><span class="number">2</span>	 正在写<span class="number">2</span></span><br><span class="line"><span class="number">3</span>	 正在写<span class="number">3</span></span><br><span class="line"><span class="number">4</span>	 正在写<span class="number">4</span></span><br><span class="line"><span class="number">5</span>	 正在写<span class="number">5</span></span><br><span class="line"><span class="number">1</span>	 正在读<span class="number">1</span></span><br><span class="line"><span class="number">2</span>	 正在读<span class="number">2</span></span><br><span class="line"><span class="number">3</span>	 正在读<span class="number">3</span></span><br><span class="line"><span class="number">4</span>	 正在读<span class="number">4</span></span><br><span class="line"><span class="number">5</span>	 正在读<span class="number">5</span></span><br><span class="line"><span class="number">1</span>	 写完了<span class="number">1</span></span><br><span class="line"><span class="number">2</span>	 读完了<span class="keyword">null</span></span><br><span class="line"><span class="number">1</span>	 读完了<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可以看到没有锁的情况下，违反了原子性，1还没有写完，其他的操作又进来了，使用读写锁解决</p>
<ul>
<li>读-读可共享</li>
<li>读-写不可共享</li>
<li>写-写不可可共享</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在写"</span> + key);</span><br><span class="line">            <span class="comment">//暂停一会儿线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 写完了"</span> + key);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在读"</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 读完了"</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(num + <span class="string">""</span>, num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span>	 正在写<span class="number">1</span></span><br><span class="line"><span class="number">1</span>	 写完了<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>	 正在写<span class="number">2</span></span><br><span class="line"><span class="number">2</span>	 写完了<span class="number">2</span></span><br></pre></td></tr></table></figure>





<h1 id="第九章-阻塞队列"><a href="#第九章-阻塞队列" class="headerlink" title="第九章 阻塞队列"></a>第九章 阻塞队列</h1><h2 id="1、阻塞队列是什么"><a href="#1、阻塞队列是什么" class="headerlink" title="1、阻塞队列是什么"></a>1、阻塞队列是什么</h2><p>阻塞：必须要阻塞/不得不阻塞<br>阻塞队列是一个队列，在数据结构中起的作用如下图：</p>
<img src="/2020/04/16/JUC/批注 2020-02-22 134107.png" style="zoom: 60%;">
线程1往阻塞队列里添加元素，线程2从阻塞队列里移除元素

<p>当队列是空的，从队列中获取元素的操作将会被阻塞<br>当队列是满的，从队列中添加元素的操作将会被阻塞</p>
<p>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</p>
<p>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</p>
<h2 id="2、阻塞队列的用处"><a href="#2、阻塞队列的用处" class="headerlink" title="2、阻塞队列的用处"></a>2、阻塞队列的用处</h2><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p>
<p>为什么需要BlockingQueue<br>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p>
<p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<p>有的时候需要线程进行阻塞，比如海底捞 候客区 一直等里面的空位置</p>
<h2 id="3、架构梳理-种类分析"><a href="#3、架构梳理-种类分析" class="headerlink" title="3、架构梳理 种类分析"></a>3、架构梳理 种类分析</h2><p>BlockingQueue是Queue下的一个接口，</p>
<img src="/2020/04/16/JUC/批注 2020-02-22 134700.png" style="zoom:67%;">

<p>而具体的实现类有以下7个（红色的具体掌握）<br><img src="/2020/04/16/JUC/批注 2020-02-22 134813.png" style="zoom:120%;"></p>
<ul>
<li><font color="red">ArrayBlockingQueue：由数组结构组成的有界阻塞队列。</font></li>
<li><font color="red">LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</font></li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</li>
<li><font color="red">SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。</font></li>
<li>LinkedTransferQueue：由链表组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：由链表组成的双向阻塞队列。(Deque是Double Queue的意思)</li>
</ul>
<h2 id="4、BlockingQueue核心方法API"><a href="#4、BlockingQueue核心方法API" class="headerlink" title="4、BlockingQueue核心方法API"></a>4、BlockingQueue核心方法API</h2><img src="/2020/04/16/JUC/QQ截图20200222162827.png" style="zoom:80%;">

<p>*<em>抛出异常 *</em></p>
<ul>
<li>当阻塞队列满时，再往队列里add插入元素会抛IllegalStateException:Queue full</li>
<li>当阻塞队列空时，再往队列里remove移除元素会抛NoSuchElementException</li>
</ul>
<p><strong>特殊值</strong></p>
<ul>
<li>插入方法，成功ture失败false</li>
<li>移除方法，成功返回出队列的元素，队列里没有就返回null</li>
</ul>
<p><strong>一直阻塞</strong></p>
<ul>
<li>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出</li>
<li>当阻塞队列空时，消费者线程试图从队列里take元素队列会一直阻塞消费者线程直到队列可用</li>
</ul>
<p><strong>超时退出</strong></p>
<ul>
<li>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</li>
</ul>
<h1 id="第十章-ThreadPool线程池"><a href="#第十章-ThreadPool线程池" class="headerlink" title="第十章 ThreadPool线程池"></a>第十章 ThreadPool线程池</h1><h2 id="1、为什么用线程池"><a href="#1、为什么用线程池" class="headerlink" title="1、为什么用线程池"></a>1、为什么用线程池</h2><p>例子：<br>10年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需要来回切换。<br>现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。</p>
<p>线程池的优势：<br>线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>它的主要特点为：<font color="red">线程复用  控制最大并发数 管理线程。</font></p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h2 id="2、线程池如何使用"><a href="#2、线程池如何使用" class="headerlink" title="2、线程池如何使用"></a>2、线程池如何使用</h2><h3 id="1-、架构说明"><a href="#1-、架构说明" class="headerlink" title="(1)、架构说明"></a>(1)、架构说明</h3><p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类</p>
<img src="/2020/04/16/JUC/QQ截图20200222170202.png" style="zoom:80%;">



<h3 id="2-、线程池三大实现"><a href="#2-、线程池三大实现" class="headerlink" title="(2)、线程池三大实现"></a>(2)、线程池三大实现</h3><ol>
<li>Executors.newFixedThreadPool(int) 执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程</li>
<li>Executors.newSingleThreadExecutor() 一个任务一个任务的执行，一池一线程</li>
<li>Executors.newCachedThreadPool() 执行很多短期异步任务，线程池根据需要创建新线程，但在先前构建的线程可用时将重用它们。可扩容，遇强则强  （这个类似于ArrayList，可以扩容，能根据线程使用情况自动分配最合适的线程数，任务来的慢，可以是一个线程，任务来的快，自动变成多线程）</li>
</ol>
<p>下面代码中的<code>Executors</code> 是线程池中的一个工具类，里面都是静态方法，类似于Arrays工具类，提供了不同线程池的创建方法，不用new了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//固定数的线程池，一池五线程，一个银行网点，5个受理业务的窗口</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个银行网点，1个受理业务的窗口</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool =  Executors.newSingleThreadExecutor();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个银行网点，可扩展受理业务的窗口</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool =  Executors.newCachedThreadPool();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"\t 办理业务"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、ThreadPoolExecutor底层原理"><a href="#3、ThreadPoolExecutor底层原理" class="headerlink" title="3、ThreadPoolExecutor底层原理"></a>3、ThreadPoolExecutor底层原理</h2><h3 id="1-、三大实现都是ThreadPoolExecutor"><a href="#1-、三大实现都是ThreadPoolExecutor" class="headerlink" title="(1)、三大实现都是ThreadPoolExecutor"></a>(1)、三大实现都是ThreadPoolExecutor</h3><p>看起来线程池三大实现有三个实现方法，但是抽丝剥茧，代码在下面，可以看出都是一个方法，不同的5个参数罢了，使用到了TimeUnit.MILLISECONDS和阻塞队列</p>
<p>初始化的线程数</p>
<p>newFixedThreadPool是自己设定</p>
<p>newSingleThreadExecutor恒为1</p>
<p>newCachedThreadPool的是0和 Integer.MAX_VALUE  还有阻塞队列上面都是LinkedBlockingQueue，而它是SynchronousQueue，当前线程被锁了，就创建新的，妙啊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-、ThreadPoolExecutor-七大参数"><a href="#2-、ThreadPoolExecutor-七大参数" class="headerlink" title="(2)、ThreadPoolExecutor 七大参数"></a>(2)、ThreadPoolExecutor 七大参数</h3><p>不是看上面的参数，只有5个，点进ThreadPoolExecutor里面去，一共7大参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ol>
<li>corePoolSize：线程池中的常驻核心线程数</li>
<li>maximumPoolSize：线程池中能够容纳同时执行的最大线程数，<font color="red">此值必须大于等于1</font></li>
<li>keepAliveTime：多余的空闲线程的存活时间当前池中线程数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止</li>
<li>unit：keepAliveTime的单位 </li>
<li>workQueue：阻塞任务队列，被提交但尚未被执行的任务</li>
<li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，<font color="red">一般默认的即可</font></li>
<li>handler：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略</li>
</ol>
<p>拒绝策略下面会详讲</p>
<p>上面的三大实现都是指定1<del>5的内容，6</del>7采用默认即可</p>
<h3 id="3-、线程池底层工作原理"><a href="#3-、线程池底层工作原理" class="headerlink" title="(3)、线程池底层工作原理"></a>(3)、线程池底层工作原理</h3><img src="/2020/04/16/JUC/QQ截图20200222175107.png" style="zoom: 200%;">

<ol>
<li>在创建了线程池后，开始等待请求。</li>
<li>当调用execute()方法添加一个请求任务时，线程池会做出如下判断：<ul>
<li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</li>
<li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</li>
<li>如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>
<li>如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</li>
</ul>
</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：<ul>
<li>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。</li>
<li>所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</li>
</ul>
</li>
</ol>
<h3 id="4-、线程池的拒绝策略"><a href="#4-、线程池的拒绝策略" class="headerlink" title="(4)、线程池的拒绝策略"></a>(4)、线程池的拒绝策略</h3><h2 id="4、手写线程池"><a href="#4、手写线程池" class="headerlink" title="4、手写线程池"></a>4、手写线程池</h2><h3 id="1-、超级大坑"><a href="#1-、超级大坑" class="headerlink" title="(1)、超级大坑"></a>(1)、超级大坑</h3><p>在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？超级大坑</p>
<p><strong><font color="red">答案是一个都不用，我们工作中只能使用自定义的</font></strong>    Executors中JDK已经给你提供了，为什么不用？</p>
<p>阿里巴巴Java开发手册中明确写出不允许使用 Executors 去创建</p>
<p><img src="/2020/04/16/JUC/QQ%E6%88%AA%E5%9B%BE20200222181114.png" alt></p>
<h3 id="2-、手写线程池"><a href="#2-、手写线程池" class="headerlink" title="(2)、手写线程池"></a>(2)、手写线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    	<span class="number">2</span>,  <span class="comment">//corePoolSize：线程池中的常驻核心线程数</span></span><br><span class="line">        Runtime.getRuntime().availableProcessors(), <span class="comment">//maximumPoolSize 最大线程数</span></span><br><span class="line">        <span class="number">3</span>,  <span class="comment">//存活时间</span></span><br><span class="line">        TimeUnit.SECONDS, <span class="comment">//存活时间单位</span></span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>),  <span class="comment">//阻塞任务队列</span></span><br><span class="line">        Executors.defaultThreadFactory(),   <span class="comment">//默认线程工厂</span></span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());  <span class="comment">//拒绝策略</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">"\t办理业务"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中最大线程数应当和本机线程数一致？</p>
<p>阻塞任务队列初始化的时候一定要复制，默认的话，直接就是Integer最大值 21亿多了，没用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中手写的线程池最大可容纳任务为最大线程数+阻塞任务队列容量，这个线程池是3+5=8，超过8个，就使用拒绝策略</p>
<h4 id="合理配置线程池的最大数量"><a href="#合理配置线程池的最大数量" class="headerlink" title="合理配置线程池的最大数量"></a>合理配置线程池的最大数量</h4><ul>
<li><p>CPU密集型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());<span class="comment">//查看CPU核数</span></span><br></pre></td></tr></table></figure>
<p>一般CPU密集型的都是CPU核数+1,8核CPU配9个</p>
</li>
<li><p>IO密集型</p>
</li>
</ul>
<ol>
<li>IO密集型任务 可以使用稍大的线程池，一般为2*CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。混合型任务 可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。 因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</li>
<li><img src="/2020/04/16/JUC/%E5%9B%BE%E5%83%8F.bmp" alt></li>
</ol>
<p>8/(1-0.9)=80</p>
<p>下面详解拒绝策略</p>
<h3 id="3-、拒绝策略"><a href="#3-、拒绝策略" class="headerlink" title="(3)、拒绝策略"></a>(3)、拒绝策略</h3><p>等待队列已经排满了，再也塞不下新任务了同时，线程池中的max线程也达到了，无法继续为新任务服务。这个是时候我们就需要拒绝策略机制合理的处理这个问题。</p>
<p>JDK内置了4种拒绝策略</p>
<ol>
<li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.RejectedExecutionException: Task test.MyThreadPoolDemo.MyPoolDemo$$Lambda$<span class="number">1</span>/<span class="number">1096979270</span>@<span class="number">7</span>cca494b rejected from java.util.concurrent.ThreadPoolExecutor@<span class="number">7</span>ba4f24f[Running, pool size = <span class="number">4</span>, active threads = <span class="number">4</span>, queued tasks = <span class="number">5</span>, completed tasks = <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。这里直接返回给了main线程，从哪来，回哪去</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>	 办理业务</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。</li>
</ol>
<p>只办理了9个，第10个被抛弃了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>	 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>	 办理业务</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。和上面的DiscardOldestPolicy差不多</li>
</ol>
<p>这4种拒绝策略均实现了RejectedExecutionHandle接口，可以直接使用</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>JUC详解</p>
    
    <p><span class="copy-title">本文作者:</span><a  title="John Doe">John Doe</a></p>
    <p><span class="copy-title">发布时间:</span>2020-04-16, 00:00:00</p>
    <p><span class="copy-title">最后更新:</span>2020-04-16, 17:47:58</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2020/04/16/JUC/" title="JUC详解">http://yoursite.com/2020/04/16/JUC/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 Yelog</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#JavaSe','#JUC','#设计模式',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
