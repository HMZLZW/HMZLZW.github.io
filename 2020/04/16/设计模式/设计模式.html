<hr>
<p>title: 设计模式<br>date: 2020-4-16<br>comments: true<br>toc: true<br>categories: “Java基础”<br>tags:<br>    - JavaSe<br>    - 设计模式</p>
<hr>
<p>设计模式就像一本书的目录，会起到提纲挈领的作用。<br>但是光靠目录，是无法完全掌握这本书的。<br>当我们看完这本书，再回过头来看看这个目录，会觉得这个目录的总结挺到位的。</p>
<p>后面我们自己写书的时候，可以参考前一本书的目录大纲的方式，高效完成一部书。</p>
<p>总之，没有编码经验，初学设计模式，<strong>囫囵吞枣即可</strong>，后面有一定编码经验，<strong>再细细回味</strong>。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p>
<h1 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h1><p>​        所谓类的单例设计模式，就是 采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，<br>并且该类只提供一个取得其对象实例的方法(静态方法)。<br>​        比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。</p>
<ul>
<li><p><font color=red>饿汉式( 静态常量) </font>      饿汉式 通过反射或者序列化会破坏单例？</p>
</li>
<li><p><font color=red>饿汉式（静态代码块） </font></p>
</li>
<li><p>懒汉式(线程不安全)</p>
</li>
<li><p>懒汉式(线程安全，同步方法)</p>
</li>
<li><p>懒汉式(线程安全，同步代码块)</p>
</li>
<li><p><font color=red>双重检查 </font></p>
</li>
<li><p><font color=red>静态内部类 </font></p>
</li>
<li><p><font color=red>枚举 </font></p>
<p><font color=red>（红色推荐使用）</font></p>
</li>
</ul>
<h2 id="1、八种实现方法"><a href="#1、八种实现方法" class="headerlink" title="1、八种实现方法"></a>1、八种实现方法</h2><h3 id="（1）、饿汉式（静态常量）"><a href="#（1）、饿汉式（静态常量）" class="headerlink" title="（1）、饿汉式（静态常量）"></a>（1）、饿汉式（静态常量）</h3><ol>
<li><p>步骤如下：<br>1) 构造器私有化 (防止 new )<br>2) 类的内部创建对象<br>3) 向外暴露一个静态的公共方法。getInstance<br>4) 代码实现</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest01</span> </span>{
 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
     <span class="comment">//测试</span>
<span class="comment">//        Singleton a=new Singleton();</span>
<span class="comment">//        System.out.println("a.hashCode=" + a.hashCode());</span>

     Singleton instance = Singleton.getInstance();
     Singleton instance2 = Singleton.getInstance();
     System.out.println(instance == instance2); <span class="comment">// true</span>
     System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());
     System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());
 }
}
</code></pre>
</li>
</ol>
<p>class Singleton {<br>    //1. 构造器私有化, 外部能 new<br>    private Singleton() {<br>    }</p>
<pre><code>//2.本类内部创建对象实例
private final static Singleton instance = new Singleton();

//3. 提供一个公有的静态方法，返回实例对象
public static Singleton getInstance() {
    return instance;
}</code></pre><p>}</p>
<pre><code>


####  补：构造器私有化

构造方法是私有的，则意味着无法从除自身之外的任何类访问它。这是Java提供的访问控制机制。

```java
class Singleton{
    static Singleton instance = new Singleton() ;    // 在内部产生本类的实例化对象
    private Singleton(){        // 将构造方法进行了封装，私有化    
    }
    public void print(){
        System.out.println(&quot;Hello World!!!&quot;) ;
    }
};
public class SingletonDemo04{
    public static void main(String args[]){
        Singleton s1 = null ;    // 声明对象
        s1 = Singleton.instance ;    // 通过类取得实例化对象
        s1.print() ;        // 调用方法
    }
};

运行结果：hello world！！</code></pre><h4 id="优缺点说明："><a href="#优缺点说明：" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。<br>2) 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则<br>会造成内存的浪费<br>3) 这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大<br>多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静<br>态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果<br><strong><font color=red>4) 结论：这种单例模式可用，可能造成内存浪费,不管有没有使用，反正就加载了，资源浪费</font></strong></p>
<h3 id="（2）、饿汉式（静态代码块）"><a href="#（2）、饿汉式（静态代码块）" class="headerlink" title="（2）、饿汉式（静态代码块）"></a>（2）、饿汉式（静态代码块）</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest02</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2); <span class="comment">// true</span>
        System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());
        System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{
    <span class="comment">//1. 构造器私有化, 外部能 new</span>
    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{
    }

    <span class="comment">//2.本类内部创建对象实例</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance ;

    <span class="comment">// 在静态代码块中，创建单例对象</span>
    <span class="keyword">static</span> {
        instance = <span class="keyword">new</span> Singleton();
    }

    <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> instance;
    }
}
</code></pre>
<h4 id="优缺点说明：-1"><a href="#优缺点说明：-1" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了<strong>静态代码块</strong>中，也是在类装载的时候，就执<br>行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。<br><strong><font color=red>2) 结论：这种单例模式可用，但是可能造成内存浪费</font></strong></p>
<p><strong>饿汉式：都是在类加载的时候产生这个类的实例，只是实现方法有些许差异</strong></p>
<h3 id="（3）、懒汉式-线程不安全"><a href="#（3）、懒汉式-线程不安全" class="headerlink" title="（3）、懒汉式(线程不安全)"></a>（3）、懒汉式(线程不安全)</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest03</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2); <span class="comment">// true</span>
        System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());
        System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;
    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{}
    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance，即懒汉式</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{
        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) {
            instance = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> instance;
    }
}</code></pre>
<h4 id="优缺点说明：-2"><a href="#优缺点说明：-2" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 起到了 <strong>Lazy Loading</strong> 的效果，但是只能在单线程下使用。<br>2) 如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过<br>了这个判断语句，这时便会 产生多个实例。所以在多线程环境下不可使用这种方式<br><strong><font color=red>3) 结论：在实际开发中， 不要使用这种方式.</font></strong></p>
<h3 id="（4）、懒汉式-线程安全，同步方法"><a href="#（4）、懒汉式-线程安全，同步方法" class="headerlink" title="（4）、懒汉式(线程安全，同步方法)"></a>（4）、懒汉式(线程安全，同步方法)</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest04</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Singleton instance = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        System.out.println(instance == instance2); <span class="comment">// true</span>
        System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());
        System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;
    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{}
    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance，即懒汉式</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{
        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) {
            instance = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> instance;
    }
}
</code></pre>
<h4 id="补：synchronized"><a href="#补：synchronized" class="headerlink" title="补：synchronized"></a>补：synchronized</h4><p>在并发编程中存在线程安全问题，主要原因有：1.存在共享数据 2.多线程共同操作共享数据。关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。</p>
<p><a href="https://blog.csdn.net/zjy15203167987/article/details/82531772" target="_blank" rel="noopener">【Java并发编程之深入理解】Synchronized的使用</a></p>
<h4 id="优缺点说明：-3"><a href="#优缺点说明：-3" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 解决了 线程安全问题<br>2) 效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行<br>一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。 方法进行同步效率太低。<br><strong><font color=red>3) 结论：在实际开发中， 不推荐使用这种方式</font></strong></p>
<h3 id="（5）、懒汉式-线程安全，同步代码块"><a href="#（5）、懒汉式-线程安全，同步代码块" class="headerlink" title="（5）、懒汉式(线程安全，同步代码块)"></a>（5）、懒汉式(线程安全，同步代码块)</h3><pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;
    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{}
    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance，即懒汉式</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{
        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) {
            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>{
                instance = <span class="keyword">new</span> Singleton();
            }
        }
        <span class="keyword">return</span> instance;
    }
}</code></pre>
<p>   这种方法根本就是<font color=red>错误的写法</font>，仍然线程不安全，多个线程同时进入if语句还是没有办法锁住，会创建多个实例，这是一个错误示例，开发中有人曾这么干，面试可能问。<br>   <strong><font color=red>结论：在实际开发中， 不能使用这种方式</font></strong></p>
<h3 id="（6）、双重检查"><a href="#（6）、双重检查" class="headerlink" title="（6）、双重检查"></a>（6）、双重检查</h3><pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;
    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{}
    <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span>
    <span class="comment">//同时保证了效率, 推荐使用</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{
        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) {   <span class="comment">//进来的时候检查一次</span>
            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>{
                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) {   <span class="comment">//进锁之后，再检查一次</span>
                    instance = <span class="keyword">new</span> Singleton();
                }
            }
        }
        <span class="keyword">return</span> instance;
    }
}</code></pre>
<p>双重检锁虽然是线程安全的，会出现内部成员变量空指针异常，如果要使用，需将类实例用volatile修饰</p>
<h4 id="补：volatile"><a href="#补：volatile" class="headerlink" title="补：volatile"></a>补：volatile</h4><p>在并发编程中存在线程安全问题，主要原因有：1.存在共享数据 2.多线程共同操作共享数据。关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。</p>
<p><a href="https://www.jianshu.com/p/b05e4da39de9" target="_blank" rel="noopener">volatile详解</a></p>
<h4 id="优缺点说明：-4"><a href="#优缺点说明：-4" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这<br>样就可以保证线程安全了。<br>2) 这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避<br>免的反复进行方法同步.<br><strong>3) 线程安全； 延迟加载； 效率较高</strong><br><strong><font color=red>4) 结论：在实际开发中， 推荐使用这种单例设计模式。</font></strong></p>
<h3 id="（7）、静态内部类"><a href="#（7）、静态内部类" class="headerlink" title="（7）、静态内部类"></a>（7）、静态内部类</h3><pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;
    <span class="comment">//构造器私有化</span>
    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{}
    <span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>{
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();
    }
    <span class="comment">//提供一个静态的公有方法，直接返回 SingletonInstance.INSTANCE</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> SingletonInstance.INSTANCE;
    }
}</code></pre>
<h4 id="优缺点说明：-5"><a href="#优缺点说明：-5" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。<br>2) 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才<br>会装载 SingletonInstance 类，从而完成 Singleton 的实例化。<br>3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行<br>初始化时，别的线程是无法进入的。<br>4) 优点： 避免了线程不安全，利用 静态内部类特点实现延迟加载，效率高<br><strong><font color=red>5) 结论：在实际开发中， 推荐使用这种单例设计模式。</font></strong></p>
<h3 id="（8）、枚举"><a href="#（8）、枚举" class="headerlink" title="（8）、枚举"></a>（8）、枚举</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest08</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Singleton instance = Singleton.INSTANCE;
        Singleton instance2 = Singleton.INSTANCE;
        System.out.println(instance == instance2);
        System.out.println(instance.hashCode());
        System.out.println(instance2.hashCode());
        instance.sayOK();
    }
}

<span class="comment">//使用枚举，可以实现单例, 推荐</span>
<span class="keyword">enum</span> Singleton {
    INSTANCE; <span class="comment">//属性</span>

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>{
        System.out.println(<span class="string">"ok~"</span>);
    }
}</code></pre>
<h4 id="优缺点说明：-6"><a href="#优缺点说明：-6" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建<br>新的对象。<br>2) 这种方式是 Effective Java  作者 Josh Bloch  提倡的方式<br>3) 枚举真正实现了单例，把反序列化和反射创建第二对象的路都堵死了！<br><strong><font color=red>4) 结论：在实际开发中， 推荐使用这种单例设计模式。</font></strong></p>
<h2 id="2、单例模式在-JDK-应用的源码分析"><a href="#2、单例模式在-JDK-应用的源码分析" class="headerlink" title="2、单例模式在 JDK 应用的源码分析"></a>2、单例模式在 JDK 应用的源码分析</h2><p> 单例模式在 JDK 应用的源码分析</p>
<p>  我们 JDK 中，java.lang.Runtime 就是经典的单例模式(饿汉式)</p>
<pre><code class="java"><span class="comment">//JDK源码 Runtime类（局部）使用  饿汉式（静态常量）进行实现单例</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();

    <span class="comment">/**</span>
<span class="comment">     * Returns the runtime object associated with the current Java application.</span>
<span class="comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span>
<span class="comment">     * methods and must be invoked with respect to the current runtime object.</span>
<span class="comment">     *</span>
<span class="comment">     * <span class="doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span>
<span class="comment">     *          Java application.</span>
<span class="comment">     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> currentRuntime;
    }

    <span class="comment">/** Don't let anyone else instantiate this class */</span>
    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>{}
}</code></pre>
<h2 id="3、单例模式注意事项和细节说明"><a href="#3、单例模式注意事项和细节说明" class="headerlink" title="3、单例模式注意事项和细节说明"></a>3、单例模式注意事项和细节说明</h2><ol>
<li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使<br>用单例模式可以提高系统性能</li>
<li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而<strong>不是使用 new</strong></li>
<li>单例模式 使用的场景：需要 频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：<strong>重量级</strong><br><strong>对象</strong>)，但又经常用到的对象、 工具类对象、频繁访问数据库或文件的对象(比如 <strong>数据源</strong>、<strong>session  工厂</strong>等)</li>
</ol>
<h1 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h1><h2 id="1、简单工厂模式"><a href="#1、简单工厂模式" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h2><h3 id="1-、看一个具体的需求"><a href="#1-、看一个具体的需求" class="headerlink" title="(1)、看一个具体的需求"></a>(1)、看一个具体的需求</h3><p>​    看一个披萨的项目：要便于披萨种类的扩展，要便于维护</p>
<ol>
<li><p>披萨的种类很多(比如 GreekPizz、CheesePizz 等)</p>
</li>
<li><p>披萨的制作有 prepare，bake, cut, box</p>
</li>
<li><p>完成披萨店订购功能。</p>
</li>
</ol>
<h3 id="2-、使用传统的方式来完成"><a href="#2-、使用传统的方式来完成" class="headerlink" title="(2)、使用传统的方式来完成"></a>(2)、使用传统的方式来完成</h3><h4 id="1-、UML类图分析"><a href="#1-、UML类图分析" class="headerlink" title="1)、UML类图分析"></a>1)、UML类图分析</h4><p>这样设计耦合性很高，一个orderPizza类也依赖了具体的实现GreekPizza和CheessPizza，如果增加新的披萨种类，会有更多的依赖，<strong>违反了OCP原则</strong>。</p>
<img src="设计模式\QQ截图20200116163455.png" style="zoom:80%;" />

<h4 id="2-、关键代码"><a href="#2-、关键代码" class="headerlink" title="2)、关键代码"></a>2)、关键代码</h4><pre><code class="java"><span class="comment">// 构造器</span>
<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span> </span>{
   Pizza pizza = <span class="keyword">null</span>;
   String orderType; <span class="comment">// 订购披萨的类型</span>
   <span class="keyword">do</span> {
      orderType = getType();
       <span class="comment">//这里每次增加新的种类披萨都要修改代码</span>

      <span class="keyword">if</span> (orderType.equals(<span class="string">"greek"</span>)) {
         pizza = <span class="keyword">new</span> GreekPizza();
         pizza.setName(<span class="string">" 希腊披萨 "</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"cheese"</span>)) {
         pizza = <span class="keyword">new</span> CheesePizza();
         pizza.setName(<span class="string">" 奶酪披萨 "</span>);
      }  <span class="keyword">else</span> {
         <span class="keyword">break</span>;
      }
      <span class="comment">//输出pizza 制作过程</span>
      pizza.prepare();
      pizza.bake();
      pizza.cut();
      pizza.box();
   } <span class="keyword">while</span> (<span class="keyword">true</span>);
}

<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span>
<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>{
   <span class="keyword">try</span> {
      BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));
      System.out.println(<span class="string">"input pizza 种类:"</span>);
      String str = strin.readLine();
      <span class="keyword">return</span> str;
   } <span class="keyword">catch</span> (IOException e) {
      e.printStackTrace();
      <span class="keyword">return</span> <span class="string">""</span>;
   }
}</code></pre>
<h4 id="3-、传统的方式的优缺点"><a href="#3-、传统的方式的优缺点" class="headerlink" title="3)、传统的方式的优缺点"></a>3)、传统的方式的优缺点</h4><ol>
<li><p>优点是比较好理解，简单易操作。</p>
</li>
<li><p>缺点是违反了设计模式的 ocp  原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</p>
</li>
<li><p>比如我们这时 要新增加一个 Pizza  的种类(Pepper  披萨)，我们需要做如下修改.</p>
<pre><code class="java"><span class="keyword">if</span> (orderType.equals(<span class="string">"greek"</span>)) {
   pizza = <span class="keyword">new</span> GreekPizza();
   pizza.setName(<span class="string">" 希腊披萨 "</span>);
} <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"cheese"</span>)) {
   pizza = <span class="keyword">new</span> CheesePizza();
   pizza.setName(<span class="string">" 奶酪披萨 "</span>);
} <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) {
   pizza = <span class="keyword">new</span> PepperPizza();
   pizza.setName(<span class="string">"胡椒披萨"</span>);
} <span class="keyword">else</span> {
   <span class="keyword">break</span>;
}</code></pre>
<p>如果我们增加一个 Pizza 类，只要是订购 Pizza 的代码都需要修改.</p>
</li>
<li><p>改进的思路分析<br>分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza的代码，往往有多处。<br>思路： <strong>把创建 Pizza  对象封装到一个类中</strong> ， <strong>这样我们有新的 Pizza  种类时</strong>， 只需要修改该类就可，其它有创建到 Pizza<br>对象的代码就不需要修改了.-&gt;  简单工厂模式</p>
</li>
</ol>
<h3 id="3-、简单工厂基本介绍"><a href="#3-、简单工厂基本介绍" class="headerlink" title="(3)、简单工厂基本介绍"></a>(3)、简单工厂基本介绍</h3><p>1) 简单工厂模式是属于 <strong>创建型模式</strong>，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品<br>类的实例。简单工厂模式是 工厂模式家族中<strong>最简单实用的模式</strong><br>2) 简单工厂模式：定义了一个创建对象的类，由<strong>这个类来 封装实例化对象的行为(代码)</strong><br>3) 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.</p>
<h3 id="4-、简单工厂实现"><a href="#4-、简单工厂实现" class="headerlink" title="(4)、简单工厂实现"></a>(4)、简单工厂实现</h3><h4 id="1-、UML类图分析-1"><a href="#1-、UML类图分析-1" class="headerlink" title="1)、UML类图分析"></a>1)、UML类图分析</h4><img src="设计模式/QQ截图20200116170558.png" style="zoom:80%;" />

<p>####2)、关键代码（普通方法）</p>
<pre><code class="java"><span class="comment">//定义一个简单工厂对象</span>
SimpleFactory simpleFactory;
Pizza pizza = <span class="keyword">null</span>;

<span class="comment">//构造器</span>
<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(SimpleFactory simpleFactory)</span> </span>{
   setFactory(simpleFactory);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(SimpleFactory simpleFactory)</span> </span>{
   String orderType = <span class="string">""</span>; <span class="comment">//用户输入的</span>
   <span class="keyword">this</span>.simpleFactory = simpleFactory; <span class="comment">//设置简单工厂对象</span>
   <span class="keyword">do</span> {
      orderType = getType();
      pizza = <span class="keyword">this</span>.simpleFactory.createPizza(orderType);
      <span class="comment">//输出pizza</span>
      <span class="keyword">if</span>(pizza != <span class="keyword">null</span>) { <span class="comment">//订购成功</span>
         pizza.prepare();
         pizza.bake();
         pizza.cut();
         pizza.box();
      } <span class="keyword">else</span> {
         System.out.println(<span class="string">" 订购披萨失败 "</span>);
         <span class="keyword">break</span>;
      }
   }<span class="keyword">while</span>(<span class="keyword">true</span>);
}</code></pre>
<p>这样的代码还可以升级为下面一种静态方法，不用new SimpleFactory实例，直接就可以调用。</p>
<p>工厂模式，<strong>工厂一般都有很多地方调用。一般要配合单例模式来进行使用。</strong></p>
<h4 id="3-、关键代码（改成静态方法）"><a href="#3-、关键代码（改成静态方法）" class="headerlink" title="3)、关键代码（改成静态方法）"></a>3)、关键代码（改成静态方法）</h4><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="title">OrderPizza2</span><span class="params">()</span> </span>{
   <span class="keyword">do</span> {
      orderType = getType();
      pizza = SimpleFactory.createPizza2(orderType);
      <span class="comment">// 输出pizza</span>
      <span class="keyword">if</span> (pizza != <span class="keyword">null</span>) { <span class="comment">// 订购成功</span>
         pizza.prepare();
         pizza.bake();
         pizza.cut();
         pizza.box();
      } <span class="keyword">else</span> {
         System.out.println(<span class="string">" 订购披萨失败 "</span>);
         <span class="keyword">break</span>;
      }
   } <span class="keyword">while</span> (<span class="keyword">true</span>);
}</code></pre>
<p>​       每一个OrderPizza去使用SimpleFactory时，只需要用createPizza2(创建对象)方法即可，不需要关注里面的实现细节。</p>
<pre><code class="java"><span class="comment">//SimpleFactory里面的createPizza2方法</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title">createPizza2</span><span class="params">(String orderType)</span> </span>{
    Pizza pizza = <span class="keyword">null</span>;
    System.out.println(<span class="string">"使用简单工厂模式2"</span>);
    <span class="keyword">if</span> (orderType.equals(<span class="string">"greek"</span>)) {
        pizza = <span class="keyword">new</span> GreekPizza();
        pizza.setName(<span class="string">" 希腊披萨 "</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"cheese"</span>)) {
        pizza = <span class="keyword">new</span> CheesePizza();
        pizza.setName(<span class="string">" 奶酪披萨 "</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) {
        pizza = <span class="keyword">new</span> PepperPizza();
        pizza.setName(<span class="string">"胡椒披萨"</span>);
    }
    <span class="keyword">return</span> pizza;
}</code></pre>
<h3 id="5-、简单工厂优缺点"><a href="#5-、简单工厂优缺点" class="headerlink" title="(5)、简单工厂优缺点"></a>(5)、简单工厂优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；</li>
<li>把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；</li>
<li>违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</li>
<li>简单工厂模式由于使用了静态工厂方法，<strong>静态方法不能被继承和重写</strong>，会造成工厂角色无法形成基于继承的等级结构。</li>
</ul>
<h3 id="6-、-应用场景"><a href="#6-、-应用场景" class="headerlink" title="(6)、 应用场景"></a>(6)、 应用场景</h3><p>在了解了优缺点后，我们知道了简单工厂模式的应用场景：</p>
<ul>
<li>客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；</li>
<li>当工厂类负责创建的对象（具体产品）比较少时。</li>
</ul>
<h2 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h2><h3 id="1-、一个新的需求"><a href="#1-、一个新的需求" class="headerlink" title="(1)、一个新的需求"></a>(1)、一个新的需求</h3><p>披萨项目新的需求：客户在点披萨时，可以点 不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或<br>者是伦敦的奶酪 pizza、伦敦的胡椒 pizza。</p>
<ul>
<li>思路 1：使用 简单工厂模式，创建 不同的简单工厂类，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等。从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好。不停的创建SimpleFactory类，会有类爆炸的问题。</li>
<li>思路 2：使用工厂方法模式</li>
</ul>
<h3 id="2-、工厂方法模式介绍"><a href="#2-、工厂方法模式介绍" class="headerlink" title="(2)、工厂方法模式介绍"></a>(2)、工厂方法模式介绍</h3><ol>
<li>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。</li>
<li>工厂方法模式： 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类</li>
</ol>
<h3 id="3-、工厂方法模式应用案例"><a href="#3-、工厂方法模式应用案例" class="headerlink" title="(3)、工厂方法模式应用案例"></a>(3)、工厂方法模式应用案例</h3><h4 id="1-披萨项目新的需求："><a href="#1-披萨项目新的需求：" class="headerlink" title="1) 披萨项目新的需求："></a>1) 披萨项目新的需求：</h4><p>客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza</p>
<h4 id="2-UML类图分析"><a href="#2-UML类图分析" class="headerlink" title="2) UML类图分析"></a>2) UML类图分析</h4><img src="设计模式/QQ截图20200116192605.png" style="zoom:80%;" />

<p>说白了就是一个大工厂分解成若干个小工厂，由子类决定要实例化的类</p>
<h4 id="3-关键代码"><a href="#3-关键代码" class="headerlink" title="3)关键代码"></a>3)关键代码</h4><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
      String loc = <span class="string">"bj"</span>;
      <span class="keyword">if</span> (loc.equals(<span class="string">"bj"</span>)) {
         <span class="comment">//创建北京口味的各种Pizza</span>
         <span class="keyword">new</span> BJOrderPizza();   <span class="comment">//原本一个大工厂，现在搞出不同的小工厂来了</span>
      } <span class="keyword">else</span> {
         <span class="comment">//创建伦敦口味的各种Pizza</span>
         <span class="keyword">new</span> LDOrderPizza();
      }
   }
}</code></pre>
<p>BJOrderPizza类（其中的一个小工厂）</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title">OrderPizza</span> </span>{
   <span class="meta">@Override</span>
   <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>{
      Pizza pizza = <span class="keyword">null</span>;
      <span class="keyword">if</span>(orderType.equals(<span class="string">"cheese"</span>)) {
         pizza = <span class="keyword">new</span> BJCheesePizza();
      } <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) {
         pizza = <span class="keyword">new</span> BJPepperPizza();
      }
      <span class="keyword">return</span> pizza;
   }
}</code></pre>
<p>LDOrderPizza类（其中的一个小工厂）</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LDOrderPizza</span> <span class="keyword">extends</span> <span class="title">OrderPizza</span> </span>{
   <span class="meta">@Override</span>
   <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>{
      Pizza pizza = <span class="keyword">null</span>;
      <span class="keyword">if</span>(orderType.equals(<span class="string">"cheese"</span>)) {
         pizza = <span class="keyword">new</span> LDCheesePizza();
      } <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) {
         pizza = <span class="keyword">new</span> LDPepperPizza();
      }
      <span class="keyword">return</span> pizza;
   }
}</code></pre>
<h3 id="4-、工厂方法优缺点"><a href="#4-、工厂方法优缺点" class="headerlink" title="(4)、工厂方法优缺点"></a>(4)、工厂方法优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li><p>更符合开-闭原则<br>新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</p>
<blockquote>
<p>简单工厂模式需要修改工厂类的判断逻辑</p>
</blockquote>
</li>
<li><p>符合单一职责原则<br>每个具体工厂类只负责创建对应的产品</p>
<blockquote>
<p>简单工厂中的工厂类存在复杂的switch逻辑判断</p>
</blockquote>
</li>
<li><p>不使用静态工厂方法，可以形成基于继承的等级结构。</p>
<blockquote>
<p>简单工厂模式的工厂类使用静态工厂方法</p>
</blockquote>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
<li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li>
<li>一个具体工厂只能创建一种具体产品</li>
</ul>
<p><strong>总结：</strong></p>
<p>工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</p>
<h3 id="5-、应用场景"><a href="#5-、应用场景" class="headerlink" title="(5)、应用场景"></a>(5)、应用场景</h3><p>在了解了优缺点后，总结了工厂方法模式的应用场景：</p>
<ul>
<li>当一个类不知道它所需要的对象的类时<br>在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；</li>
<li>当一个类希望通过其子类来指定创建对象时<br>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
<h2 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h2><h3 id="1-、基本介绍"><a href="#1-、基本介绍" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>抽象工厂模式：定义了一个 interface  用于创建相关或有依赖关系的对象簇，而无需指明具体的类</li>
<li>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</li>
<li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</li>
<li>将工厂抽象成 两层，AbsFactory( 抽象工厂) 和  具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</li>
</ol>
<h3 id="2-、抽象工厂模式应用实例"><a href="#2-、抽象工厂模式应用实例" class="headerlink" title="(2)、抽象工厂模式应用实例"></a>(2)、抽象工厂模式应用实例</h3><h4 id="1）UML类图分析"><a href="#1）UML类图分析" class="headerlink" title="1）UML类图分析"></a>1）UML类图分析</h4><img src="设计模式/QQ截图20200116200607.png" style="zoom: 67%;" />

<p> OrderPizza类中聚合AbsFactory接口（或抽象类），就代表聚合进去了BeiJing Orderpizza或London Orderpizza，这里可以进行选择实际子类的工厂究竟是哪一个。</p>
<h4 id="2）关键代码"><a href="#2）关键代码" class="headerlink" title="2）关键代码"></a>2）关键代码</h4><pre><code class="java"><span class="comment">//一个抽象工厂模式的抽象层(接口)</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbsFactory</span> </span>{
   <span class="comment">//让下面的工厂子类来 具体实现</span>
   <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;
}</code></pre>
<p>BJFactory类实现AbsFactory接口</p>
<pre><code>//这是工厂子类
public class BJFactory implements AbsFactory {
   @Override
   public Pizza createPizza(String orderType) {
      System.out.println(&quot;~使用的是抽象工厂模式~&quot;);
      Pizza pizza = null;
      if(orderType.equals(&quot;cheese&quot;)) {
         pizza = new BJCheesePizza();
      } else if (orderType.equals(&quot;pepper&quot;)){
         pizza = new BJPepperPizza();
      }
      return pizza;
   }
}</code></pre><h3 id="3-、抽象工厂优缺点"><a href="#3-、抽象工厂优缺点" class="headerlink" title="(3)、抽象工厂优缺点"></a>(3)、抽象工厂优缺点</h3><p>  <strong>优点：</strong></p>
<ul>
<li>降低耦合<br> 抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；</li>
<li>更符合开-闭原则<br> 新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可</li>
</ul>
<blockquote>
<p>简单工厂模式需要修改工厂类的判断逻辑</p>
</blockquote>
<ul>
<li>符合单一职责原则<br> 每个具体工厂类只负责创建对应的产品</li>
</ul>
<blockquote>
<p>简单工厂中的工厂类存在复杂的switch逻辑判断</p>
</blockquote>
<ul>
<li>不使用静态工厂方法，可以形成基于继承的等级结构。</li>
</ul>
<blockquote>
<p>简单工厂模式的工厂类使用静态工厂方法</p>
</blockquote>
<hr>
<p><strong>缺点：</strong></p>
<p>抽象工厂模式很难支持新种类产品的变化。<br>这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。</p>
<p>如果实现要增加一个新的产品，在接口里面增加一个方法。这种直接修改抽象接口的做法，会导致其所有实现子类都需要进行修改，重写这个未实现的方法，<strong>违反了开闭原则</strong>。当然，如果这种修改是长期稳定的，那么也可以接受。</p>
<blockquote>
<p>对于新的产品族符合开-闭原则；对于新的产品种类不符合开-闭原则，这一特性称为开-闭原则的倾斜性。</p>
<p><strong>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦</strong>，抽象工厂模式的这种性质称为<strong>“开闭原则”的倾斜性</strong>。</p>
</blockquote>
<h3 id="4-、补充"><a href="#4-、补充" class="headerlink" title="(4)、补充"></a>(4)、补充</h3><p> 弹幕大神：</p>
<ul>
<li>这里要是换成上衣和裤子区别比较好，上衣工厂和裤子工厂都是抽象衣服工厂子类。</li>
<li>工厂方法就是父类已经实现了一个整合方法，子类直接继承；抽象工厂就是接口没有实现任何逻辑</li>
<li>继承是侵入性的 而且java是单继承，抽成接口，那么工厂类可以实现接口，不需要改变继承关系，目的就是拓展某各类功能</li>
</ul>
<p>这个披萨的案例其实讲的不是很好，配合网上资料，大概能明白，网上有几篇文章将的不错</p>
<p><a href="https://blog.csdn.net/u014727260/article/details/82560912" target="_blank" rel="noopener">CSDN：抽象工厂</a></p>
<p><a href="https://www.jianshu.com/p/7deb64f902db" target="_blank" rel="noopener">简书：抽象工厂模式（Abstract Factory）- 最易懂的设计模式解析</a></p>
<h2 id="4、工厂模式Java源码分析"><a href="#4、工厂模式Java源码分析" class="headerlink" title="4、工厂模式Java源码分析"></a>4、工厂模式Java源码分析</h2><h3 id="1-、JDK-中的-Calendar-类中，简单工厂模式"><a href="#1-、JDK-中的-Calendar-类中，简单工厂模式" class="headerlink" title="(1)、JDK 中的 Calendar 类中，简单工厂模式"></a>(1)、JDK 中的 Calendar 类中，简单工厂模式</h3><pre><code class="java"><span class="keyword">import</span> java.util.Calendar;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
      <span class="comment">// getInstance 是 Calendar 静态方法</span>
      Calendar cal = Calendar.getInstance();
      <span class="comment">// 注意月份下标从0开始，所以取月份要+1</span>
      System.out.println(<span class="string">"年:"</span> + cal.get(Calendar.YEAR));
      System.out.println(<span class="string">"月:"</span> + (cal.get(Calendar.MONTH) + <span class="number">1</span>));
   }
}</code></pre>
<p>注意 Calendar cal = Calendar.getInstance(); 不是new出来的,而是通过getInstance（）一个静态方法得到对象，debug进去</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span>
<span class="function"></span>{
    <span class="keyword">return</span> createCalendar(TimeZone.getDefault(),Locale.getDefault(Locale.Category.FORMAT));
}</code></pre>
<p>如果没有设定时区和位置，这里直接回返回默认的对象，</p>
<p>继续debug进去</p>
<pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone,</span></span>
<span class="function"><span class="params">                                       Locale aLocale)</span></span>
<span class="function"></span>{
    CalendarProvider provider =
        LocaleProviderAdapter.getAdapter(CalendarProvider<span class="class">.<span class="keyword">class</span>, <span class="title">aLocale</span>)</span>
<span class="class">                             .<span class="title">getCalendarProvider</span>()</span>;
    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) {
        <span class="keyword">try</span> {
            <span class="keyword">return</span> provider.getInstance(zone, aLocale);
        } <span class="keyword">catch</span> (IllegalArgumentException iae) {
            <span class="comment">// fall back to the default instantiation</span>
        }
    }

    Calendar cal = <span class="keyword">null</span>;

    <span class="keyword">if</span> (aLocale.hasExtensions()) {
        String caltype = aLocale.getUnicodeLocaleType(<span class="string">"ca"</span>);
        <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) {
            <span class="keyword">switch</span> (caltype) {
            <span class="keyword">case</span> <span class="string">"buddhist"</span>:
            cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"japanese"</span>:
                cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"gregory"</span>:
                cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);
                <span class="keyword">break</span>;
            }
        }
    }
    <span class="keyword">if</span> (cal == <span class="keyword">null</span>) {
        <span class="keyword">if</span> (aLocale.getLanguage() == <span class="string">"th"</span> &amp;&amp; aLocale.getCountry() == <span class="string">"TH"</span>) {
            cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);
        } <span class="keyword">else</span> <span class="keyword">if</span> (aLocale.getVariant() == <span class="string">"JP"</span> &amp;&amp; aLocale.getLanguage() == <span class="string">"ja"</span>
                   &amp;&amp; aLocale.getCountry() == <span class="string">"JP"</span>) {
            cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);
        } <span class="keyword">else</span> {
            cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);
        }
    }
    <span class="keyword">return</span> cal;
}</code></pre>
<p>其中初始化Calendar cal = null;</p>
<p>然后通过switch使用不同工厂进行创建对象，使用了简单方法工厂模式，</p>
<p>最后return回去</p>
<pre><code class="java">Calendar cal = <span class="keyword">null</span>;
<span class="keyword">if</span> (aLocale.hasExtensions()) {
    String caltype = aLocale.getUnicodeLocaleType(<span class="string">"ca"</span>);
    <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) {
        <span class="keyword">switch</span> (caltype) {
        <span class="keyword">case</span> <span class="string">"buddhist"</span>:
        cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">"japanese"</span>:
            cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">"gregory"</span>:
            cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);
            <span class="keyword">break</span>;
        }
    }
}</code></pre>
<h3 id="2-、JDK-中的-sql-Connection类中，抽象工厂模式"><a href="#2-、JDK-中的-sql-Connection类中，抽象工厂模式" class="headerlink" title="(2)、JDK 中的 sql.Connection类中，抽象工厂模式"></a>(2)、JDK 中的 sql.Connection类中，抽象工厂模式</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connection</span>  <span class="keyword">extends</span> <span class="title">Wrapper</span>, <span class="title">AutoCloseable</span> </span>{
    <span class="comment">//...        </span>
        <span class="comment">//返回普通的sql执行器</span>
        <span class="function">Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;
        <span class="comment">//返回具有参数化预编译功能的sql执行器</span>
        <span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;
        <span class="comment">//返回可以执行存储过程的sql执行器</span>
        <span class="function">CallableStatement <span class="title">prepareCall</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;   
    <span class="comment">//...         </span>
}</code></pre>
<p>从上面的注释就可以看出，这就是典型的抽象工厂接口，描述了不同的产品等级Statement、PreparedStatement、CallableStatement，它们都位于抽象接口Statement产品等级结构中。我们可以继续寻找该抽象工厂接口的实现类</p>
<p>这里就以Mysql为例，可以找到Mysql对这个工厂接口的实现类ConnectionImpl，ConnectionImpl并不是直接实现了java.sql.Connection,而是通过实现自己扩展的MySQLConnection接口，该接口也是间接继承了java.sql.Connection</p>
<img src="设计模式/20180909172407.png" style="zoom:80%;" />



<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionImpl</span> <span class="keyword">extends</span> <span class="title">ConnectionPropertiesImpl</span> <span class="keyword">implements</span> <span class="title">MySQLConnection</span> </span>{
    <span class="comment">//...</span>
 <span class="keyword">public</span> java.sql.<span class="function">Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{
        <span class="keyword">return</span> createStatement(DEFAULT_RESULT_SET_TYPE, DEFAULT_RESULT_SET_CONCURRENCY);
    }

 <span class="keyword">public</span> java.sql.<span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>{
        <span class="keyword">return</span> prepareStatement(sql, DEFAULT_RESULT_SET_TYPE, DEFAULT_RESULT_SET_CONCURRENCY);
    }

 <span class="keyword">public</span> java.sql.<span class="function">CallableStatement <span class="title">prepareCall</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>{

        <span class="keyword">return</span> prepareCall(sql, DEFAULT_RESULT_SET_TYPE, DEFAULT_RESULT_SET_CONCURRENCY);
    }
    <span class="comment">//...</span>
}</code></pre>
<p>以<code>createStatement</code>为例，跟踪其调用代码可以看到<strong>StatementImpl</strong>这个类就是实现了java.sql.Statement的具体产品类</p>
<pre><code class="java"><span class="keyword">public</span> java.sql.<span class="function">Statement <span class="title">createStatement</span><span class="params">(<span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>{
    checkClosed();

    StatementImpl stmt = <span class="keyword">new</span> StatementImpl(getMultiHostSafeProxy(), <span class="keyword">this</span>.database);
    stmt.setResultSetType(resultSetType);
    stmt.setResultSetConcurrency(resultSetConcurrency);

    <span class="keyword">return</span> stmt;
}</code></pre>
<h3 id="3-、Mybatis中的SqlSessionFactory类，抽象工厂模式"><a href="#3-、Mybatis中的SqlSessionFactory类，抽象工厂模式" class="headerlink" title="(3) 、Mybatis中的SqlSessionFactory类，抽象工厂模式"></a>(3) 、Mybatis中的SqlSessionFactory类，抽象工厂模式</h3><ul>
<li>mybatis中的SqlSessionFactory</li>
</ul>
<pre><code class="java"><span class="comment">/**</span>
<span class="comment"> * Creates an {<span class="doctag">@link</span> SqlSession} out of a connection or a DataSource</span>
<span class="comment"> * </span>
<span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSessionFactory</span> </span>{
  <span class="function">SqlSession <span class="title">openSession</span><span class="params">()</span></span>;

  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span></span>;
  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(Connection connection)</span></span>;
  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(TransactionIsolationLevel level)</span></span>;

  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType)</span></span>;
  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType, <span class="keyword">boolean</span> autoCommit)</span></span>;
  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level)</span></span>;
  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span></span>;

  <span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span>;
}</code></pre>
<p>SqlSessionFactory也是抽象工厂接口，Configuration和SqlSession都是在不同的产品等级上。通过IDEA工具可以通过UML图清晰得看到SqlSessionFactory的工厂实现类</p>
<img src="设计模式/20180909180700.png" style="zoom: 67%;" />



<h2 id="5、工厂模式小结"><a href="#5、工厂模式小结" class="headerlink" title="5、工厂模式小结"></a>5、工厂模式小结</h2><ol>
<li><p>工厂模式的意义：<br>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项<br>目的扩展和维护性。</p>
</li>
<li><p>三种工厂模式 ：</p>
<p>(简单工厂模式、工厂方法模式、抽象工厂模式)</p>
</li>
<li><p>设计模式的依赖抽象原则 ：</p>
</li>
</ol>
<ul>
<li>创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。</li>
<li>不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)</li>
<li>不要覆盖基类中已经实现的方法。</li>
</ul>
<h1 id="三、原型模式"><a href="#三、原型模式" class="headerlink" title="三、原型模式"></a>三、原型模式</h1><h2 id="问题提出：克隆羊问题"><a href="#问题提出：克隆羊问题" class="headerlink" title="问题提出：克隆羊问题"></a>问题提出：克隆羊问题</h2><p>现在有一只羊 tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊 属性完全相同的 10<br>只羊。</p>
<h2 id="1、传统模式解决问题"><a href="#1、传统模式解决问题" class="headerlink" title="1、传统模式解决问题"></a>1、传统模式解决问题</h2><h3 id="1-UML类图分析"><a href="#1-UML类图分析" class="headerlink" title="(1)UML类图分析"></a>(1)UML类图分析</h3><img src="设计模式/QQ截图20200117100134.png" style="zoom:80%;" />

<h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="(2)代码实现"></a>(2)代码实现</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   <span class="comment">//传统的方法</span>
   Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">"tom"</span>, <span class="number">1</span>, <span class="string">"白色"</span>);

   Sheep sheep2 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
   Sheep sheep3 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
   Sheep sheep4 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
   Sheep sheep5 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
   <span class="comment">//....</span>
   System.out.println(sheep);
   System.out.println(sheep2);
   System.out.println(sheep3);
   System.out.println(sheep4);
   System.out.println(sheep5);
   <span class="comment">//...</span>
}</code></pre>
<h3 id="3-传统的方式的优缺点"><a href="#3-传统的方式的优缺点" class="headerlink" title="(3)传统的方式的优缺点"></a>(3)传统的方式的优缺点</h3><ol>
<li>优点是比较好理解，简单易操作。</li>
<li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li>
<li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活</li>
<li>改进的思路分析<br>思路：Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 =&gt;<strong><font color=red>原型模式</font></strong></li>
</ol>
<h2 id="2、原型模式"><a href="#2、原型模式" class="headerlink" title="2、原型模式"></a>2、原型模式</h2><h3 id="1-、基本介绍-1"><a href="#1-、基本介绍-1" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>原型模式(Prototype 模式)是指：用 原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li>
<li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li>
<li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即  <strong><font color=red>对象.clone()</font></strong></li>
<li>形象的理解：孙大圣拔出猴毛， 变出其它孙大圣</li>
</ol>
<img src="设计模式/QQ截图20200117103029.png" style="zoom: 80%;" />



<h3 id="2-、UML类图分析"><a href="#2-、UML类图分析" class="headerlink" title="(2)、UML类图分析"></a>(2)、UML类图分析</h3><img src="设计模式/QQ截图20200117103209.png" style="zoom:80%;" />

<p><strong>原理结构图说明</strong></p>
<ol>
<li>Prototype : 原型类，声明一个克隆自己的接口</li>
<li>ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作</li>
<li>Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样)</li>
</ol>
<h3 id="3-、原型模式解决克隆羊问题"><a href="#3-、原型模式解决克隆羊问题" class="headerlink" title="(3)、原型模式解决克隆羊问题"></a>(3)、原型模式解决克隆羊问题</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   System.out.println(<span class="string">"原型模式完成对象的创建"</span>);
   Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">"tom"</span>, <span class="number">1</span>, <span class="string">"白色"</span>);

   Sheep sheep2 = (Sheep)sheep.clone(); <span class="comment">//克隆</span>
   Sheep sheep3 = (Sheep)sheep.clone(); <span class="comment">//克隆</span>
   Sheep sheep4 = (Sheep)sheep.clone(); <span class="comment">//克隆</span>
   Sheep sheep5 = (Sheep)sheep.clone(); <span class="comment">//克隆</span>

   System.out.println(sheep +<span class="string">"sheep.hashCode "</span>+sheep.hashCode());
   System.out.println(sheep2 +<span class="string">"sheep2.hashCode "</span>+sheep2.hashCode());
   System.out.println(sheep3 +<span class="string">"sheep3.hashCode "</span>+sheep3.hashCode());
   System.out.println(sheep4 +<span class="string">"sheep4.hashCode "</span>+sheep4.hashCode());
   System.out.println(sheep5 +<span class="string">"sheep5.hashCode "</span>+sheep5.hashCode());
}

<span class="comment">//结果</span>
原型模式完成对象的创建
Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep.hashCode <span class="number">1956725890</span>
Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep2.hashCode <span class="number">356573597</span>
Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep3.hashCode <span class="number">1735600054</span>
Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep4.hashCode <span class="number">21685669</span>
Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep5.hashCode <span class="number">2133927002</span></code></pre>
<h2 id="3、原型模式在-Spring-框架中源码分析"><a href="#3、原型模式在-Spring-框架中源码分析" class="headerlink" title="3、原型模式在 Spring 框架中源码分析"></a>3、原型模式在 Spring 框架中源码分析</h2><p>Spring 中原型 bean 的创建，就是原型模式的应用。</p>
<p>bean1.xml文件  scope=”prototype” 决定是单例还是多例</p>
<pre><code class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ioc"</span> <span class="attr">class</span>=<span class="string">"cn.lzw.ioc.User"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> 
<span class="comment">&lt;!-- &lt;bean id="ioc" class="cn.lzw.ioc.User" &gt;&lt;/bean&gt;  --&gt;</span></code></pre>
<pre><code class="java">ApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean1.xml"</span>);

User user1=(User)context.getBean(<span class="string">"ioc"</span>);
User user2=(User)context.getBean(<span class="string">"ioc"</span>);
System.out.println(user1);
System.out.println(user2);</code></pre>
<p>Debug追踪到<code>AbstractBeanFactory</code>的<code>protected &lt;T&gt; T doGetBean</code>时下列代码选择是单例还是原型（多例）</p>
<pre><code class="java"><span class="comment">// Create bean instance.</span>
<span class="keyword">if</span> (mbd.isSingleton()) {
   sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() {
      <span class="meta">@Override</span>
      <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{
         <span class="keyword">try</span> {
            <span class="keyword">return</span> createBean(beanName, mbd, args);
         }
         <span class="keyword">catch</span> (BeansException ex) {
            <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span>
            <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span>
            <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span>
            destroySingleton(beanName);
            <span class="keyword">throw</span> ex;
         }
      }
   });
   bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}

<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) {
   <span class="comment">// It's a prototype -&gt; create a new instance.</span>
   Object prototypeInstance = <span class="keyword">null</span>;
   <span class="keyword">try</span> {
      beforePrototypeCreation(beanName);
      prototypeInstance = createBean(beanName, mbd, args);
   }
   <span class="keyword">finally</span> {
      afterPrototypeCreation(beanName);
   }
   bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
}</code></pre>
<img src="设计模式/QQ截图20200117113334.png" style="zoom:80%;" />



<h2 id="4、深入讨论-浅拷贝和深拷贝"><a href="#4、深入讨论-浅拷贝和深拷贝" class="headerlink" title="4、深入讨论-浅拷贝和深拷贝"></a>4、深入讨论-浅拷贝和深拷贝</h2><h3 id="1-、浅拷贝的介绍"><a href="#1-、浅拷贝的介绍" class="headerlink" title="(1)、浅拷贝的介绍"></a>(1)、浅拷贝的介绍</h3><ol>
<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</li>
<li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行<br>引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成<br>员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li>
<li>前面我们克隆羊就是浅拷贝</li>
<li>浅拷贝是使用默认的 clone()方法来实现<br>sheep = (Sheep) super.clone();</li>
</ol>
<p>代码演示</p>
<p>Sheep羊实体类</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>{
   <span class="keyword">private</span> String name;
   <span class="keyword">private</span> <span class="keyword">int</span> age;
   <span class="keyword">private</span> String color;
   <span class="keyword">private</span> String address = <span class="string">"蒙古羊"</span>;
   <span class="keyword">public</span> Sheep friend; <span class="comment">//是对象, 克隆是会如何处理</span>

    <span class="comment">//克隆该实例，使用默认的clone方法来完成</span>
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>  </span>{

        Sheep sheep = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            sheep = (Sheep)<span class="keyword">super</span>.clone();
        } <span class="keyword">catch</span> (Exception e) {
            System.out.println(e.getMessage());
        }
        <span class="keyword">return</span> sheep;
    }
   <span class="comment">//省略了getset，tostring方法</span>
   }</code></pre>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   System.out.println(<span class="string">"原型模式完成对象的创建"</span>);
   Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">"tom"</span>, <span class="number">1</span>, <span class="string">"白色"</span>);

   Sheep sheep2 = (Sheep)sheep.clone(); <span class="comment">//克隆</span>
   Sheep sheep3 = (Sheep)sheep.clone(); <span class="comment">//克隆</span>
   Sheep sheep4 = (Sheep)sheep.clone(); <span class="comment">//克隆</span>
   Sheep sheep5 = (Sheep)sheep.clone(); <span class="comment">//克隆</span>

   sheep.friend = <span class="keyword">new</span> Sheep(<span class="string">"jack"</span>, <span class="number">2</span>, <span class="string">"黑色"</span>);
   System.out.println(<span class="string">"sheep2 ="</span> + sheep2 + <span class="string">"sheep2.friend="</span> + sheep2.friend.hashCode());
   System.out.println(<span class="string">"sheep3 ="</span> + sheep3 + <span class="string">"sheep3.friend="</span> + sheep3.friend.hashCode());
   System.out.println(<span class="string">"sheep4 ="</span> + sheep4 + <span class="string">"sheep4.friend="</span> + sheep4.friend.hashCode());
   System.out.println(<span class="string">"sheep5 ="</span> + sheep5 + <span class="string">"sheep5.friend="</span> + sheep5.friend.hashCode());
}

<span class="comment">//结果</span>
sheep2 =Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep2.friend=<span class="number">1836019240</span>
sheep3 =Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep3.friend=<span class="number">1836019240</span>
sheep4 =Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep4.friend=<span class="number">1836019240</span>
sheep5 =Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep5.friend=<span class="number">1836019240</span></code></pre>
<p>可以看到，这里friend属性是一个羊对象，并没有真正的克隆，只是把引用的地址给复制过去了。浅拷贝</p>
<p><font color=red> <strong>默认的clone方法只会对基本的数据类型和字符串进行克隆（值传递），其他的复杂类型和对象只会进行引用传递</font></strong></p>
<h3 id="2-、深拷贝基本介绍"><a href="#2-、深拷贝基本介绍" class="headerlink" title="(2)、深拷贝基本介绍"></a>(2)、深拷贝基本介绍</h3><ol>
<li><p>复制对象的所有基本数据类型的成员变量值</p>
</li>
<li><p>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象<br>可达的所有对象。也就是说， 对象进行深拷贝要对整个对象( 包括对象的引用类型) 进行拷贝</p>
</li>
</ol>
<h3 id="3-、深拷贝实现"><a href="#3-、深拷贝实现" class="headerlink" title="(3)、深拷贝实现"></a>(3)、深拷贝实现</h3><h4 id="方式-1：重写-clone-方法来实现深拷贝"><a href="#方式-1：重写-clone-方法来实现深拷贝" class="headerlink" title="方式 1：重写 clone 方法来实现深拷贝"></a>方式 1：重写 clone 方法来实现深拷贝</h4><p>   说白了就是俄罗斯套娃，在每个用到的类中，<strong>再写一个<code>Clone</code>方法，一层套一层</strong></p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>{

   <span class="keyword">public</span> String name; <span class="comment">//String 属性</span>
   <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span>
   <span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>{
      <span class="keyword">super</span>();
   }
}</code></pre>
<p>   <code>DeepProtoType</code>用到<code>DeepCloneableTarget</code>类，<code>DeepCloneableTarget</code>单独写一个Clone方法</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>{
   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;
   <span class="keyword">private</span> String cloneName;
   <span class="keyword">private</span> String cloneClass;

   <span class="comment">//构造器</span>
   <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> </span>{
      <span class="keyword">this</span>.cloneName = cloneName;
      <span class="keyword">this</span>.cloneClass = cloneClass;
   }
   <span class="comment">//因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>{
      <span class="keyword">return</span> <span class="keyword">super</span>.clone();
   }
}</code></pre>
<p>如果有对象的继续引用，继续写下去即可</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
   DeepProtoType p = <span class="keyword">new</span> DeepProtoType();
   p.name = <span class="string">"宋江"</span>;
   p.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">"大牛"</span>, <span class="string">"小牛"</span>);

   <span class="comment">//方式1 完成深拷贝</span>
   DeepProtoType p2 = (DeepProtoType) p.clone();

   System.out.println(<span class="string">"p.name="</span> + p.name + <span class="string">"p.deepCloneableTarget="</span> + p.deepCloneableTarget.hashCode());
   System.out.println(<span class="string">"p2.name="</span> + p.name + <span class="string">"p2.deepCloneableTarget="</span> + p2.deepCloneableTarget.hashCode());
}

<span class="comment">//结果</span>
p.name=宋江p.deepCloneableTarget=<span class="number">1956725890</span>
p2.name=宋江p2.deepCloneableTarget=<span class="number">356573597</span></code></pre>
<h4 id="方式-2：通过-对象序列化实现深拷贝-推荐"><a href="#方式-2：通过-对象序列化实现深拷贝-推荐" class="headerlink" title="方式 2：通过 对象序列化实现深拷贝(推荐)"></a>方式 2：通过 对象序列化实现深拷贝(推荐)</h4><p>通过巧妙的<strong>IO</strong>流对象操作，将对象写出在写入，相当于文件的复制一份，得到了两个不同的对象</p>
<pre><code class="JAVA"><span class="comment">//深拷贝 - 方式2 通过对象的序列化实现 (推荐)</span>
<span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>{
   <span class="comment">//创建流对象</span>
   ByteArrayOutputStream bos = <span class="keyword">null</span>;
   ObjectOutputStream oos = <span class="keyword">null</span>;
   ByteArrayInputStream bis = <span class="keyword">null</span>;
   ObjectInputStream ois = <span class="keyword">null</span>;
   <span class="keyword">try</span> {
      <span class="comment">//序列化</span>
      bos = <span class="keyword">new</span> ByteArrayOutputStream();
      oos = <span class="keyword">new</span> ObjectOutputStream(bos);
      System.out.println(<span class="string">"aaa"</span>+<span class="keyword">this</span>);
      oos.writeObject(<span class="keyword">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span>

      <span class="comment">//反序列化</span>
      bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());
      ois = <span class="keyword">new</span> ObjectInputStream(bis);
      DeepProtoType copyObj = (DeepProtoType)ois.readObject();

       <span class="keyword">return</span> copyObj;

   } <span class="keyword">catch</span> (Exception e) {
      e.printStackTrace();
      <span class="keyword">return</span> <span class="keyword">null</span>;
   } <span class="keyword">finally</span> {
      <span class="comment">//关闭流</span>
      <span class="keyword">try</span> {
         bos.close();
         oos.close();
         bis.close();
         ois.close();
      } <span class="keyword">catch</span> (Exception e2) {
         e2.printStackTrace();
      }
   }
}

<span class="comment">//结果</span>
aaalzw.Prototype.deepclone1.DeepProtoType@<span class="number">74</span>a14482
p.name=宋江p.deepCloneableTarget=<span class="number">856419764</span>
p2.name=宋江p2.deepCloneableTarget=<span class="number">1595428806</span></code></pre>
<h2 id="5、原型模式的注意事项和细节"><a href="#5、原型模式的注意事项和细节" class="headerlink" title="5、原型模式的注意事项和细节"></a>5、原型模式的注意事项和细节</h2><ol>
<li>创建新的对象比较复杂时，可以利用原型模式简化 对象的创建过程，同时也能够提高效率</li>
<li>不用重新初始化对象，而是 动态地获得对象运行时的状态</li>
<li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li>
<li>在实现深克隆的时候可能需要比较复杂的代码</li>
<li><strong>缺点</strong>：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改<br>其源代码，<strong>违背了 ocp 原则</strong>，这点请同学们注意.</li>
</ol>
<h1 id="四、建造者模式"><a href="#四、建造者模式" class="headerlink" title="四、建造者模式"></a>四、建造者模式</h1><h2 id="问题提出：盖房项目需求"><a href="#问题提出：盖房项目需求" class="headerlink" title="问题提出：盖房项目需求"></a>问题提出：盖房项目需求</h2><ol>
<li>需要建房子：这一过程为打桩、砌墙、封顶</li>
<li>房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.</li>
<li>请编写程序，完成需求.</li>
</ol>
<h2 id="1、传统模式解决问题-1"><a href="#1、传统模式解决问题-1" class="headerlink" title="1、传统模式解决问题"></a>1、传统模式解决问题</h2><h3 id="1-、UML类图分析-2"><a href="#1-、UML类图分析-2" class="headerlink" title="(1)、UML类图分析"></a>(1)、UML类图分析</h3><img src="设计模式/QQ截图20200117151539.png" style="zoom:80%;" />

<h3 id="2-、代码实现"><a href="#2-、代码实现" class="headerlink" title="(2)、代码实现"></a>(2)、代码实现</h3><pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHouse</span> </span>{
   <span class="comment">//打地基</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;
   <span class="comment">//砌墙</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;
   <span class="comment">//封顶</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>{
      buildBasic();
      buildWalls();
      roofed();
   }
}</code></pre>
<p>抽象类比接口更好实现build(),可以去调用自己的方法，接口没法掉用</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">AbstractHouse</span> </span>{
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">" 普通房子打地基 "</span>);
   }
   <span class="comment">//...</span>
 }</code></pre>
<p><code>CommonHouse</code>继承<code>AbstractHouse</code>类，重写3个抽象方法</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();
   commonHouse.build();
}</code></pre>
<h3 id="3-、传统的方式的优缺点-1"><a href="#3-、传统的方式的优缺点-1" class="headerlink" title="(3)、传统的方式的优缺点"></a>(3)、传统的方式的优缺点</h3><ol>
<li><p>优点是比较好理解，简单易操作。</p>
</li>
<li><p>设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产<br>品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。</p>
</li>
<li><p>解决方案：将产品和产品建造过程解耦 =&gt; <font color=red><strong>建造者模式.</strong></font></p>
</li>
</ol>
<h2 id="2、建造者模式"><a href="#2、建造者模式" class="headerlink" title="2、建造者模式"></a>2、建造者模式</h2><h3 id="1-、基本介绍-2"><a href="#1-、基本介绍-2" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>建造者模式（Builder Pattern )又叫生成器模式，是一种对象构建模式。它可以<br>将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方<br>法可以构造出不同表现（属性）的对象。</li>
<li>建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象<br>的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</li>
</ol>
<p><img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ%E6%88%AA%E5%9B%BE20200117153251.png" alt=""></p>
<p>比如说宝马汽车，用户只需要知道汽车由方向盘、轮胎、发动机构成，而不用知道方向盘、轮胎、发动机这些组件是怎么来的。</p>
<h3 id="2-、建造者模式的四个角色"><a href="#2-、建造者模式的四个角色" class="headerlink" title="(2)、建造者模式的四个角色"></a>(2)、建造者模式的四个角色</h3><ol>
<li><strong>Product （产品角色）：</strong> 一个具体的产品对象。</li>
<li><strong>Builder （抽象建造者）：</strong> 创建一个Product对象的各个部件指定的 接口/ 抽象类。（只需要指定大体的流程怎么搞，具体的实现细节并不管。）</li>
<li><strong>ConcreteBuilder （具体建造者）：</strong> 实现接口，构建和装配各个部件。（具体的细节由它实现）</li>
<li><strong>Director （指挥者）：</strong> 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</li>
</ol>
<h3 id="3-、UML类图分析"><a href="#3-、UML类图分析" class="headerlink" title="(3)、UML类图分析"></a>(3)、UML类图分析</h3><img src="设计模式/QQ截图20200117155436.png" style="zoom:80%;" />

<h2 id="3、建造者模式解决盖房需求应用实例"><a href="#3、建造者模式解决盖房需求应用实例" class="headerlink" title="3、建造者模式解决盖房需求应用实例"></a>3、建造者模式解决盖房需求应用实例</h2><p>需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们<br>使用建造者模式(Builder Pattern)来完成。</p>
<h3 id="1-、UML类图分析-3"><a href="#1-、UML类图分析-3" class="headerlink" title="(1)、UML类图分析"></a>(1)、UML类图分析</h3><img src="设计模式/QQ截图20200117160514.png" style="zoom:80%;" />

<h3 id="2-、代码实现-1"><a href="#2-、代码实现-1" class="headerlink" title="(2)、代码实现"></a>(2)、代码实现</h3><p><code>House</code>实体类</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>{
   <span class="keyword">private</span> String baise;
   <span class="keyword">private</span> String wall;
   <span class="keyword">private</span> String roofed;
   <span class="comment">//...省略get，set，toString方法</span>
}</code></pre>
<p><code>HouseBuilder</code>抽象类，聚合<code>House</code>实体类，定义三个建房的方法，最后返回。抽象类中抽象方法子类必须实现，普通方法没有强制要求。</p>
<pre><code class="java"><span class="comment">// 抽象的建造者</span>
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> </span>{

   <span class="keyword">protected</span> House house = <span class="keyword">new</span> House();

   <span class="comment">//将建造的流程写好, 抽象的方法</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;
   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;
   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;

   <span class="comment">//建造房子好， 将产品(房子) 返回</span>
   <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> house;
   }
}</code></pre>
<p><code>CommonHouse</code>继承<code>HouseBuilder</code>抽象类，实现3个抽象方法</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>{

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>{
      house.setBaise(<span class="string">" 普通房子打地基5米"</span>);
   }
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>{
      house.setWall(<span class="string">" 普通房子砌墙10cm "</span>);
   }
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>{
      house.setRoofed(<span class="string">" 普通房子屋顶 "</span>);
   }
}</code></pre>
<p><code>HouseDirector</code>组合<code>HouseBuilder</code>，完成实际的房子创建。</p>
<pre><code class="java"><span class="comment">//指挥者，这里去指定制作流程，返回产品</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>{

   HouseBuilder houseBuilder = <span class="keyword">null</span>;

   <span class="comment">//构造器传入 houseBuilder</span>
   <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span> </span>{
      <span class="keyword">this</span>.houseBuilder = houseBuilder;
   }

   <span class="comment">//如何处理建造房子的流程，交给指挥者</span>
   <span class="function"><span class="keyword">public</span> House <span class="title">constructHouse</span><span class="params">()</span> </span>{
      houseBuilder.buildBasic();
      houseBuilder.buildWalls();
      houseBuilder.roofed();
      <span class="keyword">return</span> houseBuilder.buildHouse();
   }
}</code></pre>
<p><code>Client</code>进行调用</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
      <span class="comment">//盖普通房子</span>
      CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();
      <span class="comment">//准备创建房子的指挥者</span>
      HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector(commonHouse);

      <span class="comment">//完成盖房子，返回产品(普通房子)</span>
      House house = houseDirector.constructHouse();
      System.out.println(house);

      System.out.println(<span class="string">"--------------------------"</span>);

      <span class="comment">//盖高楼</span>
      HighBuilding highBuilding = <span class="keyword">new</span> HighBuilding();
      <span class="comment">//重置建造者</span>
      houseDirector = <span class="keyword">new</span> HouseDirector(highBuilding);
      house = houseDirector.constructHouse();
      System.out.println(house);
   }
}</code></pre>
<h2 id="4、建造者模式在-JDK-的应用和源码分析"><a href="#4、建造者模式在-JDK-的应用和源码分析" class="headerlink" title="4、建造者模式在 JDK 的应用和源码分析"></a>4、建造者模式在 JDK 的应用和源码分析</h2><p><code>java.lang.StringBuilder</code> 中用到了建造者模式</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">builder</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"hello,world"</span>);
        System.out.println(stringBuilder);
    }
}</code></pre>
<p>进入<code>StringBuilder</code></p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span>
<span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span>
<span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></code></pre>
<p>可以看到<code>StringBuilder</code>继承了抽象类<code>AbstractStringBuilder</code>，进入<code>AbstractStringBuilder</code></p>
<pre><code class="java"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span></code></pre>
<p>可以看到<code>AbstractStringBuilder</code>实现了<code>Appendable</code>，进入<code>Appendable</code></p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Appendable</span> </span>{
    <span class="function">Appendable <span class="title">append</span><span class="params">(CharSequence csq)</span> <span class="keyword">throws</span> IOException</span>;
    <span class="function">Appendable <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> <span class="keyword">throws</span> IOException</span>;
    <span class="function">Appendable <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">throws</span> IOException</span>;
}</code></pre>
<p><code>Appendable</code>为接口，就三个方法</p>
<img src="设计模式/QQ截图20200117172909.png" style="zoom:80%;" />

<h3 id="源码中建造者模式角色分析"><a href="#源码中建造者模式角色分析" class="headerlink" title="源码中建造者模式角色分析"></a>源码中建造者模式角色分析</h3><ol>
<li><code>Appendable</code>接口定义了多个 append 方法(抽象方法), 即 <code>Appendable</code> 为抽象建造者, 定义了抽象方法</li>
<li><code>AbstractStringBuilder</code> 实现了 Appendable 接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化</li>
<li><code>StringBuilder</code>即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由<code>AbstractStringBuilder</code> 完成, 而 <code>StringBuilder</code> 继承了 <code>AbstractStringBuilder</code></li>
</ol>
<p>JDK实现的比设计模式正统思想更早，早期写JDK的人太牛逼了，在不经意间就使用到了一定的设计模式，但和现在所提出的标准的设计模式有些许不一样，思想大致相同，是一个变种的Builder建造者模式。</p>
<h2 id="5、建造者模式的注意事项和细节"><a href="#5、建造者模式的注意事项和细节" class="headerlink" title="5、建造者模式的注意事项和细节"></a>5、建造者模式的注意事项和细节</h2><ol>
<li><p>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可<br>以创建不同的产品对象</p>
</li>
<li><p>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具<br>体建造者， 用户使用不同的具体建造者即可得到不同的产品对象</p>
</li>
<li><p>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加晰，也更方便使用程序来控制创建过程</p>
</li>
<li><p>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭<br>原则”，举个例子</p>
<p>增加一个<code>OtherHouse</code>类</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>{

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>{
      house.setBaise(<span class="string">" 其他房子打地基10米"</span>);
   }
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>{
      house.setWall(<span class="string">" 其他房子砌墙20cm "</span>);
   }
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>{
      house.setRoofed(<span class="string">" 其他房子屋顶 "</span>);
   }
}</code></pre>
<p>加上了这个<code>OtherHouse</code>实体类后，所有代码都不需要变动，直接在<code>Client</code>拿来用即可</p>
<pre><code class="java"><span class="comment">//盖其他房子</span>
OtherHouse otherHouse = <span class="keyword">new</span> OtherHouse();
<span class="comment">//重置建造者</span>
houseDirector = <span class="keyword">new</span> HouseDirector(otherHouse);
house = houseDirector.constructHouse();
System.out.println(house);</code></pre>
</li>
<li><p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<font color=red><strong>如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</strong></font></p>
</li>
<li><p>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因<br>此在这种情况下，要考虑是否选择建造者模式.</p>
</li>
</ol>
<h2 id="6、-抽象工厂模式-VS-建造者模式"><a href="#6、-抽象工厂模式-VS-建造者模式" class="headerlink" title="6、 抽象工厂模式 VS 建造者模式"></a>6、 抽象工厂模式 VS 建造者模式</h2><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采<br>用抽象工厂模式不需要关心构建过程（过程已经指定好了），只关心什么产品由什么工厂生产即可。<strong>什么工厂给我提供产品</strong>。</p>
<p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品，<strong>什么流程给我提供产品</strong>。</p>
<p>确实很微妙，只可意会，不可言传，在实践中慢慢体会。。。。。。</p>
<h1 id="五、适配器设计模式"><a href="#五、适配器设计模式" class="headerlink" title="五、适配器设计模式"></a>五、适配器设计模式</h1><h2 id="1、实际问题导出"><a href="#1、实际问题导出" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="现实生活中的适配器例子"><a href="#现实生活中的适配器例子" class="headerlink" title="现实生活中的适配器例子"></a>现实生活中的适配器例子</h3><p>泰国插座用的是两孔的（欧标），可以买个多功能转换插头 (适配器) ，这样就可以使用了</p>
<img src="设计模式/QQ截图20200117213618.png" style="zoom:80%;" />

<h3 id="适配器模式基本介绍"><a href="#适配器模式基本介绍" class="headerlink" title="适配器模式基本介绍"></a>适配器模式基本介绍</h3><ol>
<li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示， 主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li>
<li>适配器模式属于<strong>结构型模式</strong></li>
<li><font color=red>主要分为三类：<strong>类适配器模式、对象适配器模式、接口适配器模式</strong></font></li>
</ol>
<h3 id="适配器模式工作原理"><a href="#适配器模式工作原理" class="headerlink" title="适配器模式工作原理"></a>适配器模式工作原理</h3><ol>
<li><p>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</p>
</li>
<li><p>从用户的角度看不到被适配者，是解耦的</p>
</li>
<li><p>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</p>
</li>
<li><p>用户收到反馈结果，感觉只是和目标接口交互，如图</p>
</li>
</ol>
<img src="设计模式/QQ截图20200117214313.png" style="zoom: 67%;" />



<h2 id="2、类适配器模式"><a href="#2、类适配器模式" class="headerlink" title="2、类适配器模式"></a>2、类适配器模式</h2><h3 id="1-、基本介绍-3"><a href="#1-、基本介绍-3" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><p>Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。</p>
<h3 id="2-、应用实例说明"><a href="#2-、应用实例说明" class="headerlink" title="(2)、应用实例说明"></a>(2)、应用实例说明</h3><p>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们<br>的目 dst(即 目标)是 5V 直流电</p>
<h3 id="3-、UML类图分析-1"><a href="#3-、UML类图分析-1" class="headerlink" title="(3)、UML类图分析"></a>(3)、UML类图分析</h3><img src="设计模式/QQ截图20200117215410.png" style="zoom:80%;" />

<h3 id="4-、代码实现"><a href="#4-、代码实现" class="headerlink" title="(4)、代码实现"></a>(4)、代码实现</h3><p><code>Voltage220V</code>类提供220V电压</p>
<pre><code class="java"><span class="comment">//被适配的类</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>{
   <span class="comment">//输出220V的电压</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>{
      <span class="keyword">int</span> src = <span class="number">220</span>;
      System.out.println(<span class="string">"电压="</span> + src + <span class="string">"伏"</span>);
      <span class="keyword">return</span> src;
   }
}</code></pre>
<p><code>IVoltage5V</code>适配接口，必须要为接口才能让<code>VoltageAdapter</code>类同时继承和实现两个类</p>
<pre><code class="java"><span class="comment">//适配接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;
}</code></pre>
<p><code>VoltageAdapter</code>提供转换方法</p>
<pre><code class="java"><span class="comment">//适配器类</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>{
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>{
      <span class="comment">//获取到220V电压</span>
      <span class="keyword">int</span> srcV = output220V();
      <span class="comment">//转成 5v</span>
      System.out.println(<span class="string">"开始转换"</span>);
      <span class="keyword">int</span> dstV = srcV / <span class="number">44</span> ;
      <span class="keyword">return</span> dstV;
   }
}</code></pre>
<p><code>Phone</code>提供充电方法，<code>IVoltage5V</code>为形参，调用时使用多态将<code>VoltageAdapter</code>传进去</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>{
   <span class="comment">//充电</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> </span>{
      <span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) {
         System.out.println(<span class="string">"电压为5V, 可以充电~~"</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) {
         System.out.println(<span class="string">"电压大于5V, 不能充电~~"</span>);
      }
   }
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   System.out.println(<span class="string">" === 类适配器模式 ===="</span>);
   Phone phone = <span class="keyword">new</span> Phone();
   phone.charging(<span class="keyword">new</span> VoltageAdapter());
}</code></pre>
<h3 id="5-、类适配器模式注意事项和细节"><a href="#5-、类适配器模式注意事项和细节" class="headerlink" title="(5)、类适配器模式注意事项和细节"></a>(5)、类适配器模式注意事项和细节</h3><ol>
<li><p>Java 是<strong>单继承机制</strong>，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性;</p>
</li>
<li><p>src 类的方法在 Adapter 中都会<strong>暴露出来</strong>，也增加了使用的成本。</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>{
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>{
      <span class="comment">//获取到220V电压</span>
      <span class="keyword">int</span> srcV = output220V();</code></pre>
</li>
</ol>
<p>这里暴露了<code>output220V();</code>方法，如果src类中有很多方法，一个个调增加了使用的成本</p>
<ol start="3">
<li>由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。</li>
</ol>
<p>所谓，祸兮福所倚，福兮祸所伏。。。。。。</p>
<h2 id="3、对象适配器模式"><a href="#3、对象适配器模式" class="headerlink" title="3、对象适配器模式"></a>3、对象适配器模式</h2><h3 id="1-、基本介绍-4"><a href="#1-、基本介绍-4" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配</li>
<li>根据“ 合成复用原则”，在系统中尽量使用 关联关系（聚合）来替代继承关系。</li>
<li>对象适配器模式是适配器模式常用的一种</li>
</ol>
<h3 id="2-、应用实例说明-1"><a href="#2-、应用实例说明-1" class="headerlink" title="(2)、应用实例说明"></a>(2)、应用实例说明</h3><p>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们<br>的目 dst(即目标)是 5V 直流电，使用<strong>对象适配器模式</strong>完成。</p>
<h3 id="3-、UML类图分析-2"><a href="#3-、UML类图分析-2" class="headerlink" title="(3)、UML类图分析"></a>(3)、UML类图分析</h3><img src="设计模式/QQ截图20200117222715.png" style="zoom:80%;" />

<p>和上面的类适配器的UML图，就是<code>Voltage220V</code>和<code>VoltageAdapter</code>由继承转变为了聚合（由此<code>Client</code>也会多一个依赖<code>Voltage220V</code>）</p>
<h3 id="4-、代码实现-1"><a href="#4-、代码实现-1" class="headerlink" title="(4)、代码实现"></a>(4)、代码实现</h3><p>只写上变动的代码,<code>VoltageAdapter</code>设一个成员<code>Voltage220V</code></p>
<pre><code class="java"><span class="comment">//适配器类</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span>  <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>{
   <span class="keyword">private</span> Voltage220V voltage220V; <span class="comment">// 关联关系-聚合</span>

    <span class="comment">//通过构造器，传入一个 Voltage220V 实例</span>
   <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220v)</span> </span>{
      <span class="keyword">this</span>.voltage220V = voltage220v;
   }
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>{
      <span class="keyword">int</span> dst = <span class="number">0</span>;
      <span class="keyword">if</span>(<span class="keyword">null</span> != voltage220V) {
         <span class="keyword">int</span> src = voltage220V.output220V();<span class="comment">//获取220V 电压</span>
         System.out.println(<span class="string">"使用对象适配器，进行适配~~"</span>);
         dst = src / <span class="number">44</span>;
         System.out.println(<span class="string">"适配完成，输出的电压为="</span> + dst);
      }
      <span class="keyword">return</span> dst;
   }
}
</code></pre>
<p>在<code>phone.charging(new VoltageAdapter(new Voltage220V()));</code>里多<code>new Voltage220V()</code>,其他都是一样的</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   System.out.println(<span class="string">" === 对象适配器模式 ===="</span>);
   Phone phone = <span class="keyword">new</span> Phone();
   phone.charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));
}</code></pre>
<h3 id="5-、类适配器模式注意事项和细节-1"><a href="#5-、类适配器模式注意事项和细节-1" class="headerlink" title="(5)、类适配器模式注意事项和细节"></a>(5)、类适配器模式注意事项和细节</h3><ol>
<li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。<br>根据合成复用原则，使用<strong>聚合代替继承</strong>， 所以它解决了类适配器必须继承 src 的局限性问题，也<strong>不再要求 dst</strong><br><strong>必须是接口</strong>。</li>
<li><strong>使用成本更低，更灵活。</strong></li>
</ol>
<h2 id="4、接口适配器模式"><a href="#4、接口适配器模式" class="headerlink" title="4、接口适配器模式"></a>4、接口适配器模式</h2><h3 id="1-、基本介绍-5"><a href="#1-、基本介绍-5" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>一些书籍称为：适配器模式(DefaultAdapter Pattern)或 缺省适配器模式。</li>
<li>核心思路：当 不需要全部实现接口提供的方法时，可先 设计一个抽象类实现 接口，并为该接口中每个方法提供一个 默认实现（空方法），那么该 抽象类的子类可有选择地覆盖父类的某些方法来实现需求</li>
<li>适用于一个接口不想使用其所有的方法的情况。</li>
</ol>
<h3 id="2-、UML类图分析-1"><a href="#2-、UML类图分析-1" class="headerlink" title="(2)、UML类图分析"></a>(2)、UML类图分析</h3><img src="设计模式/QQ截图20200117225627.png" style="zoom:80%;" />

<h3 id="3-、代码实现"><a href="#3-、代码实现" class="headerlink" title="(3)、代码实现"></a>(3)、代码实现</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface4</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;
}</code></pre>
<p><code>AbsAdapter</code>默认实现，空实现</p>
<pre><code class="java"><span class="comment">//在AbsAdapter 我们将 Interface4 的方法进行默认实现</span>
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">Interface4</span> </span>{
   <span class="comment">//默认实现，空实现</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>{}

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>{}

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>{}

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>{}
}</code></pre>
<p>实验内部类，选择性重写要用的方法</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{

   AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter() {
      <span class="comment">//只需要去覆盖我们 需要使用 接口方法</span>
      <span class="meta">@Override</span>
      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>{
         System.out.println(<span class="string">"使用了m1的方法"</span>);
      }
   };
   absAdapter.m1();
}</code></pre>
<p>感觉这个接口适配器有点瓜皮。。。。。。</p>
<h2 id="5、适配器模式在-SpringMVC-框架应用的源码剖析"><a href="#5、适配器模式在-SpringMVC-框架应用的源码剖析" class="headerlink" title="5、适配器模式在 SpringMVC 框架应用的源码剖析"></a>5、适配器模式在 SpringMVC 框架应用的源码剖析</h2><ol>
<li>SpringMvc 中的 HandlerAdapter, 就使用了适配器模式</li>
<li>SpringMVC 处理请求的流程回顾<img src="设计模式/QQ截图20200118103630.png" style="zoom:80%;" /></li>
<li>使用 HandlerAdapter 的原因分析:<br>可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller 方法，需要调用的时候就得不断是使用 if else 来进行判断是哪一种子类然后执行。那么如果后面要扩展Controller，就得修改原来的代码，这样违背了 OCP 原则。</li>
</ol>
<p>在<code>DispatcherServlet</code>里面研究，进入源码,有一个方法</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>{

    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>{
}</code></pre>
<p><code>doDispatch</code>拿到浏览器传过来的HTTP请求地址，进行解析</p>
<pre><code class="java">HttpServletRequest processedRequest = request;
HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;
<span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;

WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

<span class="keyword">try</span> {
   ModelAndView mv = <span class="keyword">null</span>;
   Exception dispatchException = <span class="keyword">null</span>;

   <span class="keyword">try</span> {
      processedRequest = checkMultipart(request);
      multipartRequestParsed = (processedRequest != request);

      <span class="comment">// Determine handler for the current request.</span>
      <span class="comment">// 通过HandlerMapping来映射Controller</span>
      mappedHandler = getHandler(processedRequest);</code></pre>
<p>首先会创建<code>processedRequest</code>，这个<code>processedRequest</code>就是<code>request</code>,然后  <code>mappedHandler = getHandler(processedRequest);</code>拿到对应的控制器</p>
<pre><code class="java">mappedHandler = getHandler(processedRequest);
<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) {
   noHandlerFound(processedRequest, response);
   <span class="keyword">return</span>;
}

<span class="comment">// Determine handler adapter for the current request.</span>
<span class="comment">//获取适配器</span>
HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
<span class="comment">//...</span>
<span class="keyword">try</span> {
    <span class="comment">// Actually invoke the handler.</span>
    <span class="comment">// 通过适配器调用controller的方法并返回ModelAndView</span>
    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
                }
</code></pre>
<p>拿到对应的控制器之后，先判断是否为空，然后通过<code>getHandlerAdapter(mappedHandler.getHandler());</code></p>
<p>拿到对应的适配器，不同的Handler要调用不同的适配器进行处理，追踪<code>getHandlerAdapter</code></p>
<pre><code class="java"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>{
    <span class="comment">//一个for循环，如果为真（这个请求我能处理，就返回了）</span>
   <span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) {
      <span class="keyword">if</span> (logger.isTraceEnabled()) {
         logger.trace(<span class="string">"Testing handler adapter ["</span> + ha + <span class="string">"]"</span>);
      }
      <span class="keyword">if</span> (ha.supports(handler)) {
         <span class="keyword">return</span> ha;
      }
   }
   <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +
         <span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);
}</code></pre>
<p><code>HandlerAdapter</code>是一个接口，继续追踪</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>{</code></pre>
<img src="设计模式/QQ截图20200118094615.png" style="zoom:80%;" />

<p>HandlerAdapter 的实现子类使得每一种Controller有一种对应的适配器实现类，每种Controller 有不同的实现方式。</p>
<p>这看源码还是有点懵逼，下面手写一下，领会精神。</p>
<h2 id="6、手写-SpringMVC适配器"><a href="#6、手写-SpringMVC适配器" class="headerlink" title="6、手写 SpringMVC适配器"></a>6、手写 SpringMVC适配器</h2><h3 id="1-、UML类图分析-4"><a href="#1-、UML类图分析-4" class="headerlink" title="(1)、UML类图分析"></a>(1)、UML类图分析</h3><img src="设计模式/QQ截图20200118100841.png" style="zoom:80%;" />

<h3 id="2-、代码实现-2"><a href="#2-、代码实现-2" class="headerlink" title="(2)、代码实现"></a>(2)、代码实现</h3><p>定义<code>HandlerAdapter</code>，然后<code>SimpleHandlerAdapter</code>,<code>HttpHandlerAdapter</code>,<code>AnnotationHandlerAdapter</code>分别实现<code>public boolean supports(Object handler);</code>和<code>public void handle(Object handler);</code>两个方法</p>
<p><code>supports</code>方法是判断当期传过来的请求我能不能处理，这里简单的使用<code>instanceof</code>类型判断</p>
<p><code>handle</code>方法调用对应 <code>Controller</code> 真正的<code>handle</code>方法进行处理</p>
<pre><code class="java"><span class="comment">///定义一个Adapter接口 </span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span></span>;
}

<span class="comment">// 多种适配器类</span>

<span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>{

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>{
      ((SimpleController) handler).doSimplerHandler();
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>{
      <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> SimpleController);
   }

}

<span class="class"><span class="keyword">class</span> <span class="title">HttpHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>{

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>{
      ((HttpController) handler).doHttpHandler();
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>{
      <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpController);
   }

}

<span class="class"><span class="keyword">class</span> <span class="title">AnnotationHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>{

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>{
      ((AnnotationController) handler).doAnnotationHandler();
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>{

      <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> AnnotationController);
   }
}</code></pre>
<pre><code class="java"><span class="comment">//多种Controller实现  </span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>{

}

<span class="class"><span class="keyword">class</span> <span class="title">HttpController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHttpHandler</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">"http..."</span>);
   }
}

<span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSimplerHandler</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">"simple..."</span>);
   }
}

<span class="class"><span class="keyword">class</span> <span class="title">AnnotationController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnnotationHandler</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">"annotation..."</span>);
   }
}</code></pre>
<p><code>DispatchServlet</code>讲究，先定义一个静态的空列表，把所有的<code>handlerAdapters</code>在构造器里给装载进去，<code>getHandler</code>遍历所有请求，能被<code>controller</code>（指定的）处理的就返回对象，最后使用<code>doDispatch()</code>进行处理</p>
<pre><code class="java"><span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchServlet</span> </span>{

   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;HandlerAdapter&gt; handlerAdapters = <span class="keyword">new</span> ArrayList&lt;HandlerAdapter&gt;();

   <span class="function"><span class="keyword">public</span> <span class="title">DispatchServlet</span><span class="params">()</span> </span>{
      handlerAdapters.add(<span class="keyword">new</span> AnnotationHandlerAdapter());
      handlerAdapters.add(<span class="keyword">new</span> HttpHandlerAdapter());
      handlerAdapters.add(<span class="keyword">new</span> SimpleHandlerAdapter());
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">()</span> </span>{

      <span class="comment">// 此处模拟SpringMVC从request取handler的对象，</span>
      <span class="comment">// 适配器可以获取到希望的Controller</span>
       HttpController controller = <span class="keyword">new</span> HttpController();
      <span class="comment">// AnnotationController controller = new AnnotationController();</span>
      <span class="comment">//SimpleController controller = new SimpleController();</span>
      <span class="comment">// 得到对应适配器</span>
      HandlerAdapter adapter = getHandler(controller);
      <span class="comment">// 通过适配器执行对应的controller对应方法</span>
      adapter.handle(controller);

   }

   <span class="function"><span class="keyword">public</span> HandlerAdapter <span class="title">getHandler</span><span class="params">(Controller controller)</span> </span>{
      <span class="comment">//遍历：根据得到的controller(handler), 返回对应适配器</span>
      <span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) {
         <span class="keyword">if</span> (adapter.supports(controller)) {
            <span class="keyword">return</span> adapter;
         }
      }
      <span class="keyword">return</span> <span class="keyword">null</span>;
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
      <span class="keyword">new</span> DispatchServlet().doDispatch(); <span class="comment">// http...</span>
   }
}</code></pre>
<p>这个设计模式完全遵守OCP原则，测试一把，加一个新的<code>OtherController</code>和<code>OtherHandlerAdapter</code>,只需要</p>
<pre><code class="java"><span class="comment">//1.</span>
<span class="class"><span class="keyword">class</span> <span class="title">OtherHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>{

<span class="comment">//2.  </span>
<span class="class"><span class="keyword">class</span> <span class="title">OtherController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>{

<span class="comment">//3.加入列表中</span>
handlerAdapters.add(<span class="keyword">new</span> OtherHandlerAdapter());

<span class="comment">//4.直接用即可</span>
OtherController controller=<span class="keyword">new</span> OtherController();</code></pre>
<h3 id="3-、说明"><a href="#3-、说明" class="headerlink" title="(3)、说明"></a><strong>(3)、说明</strong></h3><p>• Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类<br>• 适配器代替controller执行相应的方法<br>• 扩展Controller 时，只需要增加一个适配器类就完成了SpringMVC的扩展了,<br>• <strong><font color=red>这就 是设计模式的力量</font></strong></p>
<h2 id="7、适配器模式的注意事项和细节"><a href="#7、适配器模式的注意事项和细节" class="headerlink" title="7、适配器模式的注意事项和细节"></a>7、适配器模式的注意事项和细节</h2><ol>
<li><p>三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来<br>命名的。</p>
<ul>
<li>类适配器：以类给到，在Adapter里，就是将src当做类，继承</li>
<li>对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有</li>
<li>接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现</li>
</ul>
</li>
<li><p>Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。</p>
</li>
<li><p>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</p>
</li>
</ol>
<h1 id="六、桥接设计模式"><a href="#六、桥接设计模式" class="headerlink" title="六、桥接设计模式"></a>六、桥接设计模式</h1><h2 id="1、实际问题导出-1"><a href="#1、实际问题导出-1" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="手机操作问题"><a href="#手机操作问题" class="headerlink" title="手机操作问题"></a>手机操作问题</h3><p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:</p>
<img src="设计模式/QQ截图20200118104421.png" style="zoom:80%;" />

<h3 id="传统方案解决手机操作问题"><a href="#传统方案解决手机操作问题" class="headerlink" title="传统方案解决手机操作问题"></a>传统方案解决手机操作问题</h3><img src="设计模式/QQ截图20200118104511.png" style="zoom:90%;" />

<h3 id="传统方案弊端分析"><a href="#传统方案弊端分析" class="headerlink" title="传统方案弊端分析"></a>传统方案弊端分析</h3><ol>
<li><p>扩展性问题(类爆炸)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</p>
</li>
<li><p>违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.</p>
</li>
<li><p><strong>解决方案-使用桥接模式</strong></p>
</li>
</ol>
<h2 id="2、桥接模式-Bridge"><a href="#2、桥接模式-Bridge" class="headerlink" title="2、桥接模式(Bridge)"></a>2、桥接模式(Bridge)</h2><h3 id="1-、基本介绍-6"><a href="#1-、基本介绍-6" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>桥接模式(Bridge 模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</li>
<li>是一种结构型设计模式</li>
<li>Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。</li>
</ol>
<h3 id="2-、原理类图"><a href="#2-、原理类图" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="设计模式/QQ截图20200118161531.png" style="zoom: 67%;" />

<p>上图说明</p>
<ol>
<li>Client 类：桥接模式的调用者</li>
<li>抽象类(Abstraction) :维护了 Implementor / 即它的实现类ConcreteImplementorA/B, 二者是聚合关系, Abstraction充当桥接类</li>
<li>RefinedAbstraction : 是 Abstraction 抽象类的子类</li>
<li>Implementor : 行为实现类的接口</li>
<li>ConcreteImplementorA/B ：行为的具体实现类</li>
<li>从 UML 图：这里的抽象类和接口是聚合的关系，其实调用和被调用关系</li>
</ol>
<h2 id="3、桥接模式解决手机操作问题"><a href="#3、桥接模式解决手机操作问题" class="headerlink" title="3、桥接模式解决手机操作问题"></a>3、桥接模式解决手机操作问题</h2><h3 id="1-、UML类图分析-5"><a href="#1-、UML类图分析-5" class="headerlink" title="(1)、UML类图分析"></a>(1)、UML类图分析</h3><img src="设计模式/QQ截图20200118162636.png" style="zoom:80%;" />

<h3 id="2-、代码实现-3"><a href="#2-、代码实现-3" class="headerlink" title="(2)、代码实现"></a>(2)、代码实现</h3><p><code>Brand</code>定义接口</p>
<pre><code class="java"><span class="comment">//接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>{
   <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;
   <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;
   <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;
}</code></pre>
<p><code>XiaoMi</code>手机类实现<code>Brand</code>，写上自己的方法，<code>Vivo</code>类同理，不列出</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMi</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>{
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">" 小米手机开机 "</span>);
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">" 小米手机关机 "</span>);
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">" 小米手机打电话 "</span>);
   }
}</code></pre>
<p><code>Phone</code>设计为抽象类，便于聚合<code>Brand</code>接口，调用时，实际实现的确是<code>XiaoMi</code>或<code>Vivo</code>类，这个桥接模式设计的确实好，方法前面不加<code>abstract</code>可以有选择性的重写还是不重写。</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>{
   <span class="comment">//聚合品牌</span>
   <span class="keyword">private</span> Brand brand;

   <span class="comment">//构造器</span>
   <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(Brand brand)</span> </span>{
      <span class="keyword">super</span>();
      <span class="keyword">this</span>.brand = brand;
   }

   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>{
      <span class="keyword">this</span>.brand.open();
   }
   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{
      <span class="keyword">this</span>.brand.close();
   }
   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>{
      <span class="keyword">this</span>.brand.call();
   }
}</code></pre>
<p><code>FoldedPhone</code>继承抽象类<code>Phone</code>，子类选择性重写方法。<code>UpRightPhone</code>和这个一样，不单独列出</p>
<pre><code class="java"><span class="comment">//折叠式手机类，继承 抽象类 Phone</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoldedPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>{

   <span class="comment">//构造器</span>
   <span class="function"><span class="keyword">public</span> <span class="title">FoldedPhone</span><span class="params">(Brand brand)</span> </span>{
      <span class="keyword">super</span>(brand);
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>{
      <span class="keyword">super</span>.open();
      System.out.println(<span class="string">" 折叠样式手机 "</span>);
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{
      <span class="keyword">super</span>.close();
      System.out.println(<span class="string">" 折叠样式手机 "</span>);
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>{
      <span class="keyword">super</span>.call();
      System.out.println(<span class="string">" 折叠样式手机 "</span>);
   }
}</code></pre>
<p>这个桥接模式确实设计的十分巧妙，2*2直接可以搞出4个不同的产品来，有效的解决了类爆炸的问题。</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   <span class="comment">//获取折叠式手机 (样式 + 品牌 )</span>
   Phone phone1 = <span class="keyword">new</span> FoldedPhone(<span class="keyword">new</span> XiaoMi());

   phone1.open();
   phone1.call();
   phone1.close();

   System.out.println(<span class="string">"=============="</span>);

   UpRightPhone phone4 = <span class="keyword">new</span> UpRightPhone(<span class="keyword">new</span> Vivo());

   phone4.open();
   phone4.call();
   phone4.close();
}</code></pre>
<h2 id="4、桥接模式在-JDBC-的源码剖析"><a href="#4、桥接模式在-JDBC-的源码剖析" class="headerlink" title="4、桥接模式在 JDBC 的源码剖析"></a>4、桥接模式在 JDBC 的源码剖析</h2><p>Jdbc 的 Driver  接口，如果从桥接模式来看，Driver 就是一个接口，下面可以有 MySQL 的 Driver，Oracle 的<br>Driver，这些就可以当做实现接口类</p>
<p>进入<code>MySQL</code>的ConnectionImpl</p>
<pre><code class="java"><span class="keyword">package</span> com.mysql.cj.jdbc;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionImpl</span> <span class="keyword">implements</span> <span class="title">JdbcConnection</span>, <span class="title">SessionEventListener</span>, <span class="title">Serializable</span> </span>{</code></pre>
<p>继续进入<code>JdbcConnection</code></p>
<pre><code class="java"><span class="keyword">package</span> com.mysql.cj.jdbc;
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JdbcConnection</span> <span class="keyword">extends</span> <span class="title">Connection</span>, <span class="title">MysqlConnection</span>, <span class="title">TransactionEventHandler</span> </span>{</code></pre>
<p>继续进入<code>MysqlConnection</code></p>
<pre><code class="java"><span class="keyword">package</span> com.mysql.cj;
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MysqlConnection</span> </span>{</code></pre>
<p>进入<code>Connection</code></p>
<pre><code class="java"><span class="keyword">package</span> java.sql;
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connection</span>  <span class="keyword">extends</span> <span class="title">Wrapper</span>, <span class="title">AutoCloseable</span> </span>{</code></pre>
<img src="设计模式/QQ截图20200118173053.png" style="zoom:67%;" />

<p><code>DriverManager</code>使用<code>getConnection</code>开启连接</p>
<img src="设计模式/QQ截图20200118173015.png" style="zoom:67%;" />



<h2 id="5、桥接模式的注意事项和细节"><a href="#5、桥接模式的注意事项和细节" class="headerlink" title="5、桥接模式的注意事项和细节"></a>5、桥接模式的注意事项和细节</h2><ol>
<li><p>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</p>
</li>
<li><p>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</p>
</li>
<li><p>桥接模式替代多层继承方案，可以减少 子类的个数，降低系统的管理和维护成本。</p>
</li>
<li><p>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</p>
</li>
<li><p>桥接模式要求 正确识别出系统中两个独立变化的维度( 抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。</p>
</li>
<li><p>桥接模式其它应用场景，对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.</p>
</li>
</ol>
<h2 id="7、常见的应用场景"><a href="#7、常见的应用场景" class="headerlink" title="7、常见的应用场景"></a>7、常见的应用场景</h2><ul>
<li>JDBC 驱动程序</li>
<li>银行转账系统<br>转账分类: 网上转账，柜台转账，AMT 转账<strong>（抽象）</strong><br>转账用户类型：普通用户，银卡用户，金卡用户..<strong>（实际）</strong></li>
<li>消息管理<br>消息类型：即时消息，延时消息<strong>（抽象）</strong><br>消息分类：手机短信，邮件消息，QQ 消息…<strong>（实际）</strong></li>
</ul>
<h1 id="七、装饰者设计模式"><a href="#七、装饰者设计模式" class="headerlink" title="七、装饰者设计模式"></a>七、装饰者设计模式</h1><h2 id="1、实际问题导出-2"><a href="#1、实际问题导出-2" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、星巴克咖啡订单项目（咖啡馆）："><a href="#1-、星巴克咖啡订单项目（咖啡馆）：" class="headerlink" title="(1)、星巴克咖啡订单项目（咖啡馆）："></a>(1)、星巴克咖啡订单项目（咖啡馆）：</h3><ol>
<li><p>咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)</p>
</li>
<li><p>调料：Milk、Soy(豆浆)、Chocolate</p>
</li>
<li><p>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</p>
</li>
<li><p>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</p>
</li>
</ol>
<h3 id="2-、方案-1-较差"><a href="#2-、方案-1-较差" class="headerlink" title="(2)、方案 1(较差)"></a>(2)、方案 1(较差)</h3><img src="设计模式/QQ截图20200118210456.png" style="zoom:67%;" />

<p> <strong>方案 1-解决星巴克咖啡订单问题分析</strong></p>
<ol>
<li>Drink 是一个抽象类，表示饮料</li>
<li>des 就是对咖啡的描述, 比如咖啡的名字</li>
<li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法.</li>
<li>Decaf 就是单品咖啡， 继承 Drink, 并实现 cost</li>
<li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li>
<li>问题:这样设计，会有很多类 ，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增 ，就会出现类爆炸。</li>
</ol>
<p>为什么不搞成4个单品，3种调料，然后每一个定义一个成员数量和静态常量单价，初始化时设置数量，最后计算时，数量乘单价计算总金额？</p>
<h3 id="3-、方案-2-好一点"><a href="#3-、方案-2-好一点" class="headerlink" title="(3)、方案 2(好一点)"></a>(3)、方案 2(好一点)</h3><img src="设计模式/QQ截图20200118212302.png" style="zoom:67%;" />

<p> <strong>方案 2-解决星巴克咖啡订单问题分析</strong></p>
<ol>
<li>方案2可以控制类的数量，不至于造成很多的类</li>
<li>在 增加或者删除调料种类时，代码的维护量很大</li>
<li>考虑到用户可以添加多份 调料时，可以将hasMilk 返回一个对应int</li>
<li>考虑使用 <font color=red><strong>装饰者</strong></font> 模式</li>
</ol>
<h2 id="2、装饰者模式"><a href="#2、装饰者模式" class="headerlink" title="2、装饰者模式"></a>2、装饰者模式</h2><h3 id="1-、装饰者模式原理"><a href="#1-、装饰者模式原理" class="headerlink" title="(1)、装饰者模式原理"></a>(1)、装饰者模式原理</h3><ol>
<li>装饰者模式就像打包一个快递<br>主体：比如：陶瓷、衣服 (Component)       // 被装饰者<br>包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)   // 装饰者</li>
<li>Component 主体：比如类似前面的 Drink</li>
<li>ConcreteComponent 和 DecoratorConcreteComponent：具体的主体，比如前面的各个单品咖啡</li>
<li>Decorator: 装饰者，比如各调料.在如图的 Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类。</li>
</ol>
<img src="设计模式/QQ截图20200118214054.png" style="zoom:67%;" />

<h3 id="2-、装饰者模式解决星巴克咖啡订单"><a href="#2-、装饰者模式解决星巴克咖啡订单" class="headerlink" title="(2)、装饰者模式解决星巴克咖啡订单"></a>(2)、装饰者模式解决星巴克咖啡订单</h3><h3 id="3-、UML类图分析-3"><a href="#3-、UML类图分析-3" class="headerlink" title="(3)、UML类图分析"></a>(3)、UML类图分析</h3><img src="设计模式/QQ截图20200118215001.png" style="zoom:67%;" />



<p><strong>装饰者模式下的订单：2 份巧克力+ 一份牛奶的LongBlack</strong></p>
<img src="设计模式/QQ截图20200118215150.png" style="zoom:67%;" />

<p><strong>说明</strong></p>
<ol>
<li>Milk包含了LongBlack</li>
<li>一份Chocolate包含了(Milk+LongBlack)</li>
<li>一份Chocolate包含了(Chocolate+Milk+LongBlack)</li>
<li>这样不管是什么形式的单品咖啡+调料组合，通过递归方式可以方便的组合和维护。</li>
</ol>
<h3 id="4-、代码实现-2"><a href="#4-、代码实现-2" class="headerlink" title="(4)、代码实现"></a>(4)、代码实现</h3><p><code>Drink</code>定义为<code>abstract</code>抽象类</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>{
   <span class="comment">// 描述</span>
   <span class="keyword">public</span> String des;
   <span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;

   <span class="comment">//省略了get，set方法</span>

   <span class="comment">//计算费用的抽象方法</span>
   <span class="comment">//子类来实现</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;
}</code></pre>
<p>定义一个所有咖啡种类的都要继承的<code>Coffee</code>缓冲类，直接返回父类的<code>getPrice()</code></p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span>  <span class="keyword">extends</span> <span class="title">Drink</span> </span>{
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> <span class="keyword">super</span>.getPrice();
   }
}</code></pre>
<p><code>Espresso</code>和<code>LongBlack</code>,<code>ShortBlack</code>为具体的咖啡种类，继承<code>Coffee</code>缓冲类，在构造时设置描述和价格</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>{

   <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span> </span>{
      setDes(<span class="string">" 意大利咖啡 "</span>);
      setPrice(<span class="number">6.0f</span>);
   }
}</code></pre>
<p>这个<code>Decorator</code>设计的妙啊，即把被装饰者单品咖啡的价格和描述拿到了，又加上了自己调料的价格和描述，</p>
<p><strong>继承加聚合，妙哉！</strong></p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>{
   <span class="keyword">private</span> Drink obj;

   <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink obj)</span> </span>{ <span class="comment">//组合</span>
      <span class="keyword">this</span>.obj = obj;
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>{
      <span class="comment">// getPrice是等下谁实现Decorator就是谁自己的价格</span>
      <span class="comment">//obj.cost()是成员变量obj所传过来的单独咖啡的价格</span>
      <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + obj.cost();
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>{
      <span class="comment">// obj.getDes() 输出被装饰者的信息</span>
     <span class="keyword">return</span> des + <span class="string">" "</span> + getPrice() + <span class="string">" &amp;&amp; "</span> + obj.getDes()+ <span class="string">" "</span> ;
   }
}</code></pre>
<p>调料类<code>Milk</code>,<code>Soy</code>和<code>Chocolate</code>继承<code>Decorator</code>，直接调用父类的构造方法，既拿到被装饰者单品咖啡的价格和描述，又设置自己单独的价格和描述。</p>
<pre><code class="java"><span class="comment">//具体的Decorator， 这里就是调味品</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>{

   <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink obj)</span> </span>{
      <span class="keyword">super</span>(obj);
      setDes(<span class="string">" 牛奶 "</span>);
      setPrice(<span class="number">2.0f</span>);
   }
}</code></pre>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   <span class="comment">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span>

   <span class="comment">// 1. 点一份 LongBlack</span>
   Drink order = <span class="keyword">new</span> LongBlack();
   System.out.println(<span class="string">"order点一份 LongBlack  费用="</span> + order.cost());
   System.out.println(<span class="string">"order点一份 LongBlack  描述="</span> + order.getDes());
   System.out.println(<span class="string">"==========================="</span>);

   <span class="comment">// 2. order 加入一份牛奶</span>
   order = <span class="keyword">new</span> Milk(order);
   System.out.println(<span class="string">"order 加入一份牛奶 费用 ="</span> + order.cost());
   System.out.println(<span class="string">"order 加入一份牛奶 描述 = "</span> + order.getDes());
   System.out.println(<span class="string">"==========================="</span>);

   <span class="comment">// 3. order 加入一份巧克力</span>
   order = <span class="keyword">new</span> Chocolate(order);
   System.out.println(<span class="string">"order 加入一份牛奶 加入一份巧克力  费用 ="</span> + order.cost());
   System.out.println(<span class="string">"order 加入一份牛奶 加入一份巧克力 描述 = "</span> + order.getDes());
   System.out.println(<span class="string">"==========================="</span>);

   <span class="comment">// 4. order 再加入一份巧克力</span>
   order = <span class="keyword">new</span> Chocolate(order);
   System.out.println(<span class="string">"order 加入一份牛奶 加入2份巧克力   费用 ="</span> + order.cost());
   System.out.println(<span class="string">"order 加入一份牛奶 加入2份巧克力 描述 = "</span> + order.getDes());
   System.out.println(<span class="string">"==========================="</span>);
}

<span class="comment">//结果</span>
order点一份 LongBlack  费用=<span class="number">5.0</span>
order点一份 LongBlack  描述= longblack 
===========================
order 加入一份牛奶 费用 =<span class="number">7.0</span>
order 加入一份牛奶 描述 =  牛奶  <span class="number">2.0</span> &amp;&amp;  longblack  
===========================
order 加入一份牛奶 加入一份巧克力  费用 =<span class="number">10.0</span>
order 加入一份牛奶 加入一份巧克力 描述 =  巧克力  <span class="number">3.0</span> &amp;&amp;  牛奶  <span class="number">2.0</span> &amp;&amp;  longblack   
===========================
order 加入一份牛奶 加入<span class="number">2</span>份巧克力   费用 =<span class="number">13.0</span>
order 加入一份牛奶 加入<span class="number">2</span>份巧克力 描述 =  巧克力  <span class="number">3.0</span> &amp;&amp;  巧克力  <span class="number">3.0</span> &amp;&amp;  牛奶  <span class="number">2.0</span> &amp;&amp;  longblack    </code></pre>
<p>这种<strong>装饰者模式</strong>的遵守OCP原则，加入一种新品咖啡只需要就创建一个新的实体类就可以用，妙哉！</p>
<p>举个例子，加入一种<code>DeCaf</code>咖啡，写好后，什么都不用改，直接就能用</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeCaf</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>{

   <span class="function"><span class="keyword">public</span> <span class="title">DeCaf</span><span class="params">()</span> </span>{
      setDes(<span class="string">" 无因咖啡 "</span>);
      setPrice(<span class="number">1.0f</span>);
   }
}</code></pre>
<pre><code class="java">Drink order2 = <span class="keyword">new</span> DeCaf();

System.out.println(<span class="string">"order2 无因咖啡  费用 ="</span> + order2.cost());
System.out.println(<span class="string">"order2 无因咖啡 描述 = "</span> + order2.getDes());

order2 = <span class="keyword">new</span> Milk(order2);

System.out.println(<span class="string">"order2 无因咖啡 加入一份牛奶  费用 ="</span> + order2.cost());
System.out.println(<span class="string">"order2 无因咖啡 加入一份牛奶 描述 = "</span> + order2.getDes());
<span class="comment">//结果</span>
order2 无因咖啡  费用 =<span class="number">1.0</span>
order2 无因咖啡 描述 =  无因咖啡 
order2 无因咖啡 加入一份牛奶  费用 =<span class="number">3.0</span>
order2 无因咖啡 加入一份牛奶 描述 =  牛奶  <span class="number">2.0</span> &amp;&amp;  无因咖啡  </code></pre>
<h2 id="3、装饰者模式在-JDK-应用的源码分析"><a href="#3、装饰者模式在-JDK-应用的源码分析" class="headerlink" title="3、装饰者模式在 JDK 应用的源码分析"></a>3、装饰者模式在 JDK 应用的源码分析</h2><p>在JDK 的IO体系中，就是使用<strong>装饰者模式</strong>，分析如下</p>
<pre><code class="java">DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"d:\\abc.txt"</span>));
System.out.println(dis.read());
dis.close();</code></pre>
<p>进入<code>FileInputStream</code>,可以看到继承了<code>InputStream</code>，继续进去</p>
<p><code>FileInputStream</code> 是 <code>InputStream</code>子类，类似我们前面的 <code>DeCaf</code>, <code>LongBlack</code>单品咖啡</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>{</code></pre>
<p><code>InputStream</code> 是抽象类, 类似我们前面讲的<code>Drink</code></p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>{</code></pre>
<p><code>FilterInputStream</code> 是<code>InputStream</code> 子类：类似我们前面 的 <code>Decorator</code> 修饰者</p>
<p><code>FilterInputStream</code>类 有  <code>protected volatile InputStream in;</code>即含被装饰者</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>{

    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;

    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>{
        <span class="keyword">this</span>.in = in;
    }</code></pre>
<p><code>DataInputStream</code> 是<code>FilterInputStream</code> 子类，具体的修饰者，类似前面的 <code>Milk</code>, <code>Soy</code>等</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> <span class="keyword">implements</span> <span class="title">DataInput</span> </span>{</code></pre>
<p>弹幕补充：</p>
<p>桥接是抽象聚合接口，装饰者是接口聚合抽象</p>
<p>个人感觉装饰和桥接的最大区别是：装饰者如咖啡可以同时加冰和加糖,而桥接就像如手机内存一样只能有如4G或者8G</p>
<h1 id="八、组合设计模式"><a href="#八、组合设计模式" class="headerlink" title="八、组合设计模式"></a>八、组合设计模式</h1><h2 id="1、实际问题导出-3"><a href="#1、实际问题导出-3" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、一个学校院系展示需求"><a href="#1-、一个学校院系展示需求" class="headerlink" title="(1)、一个学校院系展示需求"></a>(1)、一个学校院系展示需求</h3><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，<br>一个学院有多个系。如图</p>
<img src="设计模式/QQ截图20200119094742.png" style="zoom:50%;" />

<h3 id="2-、传统方案解决学校院系展示"><a href="#2-、传统方案解决学校院系展示" class="headerlink" title="(2)、传统方案解决学校院系展示"></a>(2)、传统方案解决学校院系展示</h3><img src="设计模式/QQ截图20200119094840.png" style="zoom:33%;" />

<h3 id="3-、传统方案存在的问题分析"><a href="#3-、传统方案存在的问题分析" class="headerlink" title="(3)、传统方案存在的问题分析"></a>(3)、传统方案存在的问题分析</h3><ol>
<li>将 学院看做是学校的子类， 系是学院的子类，这样实际上是站在组织大小来进行分层次的</li>
<li>实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现的管理的操作，比如对学院、系的 添加，删除，遍历等</li>
<li>解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作。 =&gt;  <strong><font color=red>组合模式</font></strong></li>
</ol>
<h2 id="2、组合模式"><a href="#2、组合模式" class="headerlink" title="2、组合模式"></a>2、组合模式</h2><h3 id="1-、基本介绍-7"><a href="#1-、基本介绍-7" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“ 整体- 部分”的层次关系。</li>
<li>组合模式 依据树形结构来组合对象，用来表示部分以及整体层次。</li>
<li>这种类型的设计模式属于结构型模式。</li>
<li>组合模式使得 用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象</li>
</ol>
<h3 id="2-、原理类图-1"><a href="#2-、原理类图-1" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="设计模式/QQ截图20200119095614.png" style="zoom: 67%;" />

<p><strong>对原理结构图的说明-即(组合模式的角色及职责)：</strong></p>
<ol>
<li>Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component 可以是抽象类或者接口。</li>
<li>Leaf : 在组合中表示叶子节点，叶子节点没有子节点</li>
<li>Composite :非叶子节点， 用于存储子部件， 在 Component 接口中实现 子部件的相关操作，比如增加(add),删除(remove)。</li>
</ol>
<h3 id="3-、组合模式解决学校院系展示的应用实例"><a href="#3-、组合模式解决学校院系展示的应用实例" class="headerlink" title="(3)、组合模式解决学校院系展示的应用实例"></a>(3)、组合模式解决学校院系展示的应用实例</h3><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，<br>一个学院有多个系。</p>
<h3 id="4-、UML类图分析"><a href="#4-、UML类图分析" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="设计模式/QQ截图20200119100705.png" style="zoom:67%;" />

<h3 id="5-、代码实现"><a href="#5-、代码实现" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p><code>OrganizationComponent</code>所有组织类的基类，写成<code>abstract</code>抽象类，<code>print</code>写成抽象方法，所有子类都需要去实现各自的打印功能，<code>add</code>和<code>remove</code>不用写成抽象方法，叶子节点的<code>Department</code>不用<code>add</code>和<code>remove</code>功能，(下面没有其他要管理的东西了)</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationComponent</span> </span>{
   <span class="keyword">private</span> String name; <span class="comment">// 名字</span>
   <span class="keyword">private</span> String des; <span class="comment">// 说明</span>

   <span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>{
        <span class="comment">//默认实现</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();
    }

   <span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>{
        <span class="comment">//默认实现</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();
    }

    <span class="comment">//方法print, 做成抽象的, 子类都需要实现</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;

    <span class="comment">//省略get，set方法没写</span>
}</code></pre>
<p><code>Department</code>叶子节点</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>{

   <span class="comment">//叶子节点，没有集合，不用聚合其他东西</span>

   <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String des)</span> </span>{
      <span class="keyword">super</span>(name, des);
   }

   <span class="comment">//add , remove 就不用写了，因为他是叶子节点</span>

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> <span class="keyword">super</span>.getName();
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> <span class="keyword">super</span>.getDes();
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{
      System.out.println(getName());
   }
}</code></pre>
<p><code>College</code>通过<code>OrganizationComponent</code>多态去管理各个专业，这里没有强制，如果把上级学校给装进去了也可以，要十分小心上下级关系。</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>{

   <span class="comment">//List 中 存放的Department</span>
   List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();

   <span class="comment">// 构造器</span>
   <span class="function"><span class="keyword">public</span> <span class="title">College</span><span class="params">(String name, String des)</span> </span>{
      <span class="keyword">super</span>(name, des);
   }

   <span class="comment">// 重写add，将来实际业务中，Colleage 的 add 和  University add 不一定完全一样</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>{ 
      organizationComponents.add(organizationComponent);
   }

   <span class="comment">// 重写remove</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>{
      organizationComponents.remove(organizationComponent);
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> <span class="keyword">super</span>.getName();
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> <span class="keyword">super</span>.getDes();
   }

   <span class="comment">// print方法，就是输出University 包含的学院</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">"--------------"</span> + getName() + <span class="string">"--------------"</span>);
      <span class="comment">//遍历 organizationComponents</span>
      <span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) {
         organizationComponent.print();
      }
   }
}</code></pre>
<p><code>University</code>和上面的<code>College</code>一样</p>
<pre><code class="java"><span class="comment">//University 就是 Composite , 可以管理College</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">University</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>{

   List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();

   <span class="comment">// 构造器</span>
   <span class="function"><span class="keyword">public</span> <span class="title">University</span><span class="params">(String name, String des)</span> </span>{
      <span class="keyword">super</span>(name, des);
   }

   <span class="comment">// 重写add</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>{
      organizationComponents.add(organizationComponent);
   }

   <span class="comment">// 重写remove</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>{
      organizationComponents.remove(organizationComponent);
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> <span class="keyword">super</span>.getName();
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> <span class="keyword">super</span>.getDes();
   }

   <span class="comment">// print方法，就是输出University 包含的学院</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">"--------------"</span> + getName() + <span class="string">"--------------"</span>);
      <span class="comment">//遍历 organizationComponents</span>
      <span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) {
         organizationComponent.print();
      }
   }
}</code></pre>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   <span class="comment">//从大到小创建对象 学校</span>
   OrganizationComponent university = <span class="keyword">new</span> University(<span class="string">"清华大学"</span>, <span class="string">" 中国顶级大学 "</span>);

   <span class="comment">//创建 学院</span>
   OrganizationComponent computerCollege = <span class="keyword">new</span> College(<span class="string">"计算机学院"</span>, <span class="string">" 计算机学院 "</span>);
   OrganizationComponent infoEngineercollege = <span class="keyword">new</span> College(<span class="string">"信息工程学院"</span>, <span class="string">" 信息工程学院 "</span>);


   <span class="comment">//创建各个学院下面的系(专业)</span>
   computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"软件工程"</span>, <span class="string">" 软件工程不错 "</span>));
   computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"网络工程"</span>, <span class="string">" 网络工程不错 "</span>));
   computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"计算机科学与技术"</span>, <span class="string">" 计算机科学与技术是老牌的专业 "</span>));

   <span class="comment">//</span>
   infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">"通信工程"</span>, <span class="string">" 通信工程不好学 "</span>));
   infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">"信息工程"</span>, <span class="string">" 信息工程好学 "</span>));

   <span class="comment">//将学院加入到 学校</span>
   university.add(computerCollege);
   university.add(infoEngineercollege);

   <span class="comment">//university.print();</span>
   infoEngineercollege.print();
}</code></pre>
<p>要特别注意上下级关系要程序员手动维护，不然会出错，<code>OrganizationComponent</code>就是个容器，装谁都是装</p>
<pre><code class="java">computerCollege.add(university);
computerCollege.print();</code></pre>
<h2 id="3、组合模式在-JDK-集合的源码分析"><a href="#3、组合模式在-JDK-集合的源码分析" class="headerlink" title="3、组合模式在 JDK 集合的源码分析"></a>3、组合模式在 JDK 集合的源码分析</h2><p>Java 的集合类-HashMap 就使用了组合模式</p>
<img src="设计模式/QQ截图20200119105544.png" style="zoom:67%;" />

<pre><code class="java">Map&lt;Integer,String&gt; hashMap=<span class="keyword">new</span> HashMap&lt;Integer,String&gt;();
hashMap.put(<span class="number">0</span>, <span class="string">"东游记"</span>);<span class="comment">//直接存放叶子节点(Node)</span>

Map&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,String&gt;();
map.put(<span class="number">1</span>, <span class="string">"西游记"</span>);
map.put(<span class="number">2</span>, <span class="string">"红楼梦"</span>); <span class="comment">//..</span>
hashMap.putAll(map);
System.out.println(hashMap);</code></pre>
<p><code>Map</code>定义为接口，里面定义了许多方法，上面演示的<code>put</code>和<code>putAll</code>就在其中定义了</p>
<p><code>Map</code> 就是一个抽象的构建 (类似我们的<code>Component</code>)</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{
    <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;</code></pre>
<p><code>AbstractMap</code>作为一个中间件，缓冲了一下，也是个<code>abstract</code>抽象类，默认实现了一下<code>Map</code>里的方法</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{
    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{
        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>{
        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())
            put(e.getKey(), e.getValue());
    }</code></pre>
<p><code>HashMap</code>真正实现了那些抽象方法，<code>HashMap</code>是一个中间的构建(Composite), 实现/继承了相关方法</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>
<span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>{

    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{
        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);
    }

    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span>
<span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>{
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;
        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)
            n = (tab = resize()).length;
        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)
            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</code></pre>
<p>其中在<code>HashMap</code>里面有一个<code>Node</code>静态内部类，这个<code>Node</code>静态内部类就没有了<code>put</code>和<code>putAll</code>等方法，只有一些<code>get</code>方法，类似Leaf叶子节点（之前的<code>Department</code>）</p>
<pre><code class="java"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{
    <span class="keyword">final</span> <span class="keyword">int</span> hash;
    <span class="keyword">final</span> K key;
    V value;
    Node&lt;K,V&gt; next;

    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) {
        <span class="keyword">this</span>.hash = hash;
        <span class="keyword">this</span>.key = key;
        <span class="keyword">this</span>.value = value;
        <span class="keyword">this</span>.next = next;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>{ <span class="keyword">return</span> key; }
        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>{ <span class="keyword">return</span> value; }
        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>{ <span class="keyword">return</span> key + <span class="string">"="</span> + value; }</code></pre>
<h2 id="4、-组合模式的注意事项和细节"><a href="#4、-组合模式的注意事项和细节" class="headerlink" title="4、 组合模式的注意事项和细节"></a>4、 组合模式的注意事项和细节</h2><ol>
<li>简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。</li>
<li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。</li>
<li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从创建出复杂的树形结构</li>
<li>需要遍历组织机构，或者处理的对象具有树形结构时, <strong>非常适合使用组合模式.</strong></li>
<li>要求较高的抽象性，如果 节点和叶子有很多差异性的话，比如很多方法和属性都不一样，<strong>不适合使用组合模式</strong></li>
</ol>
<h1 id="九、外观设计模式"><a href="#九、外观设计模式" class="headerlink" title="九、外观设计模式"></a>九、外观设计模式</h1><h2 id="1、实际问题导出-4"><a href="#1、实际问题导出-4" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、影院管理项目"><a href="#1-、影院管理项目" class="headerlink" title="(1)、影院管理项目"></a>(1)、影院管理项目</h3><p>组建一个家庭影院：<br>DVD 播放器、投影仪、自动屏幕、环绕立体声、爆米花机,要求完成使用家庭影院的功能，其过程为：<br>直接用遥控器：统筹各设备开关<br>开爆米花机<br>放下屏幕<br>开投影仪<br>开音响<br>开 DVD，选 dvd<br>去拿爆米花<br>调暗灯光<br>播放<br>观影结束后，关闭各种设备</p>
<h3 id="2-、传统方式解决影院管理"><a href="#2-、传统方式解决影院管理" class="headerlink" title="(2)、传统方式解决影院管理"></a>(2)、传统方式解决影院管理</h3><img src="设计模式/QQ截图20200119160215.png" style="zoom: 67%;" />

<h3 id="3-、传统方式存在的问题分析"><a href="#3-、传统方式存在的问题分析" class="headerlink" title="(3)、传统方式存在的问题分析"></a>(3)、传统方式存在的问题分析</h3><ol>
<li>在 ClientTest 的 main 方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成调用过程混乱，没有清晰的过程</li>
<li>不利于在 ClientTest 中，去维护对子系统的操作</li>
<li>解决思路：定义一个高层接口，给子系统中的一组接口提供一个一致的界面(比如在高层接口提供四个方法ready, play, pause, end )，用来访问子系统中的一群接口</li>
<li>也就是说 就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节 =&gt;   <strong><font color=red>外观模式</font></strong></li>
</ol>
<h2 id="2、外观模式"><a href="#2、外观模式" class="headerlink" title="2、外观模式"></a>2、外观模式</h2><h3 id="1-、基本介绍-8"><a href="#1-、基本介绍-8" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口 提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li>
<li>外观模式通过定义一个一致的接口，用以<strong>屏蔽内部子系统的细节</strong>，使得 调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节</li>
</ol>
<h3 id="2-、原理类图-2"><a href="#2-、原理类图-2" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="设计模式/QQ截图20200119161206.png" style="zoom:67%;" />

<p>对类图说明(分类外观模式的角色)</p>
<ol>
<li>外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代<br>理给适当子系统对象</li>
<li>调用者(Client): 外观接口的调用者</li>
<li>子系统的集合：子模块或者子系统，处理 Facade 对象指派的任务，他是功能的实际提供者</li>
</ol>
<h3 id="3-、外观模式解决影院管理"><a href="#3-、外观模式解决影院管理" class="headerlink" title="(3)、外观模式解决影院管理"></a>(3)、外观模式解决影院管理</h3><ol>
<li>外观模式可以理解为转换一群接口，客户只要调用一个接口，而不用调用多个接口才能达到目的。比如：在 pc上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）。</li>
<li>外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用</li>
</ol>
<h3 id="4-、UML类图分析-1"><a href="#4-、UML类图分析-1" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="设计模式/QQ截图20200119162540.png" style="zoom: 60%;" />



<h3 id="5-、代码实现-1"><a href="#5-、代码实现-1" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p>先定义几个实体类<code>DVDPlayer</code>、<code>Popcorn</code>、<code>Projector</code>、<code>Screen</code>、<code>Stereo</code>和<code>TheaterLight</code></p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DVDPlayer</span> </span>{
   <span class="comment">//使用一把单例模式, 使用饿汉式</span>
   <span class="function"><span class="keyword">private</span> <span class="title">DVDPlayer</span><span class="params">()</span></span>{}

   <span class="keyword">private</span> <span class="keyword">static</span> DVDPlayer instance = <span class="keyword">new</span> DVDPlayer();

   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DVDPlayer <span class="title">getInstanc</span><span class="params">()</span> </span>{ <span class="keyword">return</span> instance;}

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>{  System.out.println(<span class="string">" dvd on "</span>);  }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>{  System.out.println(<span class="string">" dvd off "</span>);  }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>{ System.out.println(<span class="string">" dvd is playing "</span>); }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>{ System.out.println(<span class="string">" dvd pause .."</span>);}
   <span class="comment">//....</span>
}</code></pre>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Popcorn</span> </span>{

   <span class="function"><span class="keyword">private</span> <span class="title">Popcorn</span><span class="params">()</span></span>{}

   <span class="keyword">private</span> <span class="keyword">static</span> Popcorn instance = <span class="keyword">new</span> Popcorn();

   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Popcorn <span class="title">getInstance</span><span class="params">()</span> </span>{ <span class="keyword">return</span> instance; }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>{ System.out.println(<span class="string">" popcorn on "</span>);}

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>{ System.out.println(<span class="string">" popcorn ff "</span>);}

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{ System.out.println(<span class="string">" popcorn is poping  "</span>);}
}</code></pre>
<p><code>HomeTheaterFacade</code>聚合各个对象，在构造函数里面加载进来。</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeTheaterFacade</span> </span>{

   <span class="comment">//定义各个子系统对象，聚合进来</span>
   <span class="keyword">private</span> TheaterLight theaterLight;
   <span class="keyword">private</span> Popcorn popcorn;
   <span class="keyword">private</span> Stereo stereo;
   <span class="keyword">private</span> Projector projector;
   <span class="keyword">private</span> Screen screen;
   <span class="keyword">private</span> DVDPlayer dVDPlayer;


   <span class="comment">//构造器</span>
   <span class="function"><span class="keyword">public</span> <span class="title">HomeTheaterFacade</span><span class="params">()</span> </span>{
      <span class="keyword">this</span>.theaterLight = TheaterLight.getInstance();
      <span class="keyword">this</span>.popcorn = Popcorn.getInstance();
      <span class="keyword">this</span>.stereo = Stereo.getInstance();
      <span class="keyword">this</span>.projector = Projector.getInstance();
      <span class="keyword">this</span>.screen = Screen.getInstance();
      <span class="keyword">this</span>.dVDPlayer = DVDPlayer.getInstanc();
   }
    <span class="comment">//设计不同阶段的方法，调用聚合成员的各个方法</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>{
        popcorn.on();  popcorn.pop();  screen.down();
        projector.on(); stereo.on();  dVDPlayer.on();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>{
        dVDPlayer.play();
    }</code></pre>
<p><code>main</code>方法直接示例化一个调用<code>HomeTheaterFacade</code>，调用其中不同阶段的方法就可以了，不用每个对象new一下。</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   HomeTheaterFacade homeTheaterFacade = <span class="keyword">new</span> HomeTheaterFacade();
   homeTheaterFacade.ready();
   homeTheaterFacade.play();
   homeTheaterFacade.end();
}</code></pre>
<p><strong>话说，这个不是在平常中就会用到的吗。。。。没学设计模式之前，平时就是这么设计的。</strong></p>
<h2 id="3、外观模式在-MyBatis-框架应用的源码分析"><a href="#3、外观模式在-MyBatis-框架应用的源码分析" class="headerlink" title="3、外观模式在 MyBatis 框架应用的源码分析"></a>3、外观模式在 MyBatis 框架应用的源码分析</h2><p>在MyBatis 中的<code>Configuration</code>有两个成员<code>objectFactory</code>和<code>objectWrapperFactory</code>直接给new出来了，在下面的方法<code>newMetaObject</code>方法中进行了赋值，追踪<code>MetaObject.forObject</code>进去</p>
<p>特别说明：<code>ObjectWrapperFactory</code>和<code>ObjectFactory</code>是两个接口</p>
<pre><code class="java"><span class="keyword">package</span> org.apache.ibatis.session;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>{
 <span class="keyword">protected</span> ObjectFactory objectFactory = <span class="keyword">new</span> DefaultObjectFactory();
 <span class="keyword">protected</span> ObjectWrapperFactory objectWrapperFactory = <span class="keyword">new</span> DefaultObjectWrapperFactory();

    <span class="function"><span class="keyword">public</span> MetaObject <span class="title">newMetaObject</span><span class="params">(Object object)</span> </span>{
    <span class="keyword">return</span> MetaObject.forObject(object, objectFactory, objectWrapperFactory);
  }</code></pre>
<p><code>MetaObject.forObject</code>先判断是否为空，然后直接使用构造函数，<code>MetaObject</code>也聚合了这几个成员，在构造器中进行赋值，直接使用<code>instanceof</code>判断类型是否相等，相等直接返回</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaObject</span> </span>{

  <span class="keyword">private</span> Object originalObject;
  <span class="keyword">private</span> ObjectWrapper objectWrapper;
  <span class="keyword">private</span> ObjectFactory objectFactory;
  <span class="keyword">private</span> ObjectWrapperFactory objectWrapperFactory;

 <span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory)</span> </span>{
    <span class="keyword">this</span>.originalObject = object;
    <span class="keyword">this</span>.objectFactory = objectFactory;
    <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;

    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) {
      <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;
    } <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) {
      <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);
    } <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) {
      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);
    } <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) {
      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);
    }
  }


<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaObject <span class="title">forObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory)</span> </span>{
  <span class="keyword">if</span> (object == <span class="keyword">null</span>) {
    <span class="keyword">return</span> SystemMetaObject.NULL_META_OBJECT;
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> <span class="keyword">new</span> MetaObject(object, objectFactory, objectWrapperFactory);
  }
}</code></pre>
<p>这个<code>MetaObject</code>相当于多搞了一层而且，然后期间使用了接口和多态，大致思想是一样的，外观模式。</p>
<p><strong>源码类图</strong></p>
<img src="设计模式/QQ截图20200119172108.png" style="zoom:67%;" />



<h2 id="4、外观模式的注意事项和细节"><a href="#4、外观模式的注意事项和细节" class="headerlink" title="4、外观模式的注意事项和细节"></a>4、外观模式的注意事项和细节</h2><ol>
<li>外观模式<font color=red><strong>对外屏蔽了子系统的细节</strong></font>，因此外观模式降低了客户端对子系统使用的复杂性</li>
<li>外观模式对客户端与子系统的耦合关系 - 解耦，让子系统内部的模块更易维护和扩展</li>
<li>通过合理的使用外观模式，可以帮我们更好的<font color=red><strong>划分访问的层次</strong></font></li>
<li>当系统需要进行分层设计时，可以考虑使用 Facade 模式</li>
<li>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性</li>
<li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的</li>
</ol>
<h1 id="十、享元设计模式"><a href="#十、享元设计模式" class="headerlink" title="十、享元设计模式"></a>十、享元设计模式</h1><h2 id="1、实际问题导出-5"><a href="#1、实际问题导出-5" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、展示网站项目需求"><a href="#1-、展示网站项目需求" class="headerlink" title="(1)、展示网站项目需求"></a>(1)、展示网站项目需求</h3><p>小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：</p>
<ol>
<li>有客户要求以新闻的形式发布</li>
<li>有客户人要求以博客的形式发布</li>
<li>有客户希望以微信公众号的形式发布</li>
</ol>
<h3 id="2-、传统方案解决网站展现项目"><a href="#2-、传统方案解决网站展现项目" class="headerlink" title="(2)、传统方案解决网站展现项目"></a>(2)、传统方案解决网站展现项目</h3><ol>
<li><p>直接复制粘贴一份，然后根据客户不同要求，进行定制修改</p>
</li>
<li><p>给每个网站租用一个空间</p>
</li>
<li><p>方案设计示意图</p>
<img src="设计模式/QQ截图20200119203759.png" style="zoom: 60%;" />

</li>
</ol>
<h3 id="3-、传统方式存在的问题分析-1"><a href="#3-、传统方式存在的问题分析-1" class="headerlink" title="(3)、传统方式存在的问题分析"></a>(3)、传统方式存在的问题分析</h3><ol>
<li>需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当一个相同网站的实例对象很多，造成服务器的资源浪费</li>
<li>解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空等服务器资源都可以达成共享，减少服务器资源</li>
<li>对于代码来说，由于是一份实例，维护和扩展都更加容易</li>
<li>上面的解决思路就可以使用 享元模式 来解决</li>
</ol>
<h2 id="2、享元模式"><a href="#2、享元模式" class="headerlink" title="2、享元模式"></a>2、享元模式</h2><h3 id="1-、基本介绍-9"><a href="#1-、基本介绍-9" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><p><strong>享–&gt;共享，元–&gt;对象，共享对象模式</strong></p>
<ol>
<li>享元模式（Flyweight Pattern） 也叫 <strong>蝇量模式</strong>: 运用共享技术有效地支持大量细粒度的对象</li>
<li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象<br>中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</li>
<li>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对<br>象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</li>
<li>享元模式经典的应用场景就是池技术了，<strong>String 常量池</strong>、<strong>数据库连接池</strong>、<strong>缓冲池</strong>等等都是享元模式的应用，享<br>元模式是池技术的重要实现方</li>
</ol>
<p><strong>初步感知</strong></p>
<p>在Java中创建两个相同的字符串，就用到了享元模式，第2次创建会使用堆地址，指向第一次创建的内存空间，<code>s</code>和<code>s2</code>看起来的两个对象，实际上是同一个对象。</p>
<pre><code class="java">String s = <span class="string">"hello"</span>;
String s2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</code></pre>
<img src="设计模式/QQ截图20200119205600.png" style="zoom:67%;" />



<h3 id="2-、原理类图-3"><a href="#2-、原理类图-3" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="设计模式/QQ截图20200119205936.png" style="zoom:67%;" />

<p><strong>对类图的说明</strong><br>对原理图的说明-即(模式的角色及职责)</p>
<ol>
<li><code>FlyWeight</code> 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍) 的接口或实现</li>
<li><code>ConcreteFlyWeight</code> 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</li>
<li><code>UnSharedConcreteFlyWeight</code> 是不可共享的角色，一般不会出现在享元工厂。</li>
<li><code>FlyWeightFactory</code> 享元工厂类，用于构建一个池容器(集合)， 同时提供从池中获取对象方法</li>
</ol>
<h3 id="3-、内部状态和外部状态"><a href="#3-、内部状态和外部状态" class="headerlink" title="(3)、内部状态和外部状态"></a>(3)、内部状态和外部状态</h3><p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜<br>色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化<br>的，所以棋子坐标就是棋子的外部状态</p>
<ol>
<li>享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：<strong><font color=red>内部状态</font></strong>和<strong><font color=red>外部状态</font></strong></li>
<li><strong><font color=red>内部状态</font></strong>指对象共享出来的信息， 存储在享元对象内部且不会随环境的改变而改变</li>
<li><strong><font color=red>外部状态</font></strong>指对象得以依赖的一个标记，是 随环境改变而改变的、不可共享的状态。</li>
<li>举个例子：围棋理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题。</li>
</ol>
<h3 id="4-、UML类图分析-2"><a href="#4-、UML类图分析-2" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="设计模式/QQ截图20200120102447.png" style="zoom:67%;" />

<h3 id="5-、代码实现-2"><a href="#5-、代码实现-2" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p><code>User</code>类，定义为外部状态</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{

   <span class="keyword">private</span> String name;

   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>{
      <span class="keyword">this</span>.name = name;
   }

   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> name;
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{
      <span class="keyword">this</span>.name = name;
   }
}</code></pre>
<p><code>WebSite</code>定义为<code>abstract</code>抽象类，定义一个抽象方法<code>use</code>，其中使用<code>User</code>这个外部状态</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> </span>{

   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span></span>;<span class="comment">//抽象方法</span>
}</code></pre>
<p><code>ConcreteWebSite</code>继承<code>WebSite</code>，重写<code>use</code>方法，在这个类中，同时聚集了外部状态<code>user</code>和内部状态<code>type</code></p>
<pre><code class="java"><span class="comment">//具体网站</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title">WebSite</span> </span>{

   <span class="comment">//共享的部分，内部状态，网站发布的形式(类型)</span>
   <span class="keyword">private</span> String type = <span class="string">""</span>; 

   <span class="comment">//构造器</span>
   <span class="function"><span class="keyword">public</span> <span class="title">ConcreteWebSite</span><span class="params">(String type)</span> </span>{

      <span class="keyword">this</span>.type = type;
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span> </span>{
      System.out.println(<span class="string">"网站的发布形式为:"</span> + type + <span class="string">" 在使用中 .. 使用者是"</span> + user.getName());
   }
}</code></pre>
<p><code>WebSiteFactory</code>是这个享元模式的核心，使用一个HashMap定义网站池，根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回，并设计一个方法获取网站分类的总数 (池中有多少个网站类型)。</p>
<pre><code class="java"><span class="comment">// 网站工厂类，根据需要返回压一个网站</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSiteFactory</span> </span>{

   <span class="comment">//集合， 充当池的作用</span>
   <span class="keyword">private</span> HashMap&lt;String, ConcreteWebSite&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();

   <span class="comment">//根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回</span>
   <span class="function"><span class="keyword">public</span> WebSite <span class="title">getWebSiteCategory</span><span class="params">(String type)</span> </span>{
      <span class="keyword">if</span>(!pool.containsKey(type)) {
         <span class="comment">//就创建一个网站，并放入到池中</span>
         pool.put(type, <span class="keyword">new</span> ConcreteWebSite(type));
      }

      <span class="keyword">return</span> (WebSite)pool.get(type);
   }

   <span class="comment">//获取网站分类的总数 (池中有多少个网站类型)</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWebSiteCount</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> pool.size();
   }
}</code></pre>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   <span class="comment">// 创建一个工厂类</span>
   WebSiteFactory factory = <span class="keyword">new</span> WebSiteFactory();

   <span class="comment">// 客户要一个以新闻形式发布的网站</span>
   WebSite webSite1 = factory.getWebSiteCategory(<span class="string">"新闻"</span>);
   webSite1.use(<span class="keyword">new</span> User(<span class="string">"tom"</span>));

   <span class="comment">// 客户要一个以博客形式发布的网站</span>
   WebSite webSite2 = factory.getWebSiteCategory(<span class="string">"博客"</span>);
   webSite2.use(<span class="keyword">new</span> User(<span class="string">"jack"</span>));

   <span class="comment">// 客户要一个以博客形式发布的网站</span>
   WebSite webSite3 = factory.getWebSiteCategory(<span class="string">"博客"</span>);
   webSite3.use(<span class="keyword">new</span> User(<span class="string">"smith"</span>));

   <span class="comment">// 客户要一个以博客形式发布的网站</span>
   WebSite webSite4 = factory.getWebSiteCategory(<span class="string">"博客"</span>);
   webSite4.use(<span class="keyword">new</span> User(<span class="string">"king"</span>));

   System.out.println(<span class="string">"网站的分类共="</span> + factory.getWebSiteCount());
}

<span class="comment">//结果</span>
网站的发布形式为:新闻 在使用中 .. 使用者是tom
网站的发布形式为:博客 在使用中 .. 使用者是jack
网站的发布形式为:博客 在使用中 .. 使用者是smith
网站的发布形式为:博客 在使用中 .. 使用者是king
网站的分类共=<span class="number">2</span></code></pre>
<p>虽然一共看起来有4个网站示例，其实根据内部状态的不同，就创建了2个示例，外部状态变化不影响个数。</p>
<h2 id="3、享元模式在-JDK-Interger-的应用源码分析"><a href="#3、享元模式在-JDK-Interger-的应用源码分析" class="headerlink" title="3、享元模式在 JDK-Interger 的应用源码分析"></a>3、享元模式在 JDK-Interger 的应用源码分析</h2><p>在Java的<code>Integer</code>类中用到了享元模式</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   Integer x = Integer.valueOf(<span class="number">127</span>); <span class="comment">// 得到 x实例，类型 Integer</span>
   Integer y = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">// 得到 y 实例，类型 Integer</span>
   Integer z = Integer.valueOf(<span class="number">127</span>);<span class="comment">//..</span>
   Integer w = <span class="keyword">new</span> Integer(<span class="number">127</span>);

   System.out.println(x.equals(y)); <span class="comment">// 大小，true</span>
   System.out.println(x == y ); <span class="comment">//  false</span>
   System.out.println(x == z ); <span class="comment">// true</span>
   System.out.println(w == x ); <span class="comment">// false</span>
   System.out.println(w == y ); <span class="comment">// false</span>

   Integer x1 = Integer.valueOf(<span class="number">200</span>);
   Integer x2 = Integer.valueOf(<span class="number">200</span>);
   System.out.println(<span class="string">"x1==x2"</span> + (x1 == x2)); <span class="comment">// false</span>
}

<span class="comment">//结果</span>
<span class="keyword">true</span>
<span class="keyword">false</span>
<span class="keyword">true</span>
<span class="keyword">false</span>
<span class="keyword">false</span>
x1==x2false</code></pre>
<p>进入<code>Integer.valueOf</code></p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];
    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);
}</code></pre>
<p>可以看到，如果i大于等于<code>IntegerCache.low</code>且小于等于<code>IntegerCache.high</code>就直接从缓存中返回对象示例，不用new,而如果i不在这个区间里面，就new一个对象，追踪<code>IntegerCache.low</code>和<code>IntegerCache.high</code>的值</p>
<pre><code class="java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>{
    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;
    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;
    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];

    <span class="keyword">static</span> {
        <span class="comment">// high value may be configured by property</span>
        <span class="keyword">int</span> h = <span class="number">127</span>;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);
        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, <span class="number">127</span>);
                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span>
                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);
            } <span class="keyword">catch</span>( NumberFormatException nfe) {
                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span>
            }
        }
        high = h;</code></pre>
<p><code>IntegerCache</code>一开始就设定<code>low</code>=-128，在static里面定义high=h=127，[-128,127]因为较常用 而且这个正数范围是可以配置的,不是固定的,为了省内存空间，所以搞了个缓冲池。</p>
<p>所以可以解释这个为true，因为都是同一个对象实例</p>
<pre><code class="java"> Integer x = Integer.valueOf(<span class="number">127</span>); 
 Integer z = Integer.valueOf(<span class="number">127</span>); 
System.out.println(x == z ); <span class="comment">// true</span></code></pre>
<p>如果 Integer.valueOf(x) x 在  -128 — 127 直接，就是使用享元模式返回,如果不在范围类，则仍然 new<br><strong>小结:</strong><br>    1. 在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer(new), 否则，就直接从 缓存池返回<br>    2. valueOf 方法，就使用到享元模式<br>    3. 如果使用valueOf 方法得到一个Integer 实例，范围在 -128 - 127 ，执行速度比 new 快</p>
<h2 id="4、享元模式的注意事项和细节"><a href="#4、享元模式的注意事项和细节" class="headerlink" title="4、享元模式的注意事项和细节"></a>4、享元模式的注意事项和细节</h2><ol>
<li>在享元模式这样理解，“享”就表示共享，“元”表示对象</li>
<li>系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</li>
<li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable 存储</li>
<li><font color=red><strong>享元模式大大减少了对象的创建</strong></font>，降低了程序内存的占用，提高效率</li>
<li><font color=red><strong>享元模式提高了 系统的复杂度</strong></font>。需要分离出 内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.</li>
<li>使用享元模式时，注意划分<font color=red><strong>内部状态和外部状态</strong></font>，并且需要有一个工厂类加以控制。</li>
<li>享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池</li>
</ol>
<h1 id="十一、代理设计模式"><a href="#十一、代理设计模式" class="headerlink" title="十一、代理设计模式"></a>十一、代理设计模式</h1><h2 id="1、-代理模式"><a href="#1、-代理模式" class="headerlink" title="1、 代理模式"></a>1、 代理模式</h2><h3 id="1-、基本介绍-10"><a href="#1-、基本介绍-10" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。</li>
<li>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</li>
<li>代理模式有不同的形式, 主要有三种<strong><font color=red>静态代理</font></strong>、<strong><font color=red>动态代理</font></strong>(JDK代理、接口代理)和 <strong><font color=red>Cglib代理</font></strong> (可以在内存动态的创建对象，而不需要实现接口，他是属于动态代理的范畴)。</li>
</ol>
<h3 id="2-、代理模式示意图"><a href="#2-、代理模式示意图" class="headerlink" title="(2)、代理模式示意图"></a>(2)、代理模式示意图</h3><img src="设计模式/QQ截图20200120115608.png" style="zoom:67%;" />

<h2 id="2、静态代理"><a href="#2、静态代理" class="headerlink" title="2、静态代理"></a>2、静态代理</h2><h3 id="1-、基本介绍-11"><a href="#1-、基本介绍-11" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继<br>承相同父类</p>
<h3 id="2-、应用实例"><a href="#2-、应用实例" class="headerlink" title="(2)、应用实例"></a>(2)、应用实例</h3><p> <strong>具体要求</strong></p>
<ol>
<li>定义一个接口:ITeacherDao</li>
<li>目标对象 TeacherDAO 实现接口 ITeacherDAO</li>
<li>使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO</li>
<li>调用的时候通过调用代理对象的方法来调用目标对象.</li>
<li>特别提醒：代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法</li>
</ol>
<h3 id="3-、UML类图"><a href="#3-、UML类图" class="headerlink" title="(3)、UML类图"></a>(3)、UML类图</h3><img src="设计模式/QQ截图20200120122831.png" style="zoom: 67%;" />

<h3 id="4-、代码实现-3"><a href="#4-、代码实现-3" class="headerlink" title="(4)、代码实现"></a>(4)、代码实现</h3><pre><code class="java"><span class="comment">//接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>{

   <span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; <span class="comment">// 授课的方法</span>
}</code></pre>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>{

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">" 老师授课中  。。。。。"</span>);
   }
}</code></pre>
<p><code>TeacherDaoProxy</code>这里应该是通过无参构造来new出被代理对象</p>
<pre><code class="java"><span class="comment">//代理对象,静态代理</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>{

   <span class="keyword">private</span> ITeacherDao target; <span class="comment">// 目标对象，通过接口来聚合</span>

   <span class="comment">//构造器</span>
   <span class="function"><span class="keyword">public</span> <span class="title">TeacherDaoProxy</span><span class="params">()</span> </span>{
      target = <span class="keyword">new</span> TeacherDao();
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">"开始代理  完成某些操作。。。。。 "</span>);<span class="comment">//方法</span>
      target.teach();
      System.out.println(<span class="string">"提交。。。。。"</span>);<span class="comment">//方法</span>
   }
}</code></pre>
<p>调用时根本就看不见被代理对象才对，只能看见代理对象</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   <span class="comment">//通过代理对象，调用到被代理对象的方法</span>
   TeacherDaoProxy teacherDaoProxy = <span class="keyword">new</span> TeacherDaoProxy();
   <span class="comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法</span>
   teacherDaoProxy.teach();
}</code></pre>
<h3 id="5-、装饰者模式与静态代理的对比"><a href="#5-、装饰者模式与静态代理的对比" class="headerlink" title="(5)、装饰者模式与静态代理的对比"></a>(5)、装饰者模式与静态代理的对比</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol>
<li><p>装饰者类与代理类都需要实现目标类所实现的接口</p>
</li>
<li><p>装饰者类与代理类中都需要声明目标类对象，目的是这些类中都需要调用目标对象的目标方法</p>
</li>
<li><p>装饰者类与代理类都可以在不改变目标类的前提下对目标对象进行增强</p>
</li>
</ol>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol>
<li>目的不同：装饰者类的目的就是为了增强目标类；静态代理类的目的是为了保护和隐藏目标对象。</li>
<li>装饰者类与代理类中都需要声明目标类对象，但对于目标对象的创建方式不同。装饰者类是由带参构造器传入的；<strong>代理类中的目标对象，是在无参构造器中直接创建的</strong>。</li>
<li>测试类中，装饰者模式，需要先创建一个目标类对象，再将其通过带参构造器传给装饰者类；代理模式，测试类直接创建代理类对象，测试类根本就看不到业务接口的真正的实现类是谁。</li>
<li>装饰者类一般不具体增强目标类，而是由具体的装饰者子类进行的增强，并且可以形成“装饰者链”；静态代理类，则是具体的增强的实现，所有的增强功能，一般都是在静态代理类中完成的。</li>
</ol>
<h3 id="6-、-静态代理优缺点"><a href="#6-、-静态代理优缺点" class="headerlink" title="(6)、 静态代理优缺点"></a>(6)、 静态代理优缺点</h3><p> <strong>优点</strong>：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展<br> <strong>缺点：</strong>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类<br>           一旦接口增加方法,目标对象与代理对象都要维护</p>
<h2 id="3、动态代理"><a href="#3、动态代理" class="headerlink" title="3、动态代理"></a>3、动态代理</h2><h3 id="1-、基本介绍-12"><a href="#1-、基本介绍-12" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li>
<li>代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象</li>
<li>动态代理也叫做：JDK 代理、接口代理</li>
</ol>
<h3 id="2-、原理介绍"><a href="#2-、原理介绍" class="headerlink" title="(2)、原理介绍"></a>(2)、原理介绍</h3><p>动态代理的原理是使用了JDK 中生成代理对象的 API</p>
<ol>
<li>代理类所在包:java.lang.reflect.Proxy</li>
<li>JDK 实现代理只需要使用 newProxyInstance 方法,但是该方法需要接收三个参数,完整的写法是:<br>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</li>
</ol>
<h3 id="3-、应用实例"><a href="#3-、应用实例" class="headerlink" title="(3)、应用实例"></a>(3)、应用实例</h3><p>将前面的静态代理改进成动态代理模式(即：JDK 代理模式)</p>
<h3 id="4-、UML类图"><a href="#4-、UML类图" class="headerlink" title="(4)、UML类图"></a>(4)、UML类图</h3><img src="设计模式/QQ截图20200120143828.png" style="zoom:67%;" />

<p>与静态代理而言不需要代理类也实现<code>ITeacherDao</code>接口了，通过反射拿到代理对象的方法</p>
<h3 id="5-、代码实现-3"><a href="#5-、代码实现-3" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p><code>ITeacherDao</code>和<code>TeacherDao</code>和上面的静态代理一样，没啥说的，加了个<code>sayHello</code>方法为了演示参数的使用</p>
<pre><code class="java"><span class="comment">//接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>{

   <span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; <span class="comment">// 授课方法</span>
   <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;
}</code></pre>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>{
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">" 老师授课中.... "</span>);
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>{
      System.out.println(<span class="string">"hello "</span> + name);
   }
}</code></pre>
<p>这个动态代理的<code>ProxyFactory</code>有必要好好说一下，首先聚合的时候只使用了<code>Object</code>类，并不知道自己要代理哪一个类，构造函数将<code>target</code>赋值，这个<code>public Object getProxyInstance()</code>直接使用JDK的API，前两个参数分别为拿到<code>target</code>的所在类和<code>target</code>的所在接口，都是固定写法，没什么好说的。</p>
<p>第三个参数，在代理类中，对被代理类进行增强，<code>Object proxy, Method method, Object[] args</code>三个参数</p>
<p><code>Object returnVal = method.invoke(target, args);</code>说明了使用<code>method</code>装载被代理类，<code>args</code>里面是参数列表，这也是为什么上面设计一个<code>sayHello(String name)</code>方法的初衷，为了使用一下</p>
<p> <code>return returnVal;</code>这个返回会返回被调用方法的返回值，假如说</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> String <span class="title">teach</span><span class="params">()</span> </span>{
   System.out.println(<span class="string">" 老师授课中.... "</span>);
   <span class="keyword">return</span>  <span class="string">"hello,world"</span>;
}</code></pre>
<p>那么<code>returnVal</code>的值就是<code>hello,world</code></p>
<pre><code class="java"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;
<span class="keyword">import</span> java.lang.reflect.Method;
<span class="keyword">import</span> java.lang.reflect.Proxy;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>{

    <span class="comment">//维护一个目标对象 , Object</span>
    <span class="keyword">private</span> Object target;

    <span class="comment">//构造器 ， 对target 进行初始化</span>
    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>{
        <span class="keyword">this</span>.target = target;
    }

    <span class="comment">//给目标对象 生成一个代理对象</span>
    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>{
        <span class="comment">//说明</span>
      <span class="comment">/*</span>
<span class="comment">       *  public static Object newProxyInstance(ClassLoader loader,</span>
<span class="comment">                                          Class&lt;?&gt;[] interfaces,</span>
<span class="comment">                                          InvocationHandler h)</span>
<span class="comment"></span>
<span class="comment">            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span>
<span class="comment">            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span>
<span class="comment">            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span>
<span class="comment">       */</span>
        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                <span class="keyword">new</span> InvocationHandler() {
                    <span class="meta">@Override</span>
                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{
                        System.out.println(<span class="string">"JDK代理开始~~"</span>);
                        <span class="comment">//反射机制调用目标对象的方法</span>
                        Object returnVal = method.invoke(target, args);
                        System.out.println(<span class="string">"JDK代理提交"</span>);
                        <span class="keyword">return</span> returnVal;
                    }
                });
    }
}</code></pre>
<p><strong>这一部分涉及到反射的知识，有点懵逼，要去单独的学习一下。</strong></p>
<h2 id="4、Cglib-代理"><a href="#4、Cglib-代理" class="headerlink" title="4、Cglib 代理"></a>4、Cglib 代理</h2><h3 id="1-、基本介绍-13"><a href="#1-、基本介绍-13" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,<strong><font color=red>并没有实现任何的接口</font></strong>,这个时候可使用目标对象子类来实现代理-这就是 Cglib  代理</li>
<li>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。</li>
<li>Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的框架使用,例如 SpringAOP，实现方法拦截</li>
<li>在 AOP 编程中如何选择代理模式：<ul>
<li>目标对象需要实现接口，用 JDK 代理</li>
<li>目标对象不需要实现接口，用 Cglib 代理</li>
</ul>
</li>
<li>Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类</li>
</ol>
<h3 id="2-、实现步骤"><a href="#2-、实现步骤" class="headerlink" title="(2)、实现步骤"></a>(2)、实现步骤</h3><ol>
<li>需要引入 cglib 的 jar 文件</li>
<li><strong>在内存中动态构建子类，注意代理的类不能为 final</strong>，否则报错<br>java.lang.IllegalArgumentException:</li>
<li>目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.</li>
</ol>
<h3 id="3-、UML类图-1"><a href="#3-、UML类图-1" class="headerlink" title="(3)、UML类图"></a>(3)、UML类图</h3><img src="设计模式/QQ截图20200120154719.png" style="zoom:67%;" />

<h3 id="4-、代码实现-4"><a href="#4-、代码实现-4" class="headerlink" title="(4)、代码实现"></a>(4)、代码实现</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> </span>{
   <span class="function"><span class="keyword">public</span> String <span class="title">teach</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">" 老师授课中  ， 我是cglib代理，不需要实现接口 "</span>);
      <span class="keyword">return</span> <span class="string">"hello"</span>;
   }
}</code></pre>
<p><code>ProxyFactory</code>和动态代理的大致一样，其中<code>getProxyInstance()</code>方法里面的步骤现阶段先对着抄吧，都涉及到了Java底层源码，暂时没法理解不透正常，<code>intercept</code>方法和动态代理的最后一段大致一样。</p>
<pre><code class="java"><span class="keyword">import</span> java.lang.reflect.Method;
<span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;
<span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;
<span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>{
   <span class="comment">//维护一个目标对象</span>
   <span class="keyword">private</span> Object target;

   <span class="comment">//构造器，传入一个被代理的对象</span>
   <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>{
      <span class="keyword">this</span>.target = target;
   }

   <span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span>
   <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>{
      <span class="comment">//1. 创建一个工具类</span>
      Enhancer enhancer = <span class="keyword">new</span> Enhancer();
      <span class="comment">//2. 设置父类</span>
      enhancer.setSuperclass(target.getClass());
      <span class="comment">//3. 设置回调函数</span>
      enhancer.setCallback(<span class="keyword">this</span>);
      <span class="comment">//4. 创建子类对象，即代理对象</span>
      <span class="keyword">return</span> enhancer.create();
   }

   <span class="comment">//重写  intercept 方法，会调用目标对象的方法</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>{
      System.out.println(<span class="string">"Cglib代理模式 ~~ 开始"</span>);
      Object returnVal = method.invoke(target, args);
      System.out.println(<span class="string">"Cglib代理模式 ~~ 提交"</span>);
      <span class="keyword">return</span> returnVal;
   }
}</code></pre>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   <span class="comment">//创建目标对象</span>
   TeacherDao target = <span class="keyword">new</span> TeacherDao();
   <span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span>
   TeacherDao proxyInstance = (TeacherDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();
   <span class="comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span>
   String res = proxyInstance.teach();
   System.out.println(<span class="string">"res="</span> + res);
}</code></pre>
<p><strong>弹幕大神：</strong></p>
<p>简单来说 jdk代理是用实现接口的方式，cglib是通过继承的方式。</p>
<h2 id="5、代理模式几种变体形式"><a href="#5、代理模式几种变体形式" class="headerlink" title="5、代理模式几种变体形式"></a>5、代理模式几种变体形式</h2><ol>
<li>防火墙代理<br>内网通过代理穿透防火墙，实现对公网的访问。</li>
<li>缓存代理<br>比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据库取，然后缓存。</li>
<li>远程代理<br>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。<img src="设计模式/QQ截图20200120155630.png" style="zoom:67%;" /></li>
<li>同步代理<br>主要使用在多线程编程中，完成多线程间同步工作</li>
</ol>
<h1 id="十二、模板方法设计模式"><a href="#十二、模板方法设计模式" class="headerlink" title="十二、模板方法设计模式"></a>十二、模板方法设计模式</h1><h2 id="1、实际问题导出-6"><a href="#1、实际问题导出-6" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><p>豆浆制作问题<br>编写制作豆浆的程序，说明如下:</p>
<ol>
<li>制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎</li>
<li>通过添加不同的配料，可以制作出不同口味的豆浆</li>
<li>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的</li>
<li>请使用 模板方法模式 完成 (说明：因为模板方法模式，比较简单，很容易就想到这个方案，因此就直接使用，不再使用传统的方案来引出模板方法模式 )</li>
</ol>
<h2 id="2、-模板方法模式"><a href="#2、-模板方法模式" class="headerlink" title="2、 模板方法模式"></a>2、 模板方法模式</h2><h3 id="1-、基本介绍-14"><a href="#1-、基本介绍-14" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</li>
<li>简单说，模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</li>
<li>这种类型的设计模式属于行为型模式。</li>
</ol>
<h3 id="2-、原理类图-4"><a href="#2-、原理类图-4" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="设计模式/QQ截图20200120165052.png" style="zoom:67%;" />

<p>对原理类图的说明-即(模板方法模式的角色及职责)</p>
<p>1) AbstractClass 抽象类， 类中实现了模板方法(template)，定义了算法的骨架，具体子类需要去实现 其它的抽象<br>方法 operationr2,3,4<br>2) ConcreteClass 实现抽象方法 operationr2,3,4, 以完成算法中特点子类的步骤</p>
<h3 id="3-、应用实例要求"><a href="#3-、应用实例要求" class="headerlink" title="(3)、应用实例要求"></a>(3)、应用实例要求</h3><p>编写制作豆浆的程序，说明如下:<br>制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎<br>通过添加不同的配料，可以制作出不同口味的豆浆<br>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的(红豆、花生豆浆。。。)</p>
<h3 id="4-、UML类图分析-3"><a href="#4-、UML类图分析-3" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="设计模式/QQ截图20200120173715.png" style="zoom:67%;" />

<h3 id="5-、代码实现-4"><a href="#5-、代码实现-4" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p><code>SoyaMilk</code>写一个抽象方法<code>addCondiments()</code>让子类去实现具体的配料添加，<code>make()</code>方法写成final , 不让子类去覆盖.</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SoyaMilk</span> </span>{
   <span class="comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span>
   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>{
      select();
      addCondiments();
      soak();
      beat();

   }

   <span class="comment">//选材料</span>
   <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">"第一步：选择好的新鲜黄豆  "</span>);
   }

   <span class="comment">//添加不同的配料， 抽象方法, 子类具体实现</span>
   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;

   <span class="comment">//浸泡</span>
   <span class="function"><span class="keyword">void</span> <span class="title">soak</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">"第三步， 黄豆和配料开始浸泡， 需要3小时 "</span>);
   }

   <span class="function"><span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">"第四步：黄豆和配料放到豆浆机去打碎  "</span>);
   }
}</code></pre>
<p><code>PeanutSoyaMilk</code>和<code>RedBeanSoyaMilk</code>一样，继承<code>SoyaMilk</code>,具体实现<code>addCondiments()</code></p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeanutSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>{

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">" 加入上好的花生 "</span>);
   }
}</code></pre>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>{

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">" 加入上好的红豆 "</span>);
   }
}</code></pre>
<p>使用多态，直接调用就完了</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   <span class="comment">//制作红豆豆浆</span>
   System.out.println(<span class="string">"----制作红豆豆浆----"</span>);
   SoyaMilk redBeanSoyaMilk = <span class="keyword">new</span> RedBeanSoyaMilk();
   redBeanSoyaMilk.make();

   System.out.println(<span class="string">"----制作花生豆浆----"</span>);
   SoyaMilk peanutSoyaMilk = <span class="keyword">new</span> PeanutSoyaMilk();
   peanutSoyaMilk.make();
}</code></pre>
<h2 id="3、-模板方法模式的钩子方法"><a href="#3、-模板方法模式的钩子方法" class="headerlink" title="3、 模板方法模式的钩子方法"></a>3、 模板方法模式的钩子方法</h2><h3 id="1-、内容介绍"><a href="#1-、内容介绍" class="headerlink" title="(1)、内容介绍"></a>(1)、内容介绍</h3><ol>
<li>在模板方法模式的父类中，我们可以定义一个方法，它 默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。</li>
<li>还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，请使用钩子方法对前面的模板方法进行改造</li>
</ol>
<h3 id="2-、代码实现-4"><a href="#2-、代码实现-4" class="headerlink" title="(2)、代码实现"></a>(2)、代码实现</h3><p>在<code>SoyaMilk</code>中增加一个新方法<code>customerWantCondiments</code>，默认返回<code>true</code></p>
<pre><code class="java"><span class="comment">//钩子方法，决定是否需要添加配料</span>
<span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>{
   <span class="keyword">return</span> <span class="keyword">true</span>;
}</code></pre>
<p><code>PureSoyaMilk</code>纯豆浆类</p>
<pre><code>public class PureSoyaMilk extends SoyaMilk{

   @Override
   void addCondiments() {
      //空实现
   }

   @Override
   boolean customerWantCondiments() {
      return false;
   }
}</code></pre><h2 id="4、模板方法模式在-Spring-框架应用的源码分析"><a href="#4、模板方法模式在-Spring-框架应用的源码分析" class="headerlink" title="4、模板方法模式在 Spring 框架应用的源码分析"></a>4、模板方法模式在 Spring 框架应用的源码分析</h2><p>Spring IOC 容器初始化时运用到的模板方法模式</p>
<p>进入<code>ConfigurableApplicationContext</code>，这是一个接口，其中有一个<code>refresh</code>方法，查看他的实现类<code>AbstractApplicationContext</code></p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span>, <span class="title">Lifecycle</span>, <span class="title">Closeable</span> </span>{
    <span class="comment">//声明了一个模板方法</span>
    <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</code></pre>
<p><code>AbstractApplicationContext</code>是一个抽象类，重写了<code>refresh</code>方法，在<code>refresh</code>方法中，调用了很多方法，其中包括钩子方法，其中<code>obtainFreshBeanFactory()</code>里面的<code>refreshBeanFactory()</code>方法就是一个只有空实现的钩子方法。</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span>
<span class="class">      <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>{

    <span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>{
        refreshBeanFactory();
        ConfigurableListableBeanFactory beanFactory = getBeanFactory();
        <span class="keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);
        }
        <span class="keyword">return</span> beanFactory;
    }

    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>{
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) {
            <span class="comment">// Prepare this context for refreshing.</span>
            prepareRefresh();

            <span class="comment">// Tell the subclass to refresh the internal bean factory.</span>
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            <span class="comment">// Prepare the bean factory for use in this context.</span>
            prepareBeanFactory(beanFactory);

            <span class="keyword">try</span> {
                <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span>
                postProcessBeanFactory(beanFactory);

                <span class="comment">// Invoke factory processors registered as beans in the context.</span>
                invokeBeanFactoryPostProcessors(beanFactory);

                <span class="comment">// Register bean processors that intercept bean creation.</span>
                registerBeanPostProcessors(beanFactory);

                <span class="comment">// Initialize message source for this context.</span>
                initMessageSource();

                <span class="comment">// Initialize event multicaster for this context.</span>
                initApplicationEventMulticaster();

                <span class="comment">// Initialize other special beans in specific context subclasses.</span>
                onRefresh();

                <span class="comment">// Check for listener beans and register them.</span>
                registerListeners();

                <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span>
                finishBeanFactoryInitialization(beanFactory);

                <span class="comment">// Last step: publish corresponding event.</span>
                finishRefresh();
            }

            <span class="keyword">catch</span> (BeansException ex) {
                <span class="comment">// Destroy already created singletons to avoid dangling resources.</span>
                destroyBeans();

                <span class="comment">// Reset 'active' flag.</span>
                cancelRefresh(ex);

                <span class="comment">// Propagate exception to caller.</span>
                <span class="keyword">throw</span> ex;
            }
        }
    }</code></pre>
<p><strong>说明类图</strong></p>
<img src="设计模式/QQ截图20200120193346.png" style="zoom:67%;" />

<h2 id="5、模板方法模式的注意事项和细节"><a href="#5、模板方法模式的注意事项和细节" class="headerlink" title="5、模板方法模式的注意事项和细节"></a>5、模板方法模式的注意事项和细节</h2><ol>
<li>基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改。</li>
<li>实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。</li>
<li>既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。</li>
<li>该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大。</li>
<li>一般模板方法都加上 final 关键字， 防止子类重写模板方法。</li>
<li>模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理。</li>
</ol>
<p><strong>弹幕大神</strong></p>
<p>建造者是用于构建对象的</p>
<p>建造者模式是有指挥者director和builderde</p>
<p>建造者目的是获取复杂对象，忽略创建对象时内部复杂的步骤</p>
<p>此类线程和父类线程会出现多线程竞争资源，多运行几次，顺序会出错，</p>
<h1 id="十三、命令设计模式"><a href="#十三、命令设计模式" class="headerlink" title="十三、命令设计模式"></a>十三、命令设计模式</h1><h2 id="1、实际问题导出-7"><a href="#1、实际问题导出-7" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><p>智能生活项目需求<br>看一个具体的需求</p>
<img src="设计模式/QQ截图20200120204446.png" style="zoom:67%;" />

<ol>
<li>我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装 app 就可以控制对这些家电工作。</li>
<li>这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个 App，分别控制，我们希望只要一个app<br>就可以控制全部智能家电。</li>
<li>要实现一个 app 控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口给 app 调用，这时就可以考虑使用命令模式。</li>
<li>命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来.</li>
<li>在我们的例子中，动作的请求者是手机 app，动作的执行者是每个厂商的一个家电产品</li>
</ol>
<p><strong>感觉和外观模式很像。。。</strong></p>
<h2 id="2、命令模式"><a href="#2、命令模式" class="headerlink" title="2、命令模式"></a><strong>2、命令模式</strong></h2><h3 id="1-、基本介绍-15"><a href="#1-、基本介绍-15" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计</li>
<li>命名模式使得 请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。</li>
<li>在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。</li>
<li>通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将军和士兵)。将军只需要发出一条攻击命令，甚至都不用知道士兵具体是谁，只要发出了命令，就有响应者接收命令做出反应。<br>Invoker 是调用者（将军），Receiver 是被调用者（士兵），MyCommand 是命令，实现了 Command 接口，持有接收对象</li>
</ol>
<h3 id="2-、原理类图-5"><a href="#2-、原理类图-5" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="设计模式/QQ截图20200120205232.png" style="zoom:67%;" />



<p>对原理类图的说明-即(命名模式的角色及职责)</p>
<ol>
<li><code>Invoker</code> 是调用者角色</li>
<li><code>Command</code>: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类</li>
<li><code>Receiver</code>: 接受者角色，知道如何实施和执行一个请求相关的操作</li>
<li><code>ConcreteCommand</code>: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现 execute</li>
</ol>
<h3 id="3-、应用实例要求-1"><a href="#3-、应用实例要求-1" class="headerlink" title="(3)、应用实例要求"></a>(3)、应用实例要求</h3><p>编写程序，使用命令模式 完成前面的智能家电项目</p>
<h3 id="4-、UML类图分析-4"><a href="#4-、UML类图分析-4" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="设计模式/QQ截图20200120212934.png" style="zoom:67%;" />

<h3 id="5-、代码实现-5"><a href="#5-、代码实现-5" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p>这个命令模式设计的妙啊，值得好好的说一番。</p>
<p>首先实现对于电灯开关的操作</p>
<p>首先定义<code>Command</code>接口，定义两个方法<code>execute()</code>和<code>undo()</code></p>
<pre><code class="java"><span class="comment">//创建命令接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>{
   <span class="comment">//执行动作(操作)</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;
   <span class="comment">//撤销动作(操作)</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;
}</code></pre>
<p>写一个<code>LightReceiver</code>类，也就是电灯的实体类，具体来实现电灯的开关操作。</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightReceiver</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">" 电灯打开了.. "</span>);
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">" 电灯关闭了.. "</span>);
   }
}</code></pre>
<p><code>LightOnCommand</code>聚合<code>LightReceiver</code>在构造函数里面传进来一个<code>LightReceiver</code>实体类，<code>execute()</code>执行电灯开，<code>undo()</code>执行电灯关，(execute是执行的意思，undo是撤销的意思，在<code>LightOnCommand</code>里面，撤销自然就是电灯关了)</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>{
    <span class="comment">//聚合LightReceiver</span>
    LightReceiver light;

    <span class="comment">//构造器</span>
    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(LightReceiver light)</span> </span>{
        <span class="keyword">this</span>.light = light;
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{
        <span class="comment">//调用接收者的方法</span>
        light.on();
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>{
        <span class="comment">//调用接收者的方法</span>
        light.off();
    }
}</code></pre>
<p>和上面一样，<code>LightOffCommand</code>聚合<code>LightReceiver</code>在构造函数里面传进来一个<code>LightReceiver</code>实体类，<code>execute()</code>执行电灯关，<code>undo()</code>执行电灯开，(execute是执行的意思，undo是撤销的意思，在<code>LightOffCommand</code>里面，撤销自然就是电灯开了)</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>{
   <span class="comment">// 聚合LightReceiver</span>
   LightReceiver light;

   <span class="comment">// 构造器</span>
   <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(LightReceiver light)</span> </span>{
      <span class="keyword">this</span>.light = light;
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{
      <span class="comment">// 调用接收者的方法</span>
      light.off();
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>{
      <span class="comment">// 调用接收者的方法</span>
      light.on();
   }
}</code></pre>
<p>设计一个<code>NoCommand</code>空命令类，什么也不干，便于初始化。</p>
<pre><code class="java"><span class="comment">//没有任何命令，即空执行: 用于初始化每个按钮, 当调用空命令时，对象什么都不做</span>
<span class="comment">//其实，这样是一种设计模式, 可以省掉对空判断</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>{
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>{
   }
}</code></pre>
<h4 id="1-、心得1"><a href="#1-、心得1" class="headerlink" title="1)、心得1"></a>1)、心得1</h4><p>到这里为止，看起来是把一个电灯类就能搞定的开关操作活生生分出去了4个类，特别是还多了一个莫名其妙的<code>NoCommand</code>，看起来增加了麻烦，其实不然，到后面才能体会到真正设计模式的巧妙之处。这个<code>NoCommand</code>空命令类设计的确是牛逼，避免一些对空的判断和在遥控器初始化时使用。</p>
<p>现实中的遥控器</p>
<img src="设计模式/QQ截图20200120215522.png" style="zoom:50%;" />



<p>继续撸代码</p>
<p><code>RemoteController</code>这个控制器类(遥控器)写的确是好，定义一个撤销按钮和两个数组，分别是开按钮数组和关按钮数组，初始化时全部指向<code>NoCommand</code>空命令类，也符合现实中遥控器的实际，不开不关就是啥也不干。在按下开或关按钮时，使用对应数组元素的方法并存到撤销按钮里面，在按下撤销按钮时，进行撤销操作。</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteController</span> </span>{
   <span class="comment">// 开 按钮的命令数组</span>
   Command[] onCommands;
   Command[] offCommands;

   <span class="comment">// 执行撤销的命令</span>
   Command undoCommand;

   <span class="comment">// 构造器，完成对按钮初始化</span>
   <span class="function"><span class="keyword">public</span> <span class="title">RemoteController</span><span class="params">()</span> </span>{
      onCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];
      offCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {
         onCommands[i] = <span class="keyword">new</span> NoCommand();
         offCommands[i] = <span class="keyword">new</span> NoCommand();
      }
   }

   <span class="comment">// 给我们的按钮设置你需要的命令</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> no, Command onCommand, Command offCommand)</span> </span>{
      onCommands[no] = onCommand;
      offCommands[no] = offCommand;
   }

   <span class="comment">// 按下开按钮</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span> </span>{ 
      <span class="comment">// 找到你按下的开的按钮， 并调用对应方法</span>
      onCommands[no].execute();
      <span class="comment">// 记录这次的操作，用于撤销</span>
      undoCommand = onCommands[no];
   }

   <span class="comment">// 按下关按钮</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span> </span>{ 
      <span class="comment">// 找到你按下的关的按钮， 并调用对应方法</span>
      offCommands[no].execute();
      <span class="comment">// 记录这次的操作，用于撤销</span>
      undoCommand = offCommands[no];
   }

   <span class="comment">// 按下撤销按钮</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoButtonWasPushed</span><span class="params">()</span> </span>{
      undoCommand.undo();
   }
}</code></pre>
<p>main调用时，依次创建对象，<code>new LightOnCommand(lightReceiver);</code>这里就将电灯开按钮和电灯实体类进行了绑定，关按钮同理。<code>remoteController.setCommand(0, lightOnCommand, lightOffCommand);</code>设置数组第0位为电视机的相关操作。</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   <span class="comment">//使用命令设计模式，完成通过遥控器，对电灯的操作</span>
   <span class="comment">//创建电灯的对象(接受者)</span>
   LightReceiver lightReceiver = <span class="keyword">new</span> LightReceiver();

   <span class="comment">//创建电灯相关的开关命令</span>
   LightOnCommand lightOnCommand = <span class="keyword">new</span> LightOnCommand(lightReceiver);
   LightOffCommand lightOffCommand = <span class="keyword">new</span> LightOffCommand(lightReceiver);

   <span class="comment">//需要一个遥控器</span>
   RemoteController remoteController = <span class="keyword">new</span> RemoteController();

   <span class="comment">//给我们的遥控器设置命令, 比如 no = 0 是电灯的开和关的操作</span>
   remoteController.setCommand(<span class="number">0</span>, lightOnCommand, lightOffCommand);

   System.out.println(<span class="string">"--------按下灯的开按钮-----------"</span>);
   remoteController.onButtonWasPushed(<span class="number">0</span>);
   System.out.println(<span class="string">"--------按下灯的关按钮-----------"</span>);
   remoteController.offButtonWasPushed(<span class="number">0</span>);
   System.out.println(<span class="string">"--------按下撤销按钮-----------"</span>);
   remoteController.undoButtonWasPushed();
}</code></pre>
<h4 id="2-、心得2"><a href="#2-、心得2" class="headerlink" title="2)、心得2"></a>2)、心得2</h4><p>这个设计模式遵循OCP原则，加一个电视机的控制</p>
<p>首先是<code>TVReceiver</code>实体类</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TVReceiver</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>{
        System.out.println(<span class="string">" 电视机打开了.. "</span>);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>{
        System.out.println(<span class="string">" 电视机关闭了.. "</span>);
    }
}</code></pre>
<p><code>TVOnCommand</code></p>
<pre><code>public class TVOnCommand implements Command {
   // 聚合TVReceiver
   TVReceiver tv;

   // 构造器
   public TVOnCommand(TVReceiver tv) {
      this.tv = tv;
   }

   @Override
   public void execute() {
      // 调用接收者的方法
      tv.on();
   }

   @Override
   public void undo() {
      // 调用接收者的方法
      tv.off();
   }
}</code></pre><p><code>TVOffCommand</code></p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TVOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>{

   <span class="comment">// 聚合TVReceiver</span>
   TVReceiver tv;

   <span class="comment">// 构造器</span>
   <span class="function"><span class="keyword">public</span> <span class="title">TVOffCommand</span><span class="params">(TVReceiver tv)</span> </span>{
      <span class="keyword">this</span>.tv = tv;
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{
      <span class="comment">// 调用接收者的方法</span>
      tv.off();
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>{
      <span class="comment">// 调用接收者的方法</span>
      tv.on();
   }
}</code></pre>
<p>写完这三个类就可以直接使用了，设置一下遥控器1号位控制电视机的相关操作就可以了</p>
<pre><code class="java">System.out.println(<span class="string">"=========使用遥控器操作电视机=========="</span>);

TVReceiver tvReceiver = <span class="keyword">new</span> TVReceiver();
TVOffCommand tvOffCommand = <span class="keyword">new</span> TVOffCommand(tvReceiver);
TVOnCommand tvOnCommand = <span class="keyword">new</span> TVOnCommand(tvReceiver);

<span class="comment">//给我们的遥控器设置命令, 比如 no = 1 是电视机的开和关的操作</span>
remoteController.setCommand(<span class="number">1</span>, tvOnCommand, tvOffCommand);

System.out.println(<span class="string">"--------按下电视机的开按钮-----------"</span>);
remoteController.onButtonWasPushed(<span class="number">1</span>);
System.out.println(<span class="string">"--------按下电视机的关按钮-----------"</span>);
remoteController.offButtonWasPushed(<span class="number">1</span>);
System.out.println(<span class="string">"--------按下撤销按钮-----------"</span>);
remoteController.undoButtonWasPushed();</code></pre>
<p>这个设计模式确实牛逼，将命令的执行者和命令发出者进行了解耦，在命令发出之前，双方都是透明的，谁都不知道谁。</p>
<h2 id="3、命令模式在-Spring-框架-JdbcTemplate-应用的源码分析"><a href="#3、命令模式在-Spring-框架-JdbcTemplate-应用的源码分析" class="headerlink" title="3、命令模式在 Spring 框架 JdbcTemplate 应用的源码分析"></a>3、命令模式在 Spring 框架 JdbcTemplate 应用的源码分析</h2><p>Spring 框架的<code>JdbcTemplate</code>使用到了命令模式</p>
<p>在<code>JdbcTemplate</code>了类中的<code>query</code>方法里面有一个匿名内部类<code>QueryStatementCallback</code>，追踪<code>StatementCallback&lt;T&gt;</code>接口</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplate</span> <span class="keyword">extends</span> <span class="title">JdbcAccessor</span> <span class="keyword">implements</span> <span class="title">JdbcOperations</span> </span>{

<span class="meta">@Override</span>
<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class="keyword">throws</span> DataAccessException </span>{
   Assert.notNull(sql, <span class="string">"SQL must not be null"</span>);
   Assert.notNull(rse, <span class="string">"ResultSetExtractor must not be null"</span>);
   <span class="keyword">if</span> (logger.isDebugEnabled()) {
      logger.debug(<span class="string">"Executing SQL query ["</span> + sql + <span class="string">"]"</span>);
   }
   <span class="class"><span class="keyword">class</span> <span class="title">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title">StatementCallback</span>&lt;<span class="title">T</span>&gt;, <span class="title">SqlProvider</span> </span>{
      <span class="meta">@Override</span>
      <span class="function"><span class="keyword">public</span> T <span class="title">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>{
         ResultSet rs = <span class="keyword">null</span>;
         <span class="keyword">try</span> {
            rs = stmt.executeQuery(sql);
            ResultSet rsToUse = rs;
            <span class="keyword">if</span> (nativeJdbcExtractor != <span class="keyword">null</span>) {
               rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);
            }
            <span class="keyword">return</span> rse.extractData(rsToUse);
         }
         <span class="keyword">finally</span> {
            JdbcUtils.closeResultSet(rs);
         }
      }
      <span class="meta">@Override</span>
      <span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span>{
         <span class="keyword">return</span> sql;
      }
   }
   <span class="keyword">return</span> execute(<span class="keyword">new</span> QueryStatementCallback());
}</code></pre>
<p><code>StatementCallback&lt;T&gt;</code>接口就一个方法<code>T doInStatement(Statement stmt)</code></p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementCallback</span>&lt;<span class="title">T</span>&gt; </span>{
   <span class="function">T <span class="title">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException, DataAccessException</span>;
}</code></pre>
<p><strong>分析：</strong></p>
<ol>
<li>StatementCallback 接口 ,类似命令接口(Command)</li>
<li>class QueryStatementCallback implements StatementCallback<T>, SqlProvider , 匿名内部类， 实现了命令接口，同时也充当命令接收者.</li>
<li>命令调用者 是 JdbcTemplate , 其中 execute(StatementCallback<T> action) 方法中，调用action.doInStatement 方法. 不同的 实现 StatementCallback 接口的对象，对应不同的doInStatemnt 实现逻辑</li>
<li>另外实现 StatementCallback 命令接口的子类还有多个，例如QueryStatementCallback等</li>
</ol>
<p>这个源码分析举得例子有点牵强，没看懂，后期仔细领悟吧，不过上面的代码实现是看懂了的。</p>
<h2 id="4、-命令模式的注意事项和细节"><a href="#4、-命令模式的注意事项和细节" class="headerlink" title="4、 命令模式的注意事项和细节"></a>4、 命令模式的注意事项和细节</h2><ol>
<li>将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的 execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。</li>
<li>容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令</li>
<li>容易实现对请求的撤销和重做</li>
<li>命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意</li>
<li>空命令也是一种设计模式，它为我们 省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。</li>
<li>命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟 CMD（DOS 命令）订单的撤销/恢复、触发-反馈机制</li>
</ol>
<h1 id="十四、访问者设计模式"><a href="#十四、访问者设计模式" class="headerlink" title="十四、访问者设计模式"></a>十四、访问者设计模式</h1><h2 id="1、实际问题导出-8"><a href="#1、实际问题导出-8" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、完成测评系统需求"><a href="#1-、完成测评系统需求" class="headerlink" title="(1)、完成测评系统需求"></a>(1)、完成测评系统需求</h3><p>将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(评价 有不<br>同的种类，比如 成功、失败 等)</p>
<h3 id="2-、传统方案"><a href="#2-、传统方案" class="headerlink" title="(2)、传统方案"></a>(2)、传统方案</h3><img src="设计模式/QQ截图20200121101814.png" style="zoom:67%;" />

<h3 id="3-、传统方式的问题分析"><a href="#3-、传统方式的问题分析" class="headerlink" title="(3)、传统方式的问题分析"></a>(3)、传统方式的问题分析</h3><ol>
<li>如果系统比较小，还是ok的，但是考虑系统增加越来越多新的功能时，对代码改动较大，违反了ocp原则， 不利于维护</li>
<li>扩展性不好，比如 增加了 新的人员类型，或者管理方法，都不好做</li>
<li>引出我们会使用新的设计模式 – 访问者模式</li>
</ol>
<h2 id="2、-访问者模式"><a href="#2、-访问者模式" class="headerlink" title="2、 访问者模式"></a>2、 访问者模式</h2><h3 id="1-、基本介绍-16"><a href="#1-、基本介绍-16" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</li>
<li>主要将数据结构与数据操作分离，解决 数据结构和操作耦合性问题</li>
<li>访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口</li>
<li>访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作”污染”这些对象的类，可以选用访问者模式解决</li>
</ol>
<h3 id="2-、原理类图-6"><a href="#2-、原理类图-6" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="设计模式/QQ截图20200211101910.png" style="zoom:50%;" />

<p><strong>对原理类图的说明</strong>-即(访问者模式的角色及职责)</p>
<ol>
<li>Visitor 是抽象访问者，为该对象结构中的 ConcreteElement 的每一个类声明一个visit 操作</li>
<li>ConcreteVisitor ：是一个具体的访问值 实现每个有 Visitor 声明的操作，是每个操作实现的部分.</li>
<li>ObjectStructure 能枚举它的元素， 可以提供一个高层的接口，用来允许访问者访问元素</li>
<li>Element 定义一个 accept 方法，接收一个访问者对象</li>
<li>ConcreteElement 为具体元素，实现了 accept 方法</li>
</ol>
<h3 id="3-、应用实例要求-2"><a href="#3-、应用实例要求-2" class="headerlink" title="(3)、应用实例要求"></a>(3)、应用实例要求</h3><p>将人分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(评价 有不同<br>的种类，比如 成功、失败 等)，请使用访问者模式来说实现</p>
<h3 id="4-、UML类图分析-5"><a href="#4-、UML类图分析-5" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="设计模式/QQ截图20200211103638.png" style="zoom:67%;" />

<h3 id="5-、代码实现-6"><a href="#5-、代码实现-6" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p>先创建Person抽象类，提供一个对外访问的接口</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{
    <span class="comment">//提供一个方法，让访问者可以访问</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span></span>;
}</code></pre>
<p>然后Man和Woman类进行实现</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span> </span>{
        action.getManResult(<span class="keyword">this</span>);
    }
}</code></pre>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span> </span>{
        action.getWomanResult(<span class="keyword">this</span>);
    }
}</code></pre>
<p>写一个抽象类Action，就是访问者</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>{

    <span class="comment">//得到男性 的测评</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span></span>;

    <span class="comment">//得到女的 测评</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span></span>;
}</code></pre>
<p>两种状态Success和Fail</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Success</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span> </span>{
        System.out.println(<span class="string">" 男人给的评价该歌手成功 !"</span>);
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span> </span>{
        System.out.println(<span class="string">" 女人给的评价该歌手成功 !"</span>);
    }
}</code></pre>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fail</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span> </span>{
        System.out.println(<span class="string">" 男人给的评价该歌手失败 !"</span>);
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span> </span>{
        System.out.println(<span class="string">" 女人给的评价该歌手失败 !"</span>);
    }
}</code></pre>
<p>ObjectStructure链表，管理着很多人</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>{

    <span class="comment">//维护了一个集合</span>
    <span class="keyword">private</span> List&lt;Person&gt; persons = <span class="keyword">new</span> LinkedList&lt;&gt;();

    <span class="comment">//增加到list</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Person p)</span> </span>{
        persons.add(p);
    }
    <span class="comment">//移除</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Person p)</span> </span>{
        persons.remove(p);
    }

    <span class="comment">//显示测评情况</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Action action)</span> </span>{
        <span class="keyword">for</span>(Person p: persons) {
            p.accept(action);
        }
    }
}</code></pre>
<p>Client调用</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   <span class="comment">//创建ObjectStructure</span>
   ObjectStructure objectStructure = <span class="keyword">new</span> ObjectStructure();

   objectStructure.attach(<span class="keyword">new</span> Man());
   objectStructure.attach(<span class="keyword">new</span> Woman());

   <span class="comment">//成功</span>
   Success success = <span class="keyword">new</span> Success();
   objectStructure.display(success);

   System.out.println(<span class="string">"==============="</span>);
   Fail fail = <span class="keyword">new</span> Fail();
   objectStructure.display(fail);
}

<span class="comment">//结果</span>
 男人给的评价该歌手成功 !
 女人给的评价该歌手成功 !
===============
 男人给的评价该歌手失败 !
 女人给的评价该歌手失败 !</code></pre>
<p>这个设计模式的好处，如果加了一个状态比如说待定，只要继承Action接口即可</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">extends</span> <span class="title">Action</span></span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span> </span>{
        System.out.println(<span class="string">" 男人给的评价是该歌手待定 .."</span>);
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span> </span>{
        System.out.println(<span class="string">" 女人给的评价是该歌手待定 .."</span>);
    }
}</code></pre>
<pre><code class="java">System.out.println(<span class="string">"=======给的是待定的测评========"</span>);

Wait wait = <span class="keyword">new</span> Wait();
objectStructure.display(wait);

<span class="comment">//结果</span>
=======给的是待定的测评========
 男人给的评价是该歌手待定 ..
 女人给的评价是该歌手待定 ..</code></pre>
<h2 id="3、访问者模式的注意事项和细节"><a href="#3、访问者模式的注意事项和细节" class="headerlink" title="3、访问者模式的注意事项和细节"></a>3、访问者模式的注意事项和细节</h2><p><strong>这里使用了双分派</strong><br>说明</p>
<ol>
<li>这里我们使用到了双分派, 即首先在客户端程序中，将具体状态作为参数传递Woman中(第一次分派)</li>
<li>然后Woman 类调用作为参数的 “具体方法” 中方法getWomanResult, 同时将自己(this)作为参数传入，完成第二次的分派</li>
</ol>
<p><strong>优点</strong></p>
<ol>
<li>访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高</li>
<li>访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的, 这样造成了具体元素变更比较困难</li>
<li>违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素</li>
<li>因此， 如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么 访问者模式就是比较合适的.</li>
</ol>
<h1 id="十五、迭代器设计模式"><a href="#十五、迭代器设计模式" class="headerlink" title="十五、迭代器设计模式"></a>十五、迭代器设计模式</h1><h2 id="1、实际问题导出-9"><a href="#1、实际问题导出-9" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，<br>一个学院有多个系。(这个要求和 八、组合设计模式 里面提出的要求是一样的)如图：</p>
<img src="设计模式/QQ截图20200222205545.png" style="zoom:80%;" />

<h2 id="2、迭代器模式"><a href="#2、迭代器模式" class="headerlink" title="2、迭代器模式"></a>2、迭代器模式</h2><h3 id="1-、基本介绍-17"><a href="#1-、基本介绍-17" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>迭代器模式（Iterator Pattern）是 常用的设计模式，属于行为型模式</li>
<li>如果我们的集合元素是用不同的方式实现的，<font color="red">有数组，有链表，还有 java 的集合类，或者还有其他方式</font>，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。</li>
<li>迭代器模式， 提供一种遍历集合元素的统一接口，用 一致的方法遍历集合元素，不需要知道 集合对象的底层表示，即：不暴露其内部的结构。</li>
</ol>
<p>多种存储方式，一套代码解决 –&gt; 迭代器模式</p>
<h3 id="2-、原理类图-7"><a href="#2-、原理类图-7" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="设计模式/QQ截图20200222210312.png" style="zoom: 50%;" />

<p>对原理类图的说明-即(迭代器模式的角色及职责)</p>
<ol>
<li>Iterator ： 迭代器接口，是系统提供，含义 hasNext, next, remove</li>
<li>ConcreteIterator : 具体的迭代器类，管理迭代</li>
<li>Aggregate :一个统一的聚合接口， 将客户端和具体聚合解耦</li>
<li>ConcreteAggreage : 具体的聚合持有对象集合， 并提供一个方法，返回一个迭代器， 该迭代器可以正确遍历集合</li>
<li>Client :客户端， 通过 Iterator 和 Aggregate 依赖子类</li>
</ol>
<h3 id="3-、应用实例要求-3"><a href="#3-、应用实例要求-3" class="headerlink" title="(3)、应用实例要求"></a>(3)、应用实例要求</h3><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，<br>一个学院有多个系。</p>
<h3 id="4-、UML类图分析-6"><a href="#4-、UML类图分析-6" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="设计模式/QQ截图20200222211204.png" style="zoom:80%;" />

<h3 id="5-、代码实现-7"><a href="#5-、代码实现-7" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p>这个设计模式没啥用，跳过</p>
<h1 id="十六、观察者设计模式"><a href="#十六、观察者设计模式" class="headerlink" title="十六、观察者设计模式"></a>十六、观察者设计模式</h1><h2 id="1、实际问题导出-10"><a href="#1、实际问题导出-10" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、天气预报项目需求"><a href="#1-、天气预报项目需求" class="headerlink" title="(1)、天气预报项目需求"></a>(1)、天气预报项目需求</h3><ol>
<li>气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。</li>
<li>需要 设计开放型 API，便于 其他第三方也能接入气象站获取数据。</li>
<li>提供温度、气压和湿度的接口</li>
<li>测量数据更新时，要能实时的通知给第三方</li>
</ol>
<h3 id="2-、传统方案-1"><a href="#2-、传统方案-1" class="headerlink" title="(2)、传统方案"></a>(2)、传统方案</h3><p>让气象台有信息变化的时候就使用update方法，推送给用户,</p>
<p>代码实现以下，看一下缺点</p>
<p>先写一个订阅用户，其中的update方法是由气象台来调用的</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditions</span> </span>{
   <span class="comment">// 温度，气压，湿度</span>
   <span class="keyword">private</span> <span class="keyword">float</span> temperature;
   <span class="keyword">private</span> <span class="keyword">float</span> pressure;
   <span class="keyword">private</span> <span class="keyword">float</span> humidity;

   <span class="comment">//使用推送模式更新 天气情况，是由 WeatherData 来调用，</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>{
      <span class="keyword">this</span>.temperature = temperature;
      <span class="keyword">this</span>.pressure = pressure;
      <span class="keyword">this</span>.humidity = humidity;
      display();
   }

   <span class="comment">//显示</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">"***Today mTemperature: "</span> + temperature + <span class="string">"***"</span>);
      System.out.println(<span class="string">"***Today mPressure: "</span> + pressure + <span class="string">"***"</span>);
      System.out.println(<span class="string">"***Today mHumidity: "</span> + humidity + <span class="string">"***"</span>);
   }
}</code></pre>
<p>然后是气象台的数据改变时，调用setdata方法，然后订阅订阅者的update，这样聚集了大量的不同订阅者对象在类中</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> </span>{
   <span class="keyword">private</span> <span class="keyword">float</span> temperatrue;
   <span class="keyword">private</span> <span class="keyword">float</span> pressure;
   <span class="keyword">private</span> <span class="keyword">float</span> humidity;
   <span class="keyword">private</span> CurrentConditions currentConditions;
   <span class="comment">//加入新的第三方</span>

   <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">(CurrentConditions currentConditions)</span> </span>{
      <span class="keyword">this</span>.currentConditions = currentConditions;
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> temperatrue;
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> pressure;
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> humidity;
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>{
      <span class="comment">//调用 接入方的 update</span>
      currentConditions.update(getTemperature(), getPressure(), getHumidity());
   }

   <span class="comment">//当数据有更新时，就调用 setData</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>{
      <span class="keyword">this</span>.temperatrue = temperature;
      <span class="keyword">this</span>.pressure = pressure;
      <span class="keyword">this</span>.humidity = humidity;
      <span class="comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span>
      dataChange();
   }
}</code></pre>
<p>client调用</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
      <span class="comment">//创建接入方 currentConditions</span>
      CurrentConditions currentConditions = <span class="keyword">new</span> CurrentConditions();
      <span class="comment">//创建 WeatherData 并将 接入方 currentConditions 传递到 WeatherData中</span>
      WeatherData weatherData = <span class="keyword">new</span> WeatherData(currentConditions);

      <span class="comment">//更新天气情况</span>
      weatherData.setData(<span class="number">30</span>, <span class="number">150</span>, <span class="number">40</span>);

      <span class="comment">//天气情况变化</span>
      System.out.println(<span class="string">"============天气情况变化============="</span>);
      weatherData.setData(<span class="number">40</span>, <span class="number">160</span>, <span class="number">20</span>);
   }
}

<span class="comment">//结果</span>
***Today mTemperature: <span class="number">30.0</span>***
***Today mPressure: <span class="number">150.0</span>***
***Today mHumidity: <span class="number">40.0</span>***
============天气情况变化=============
***Today mTemperature: <span class="number">40.0</span>***
***Today mPressure: <span class="number">160.0</span>***
***Today mHumidity: <span class="number">20.0</span>***</code></pre>
<h3 id="3-、传统方式的问题分析-1"><a href="#3-、传统方式的问题分析-1" class="headerlink" title="(3)、传统方式的问题分析"></a>(3)、传统方式的问题分析</h3><ol>
<li>其他第三方接入气象站获取数据的问题</li>
<li>无法在运行时动态的添加第三方(在 WeatherData 中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到 dataChange, 不利于维护，也不是动态加入)</li>
<li>违反 ocp 原则=&gt;观察者模式</li>
</ol>
<h2 id="2、观察者模式"><a href="#2、观察者模式" class="headerlink" title="2、观察者模式"></a>2、观察者模式</h2><h3 id="1-、基本介绍-18"><a href="#1-、基本介绍-18" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>观察者模式类似订牛奶业务</li>
<li>奶站/气象局：Subject</li>
<li>用户/第三方网站：Observer</li>
</ol>
<ul>
<li>Subject：登记注册、移除和通知</li>
</ul>
<ol>
<li>registerObserver 注册</li>
<li>removeObserver 移除</li>
<li>notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送，看具体需求定</li>
</ol>
<ul>
<li>Observer：接收输入</li>
</ul>
<p>观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为 Subject，依赖的对象为 Observer，Subject通知 Observer 变化,比如这里的奶站是 Subject，是 1 的一方。用户时 Observer，是多的一方。</p>
<h3 id="2-、UML类图分析-2"><a href="#2-、UML类图分析-2" class="headerlink" title="(2)、UML类图分析"></a>(2)、UML类图分析</h3><img src="设计模式/QQ截图20200222215005.png" style="zoom:67%;" />

<h3 id="3-、代码实现-1"><a href="#3-、代码实现-1" class="headerlink" title="(3)、代码实现"></a>(3)、代码实现</h3><p>首先写一个观察者接口，所有要实现订阅功能的类都去实现它</p>
<pre><code class="java"><span class="comment">//观察者接口，有观察者来实现</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>{
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span></span>;
}</code></pre>
<p>CurrentConditions直接从上面照抄</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditions</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>{

   <span class="comment">// 温度，气压，湿度</span>
   <span class="keyword">private</span> <span class="keyword">float</span> temperature;
   <span class="keyword">private</span> <span class="keyword">float</span> pressure;
   <span class="keyword">private</span> <span class="keyword">float</span> humidity;

   <span class="comment">// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>{
      <span class="keyword">this</span>.temperature = temperature;
      <span class="keyword">this</span>.pressure = pressure;
      <span class="keyword">this</span>.humidity = humidity;
      display();
   }

   <span class="comment">// 显示</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>{
      System.out.println(<span class="string">"***Today mTemperature: "</span> + temperature + <span class="string">"***"</span>);
      System.out.println(<span class="string">"***Today mPressure: "</span> + pressure + <span class="string">"***"</span>);
      System.out.println(<span class="string">"***Today mHumidity: "</span> + humidity + <span class="string">"***"</span>);
   }
}</code></pre>
<p>在写一个Subject接口，所有要实现发布功能的类都要有这三个方法，订阅 移除 通知</p>
<pre><code class="java"><span class="comment">//接口, 让WeatherData 来实现</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>{

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;
}</code></pre>
<p>WeatherData继承Subject接口，重写三个方法，然后其中有一个链表，对所有的订阅者进行遍历链表通知</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>{
   <span class="keyword">private</span> <span class="keyword">float</span> temperatrue;
   <span class="keyword">private</span> <span class="keyword">float</span> pressure;
   <span class="keyword">private</span> <span class="keyword">float</span> humidity;
   <span class="comment">//观察者集合</span>
   <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;

   <span class="comment">//加入新的第三方</span>
   <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>{
      observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> temperatrue;
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> pressure;
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> humidity;
   }

   <span class="comment">//当数据有更新时，就调用 setData</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>{
      <span class="keyword">this</span>.temperatrue = temperature;
      <span class="keyword">this</span>.pressure = pressure;
      <span class="keyword">this</span>.humidity = humidity;
      <span class="comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span>
      notifyObservers();
   }

   <span class="comment">//注册一个观察者</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>{
      observers.add(o);
   }

   <span class="comment">//移除一个观察者</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>{
      <span class="keyword">if</span>(observers.contains(o)) {
         observers.remove(o);
      }
   }

   <span class="comment">//遍历所有的观察者，并通知</span>
   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>{
      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++) {
         observers.get(i).update(<span class="keyword">this</span>.temperatrue, <span class="keyword">this</span>.pressure, <span class="keyword">this</span>.humidity);
      }
   }
}</code></pre>
<p>这样的可扩展性很好，其他网站要调用，直接实现Observer接口，并进行注册就可以使用了</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
   <span class="comment">//创建一个WeatherData</span>
   WeatherData weatherData = <span class="keyword">new</span> WeatherData();
   <span class="comment">//创建观察者</span>
   CurrentConditions currentConditions = <span class="keyword">new</span> CurrentConditions();
   BaiduSite baiduSite = <span class="keyword">new</span> BaiduSite();

   <span class="comment">//注册到weatherData</span>
   weatherData.registerObserver(currentConditions);
   weatherData.registerObserver(baiduSite);
   <span class="comment">//测试</span>
   System.out.println(<span class="string">"通知各个注册的观察者, 看看信息"</span>);
   weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);


   weatherData.removeObserver(currentConditions);
   <span class="comment">//测试</span>
   System.out.println();
   System.out.println(<span class="string">"通知各个注册的观察者, 看看信息"</span>);
   weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);
}</code></pre>
<h2 id="3、观察者模式在-JDK-应用的源码分析"><a href="#3、观察者模式在-JDK-应用的源码分析" class="headerlink" title="3、观察者模式在 JDK 应用的源码分析"></a>3、观察者模式在 JDK 应用的源码分析</h2><p> Jdk 的 Observable 类就使用了观察者模式</p>
<p>进入Observable类，可以看到其中维护了一个Vector，和list基本一样，线程安全而已</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;
    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;

    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>{
        obs = <span class="keyword">new</span> Vector&lt;&gt;();
    }</code></pre>
<p>然后其中也有注册，注销，通知方法，基本一模一样</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>{
    <span class="keyword">if</span> (o == <span class="keyword">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    <span class="keyword">if</span> (!obs.contains(o)) {
        obs.addElement(o);
    }
}

<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>{
        obs.removeElement(o);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>{

        Object[] arrLocal;

        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {

            <span class="keyword">if</span> (!changed)
                <span class="keyword">return</span>;
            arrLocal = obs.toArray();
            clearChanged();
        }

        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)
            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);
    }</code></pre>
<p>模式角色分析</p>
<ol>
<li>Observable 的作用和地位等价于 我们前面讲过 Subject</li>
<li>Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理 Observer 的方法add.. delete .. notify…</li>
<li>Observer 的作用和地位等价于我们前面讲过的 Observer, 有 update</li>
<li>Observable 和 Observer 的使用方法和前面讲过的一样，只是 Observable 是类，通过继承来实现观察者模式</li>
</ol>
<h1 id="十七、中介者设计模式"><a href="#十七、中介者设计模式" class="headerlink" title="十七、中介者设计模式"></a>十七、中介者设计模式</h1><h2 id="1、实际问题导出-11"><a href="#1、实际问题导出-11" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、智能家庭项目需求"><a href="#1-、智能家庭项目需求" class="headerlink" title="(1)、智能家庭项目需求"></a>(1)、智能家庭项目需求</h3><p>智能家庭项目：</p>
<ol>
<li>智能家庭包括各种设备，闹钟、咖啡机、电视机、窗帘 等</li>
<li>主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作，比如流程为：闹铃响起-&gt;咖啡机开始做咖啡-&gt;窗帘自动落下-&gt;电视机开始播放</li>
</ol>
<h3 id="2-、传统方案-2"><a href="#2-、传统方案-2" class="headerlink" title="(2)、传统方案"></a>(2)、传统方案</h3><img src="设计模式/QQ截图20200223103053.png" style="zoom:67%;" />

<h3 id="3-、传统的方式的问题分析"><a href="#3-、传统的方式的问题分析" class="headerlink" title="(3)、传统的方式的问题分析"></a>(3)、传统的方式的问题分析</h3><ol>
<li>当各电器对象有多种状态改变时，相互之间的调用关系会比较复杂</li>
<li>各个 电器对象彼此联系，你中有我，我中有你，不利于松耦合.</li>
<li>各个电器对象之间所传递的消息(参数)，容易混乱</li>
<li>当系统增加一个新的电器对象时，或者执行流程改变时，代码的可维护性、扩展性都不理想<br><font color="red">考虑中介者模式</font></li>
</ol>
<h2 id="2、中介者模式"><a href="#2、中介者模式" class="headerlink" title="2、中介者模式"></a>2、中介者模式</h2><h3 id="1-、基本介绍-19"><a href="#1-、基本介绍-19" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>中介者模式（Mediator Pattern），用一个 中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其 耦合松散，而且可以独立地改变它们之间的交互</li>
<li>中介者模式属于行为型模式，使代码易于维护</li>
<li>比如 MVC 模式，C（Controller 控制器）是 M（Model 模型）和 V（View 视图）的中介者，在前后端交互时起到了中间人的作用</li>
</ol>
<h3 id="2-、原理类图-8"><a href="#2-、原理类图-8" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="设计模式/QQ截图20200223102842.png" style="zoom:67%;" />

<p>对原理类图的说明-即(中介者模式的角色及职责)</p>
<ol>
<li>Mediator 就是抽象中介者,定义了同事对象到中介者对象的接口</li>
<li>Colleague 是抽象功能类</li>
<li>ConcreteMediator 具体的中介者对象, 实现抽象方法, 他需要知道所有的具体的功能类,即以一个集合来管理HashMap,并接受某个同事对象消息，完成相应的任务</li>
<li>ConcreteColleague 具体的功能类，会有很多, <font color="red">每个功能只知道自己的行为，而不了解其他功能类的行为(方法)，在自身的构造方法里面会使用依赖Mediator中介者对象，将自身放进ConcreteMediator的HashMap去管理</font></li>
</ol>
<h3 id="3-、应用实例要求-4"><a href="#3-、应用实例要求-4" class="headerlink" title="(3)、应用实例要求"></a>(3)、应用实例要求</h3><p>完成前面的智能家庭的项目，使用中介者模式</p>
<h3 id="4-、UML类图分析-7"><a href="#4-、UML类图分析-7" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="设计模式/QQ截图20200223105320.png" style="zoom:80%;" />

<h3 id="5-、代码实现-8"><a href="#5-、代码实现-8" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p>代码过于复杂，了解思想即可</p>
<h2 id="3、中介者模式的注意事项和细节"><a href="#3、中介者模式的注意事项和细节" class="headerlink" title="3、中介者模式的注意事项和细节"></a>3、中介者模式的注意事项和细节</h2><ol>
<li>多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构，进行解耦</li>
<li>减少类间依赖，降低了耦合，符合迪米特原则</li>
<li>中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响</li>
<li>如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意</li>
</ol>
<h1 id="十七、备忘录设计模式"><a href="#十七、备忘录设计模式" class="headerlink" title="十七、备忘录设计模式"></a>十七、备忘录设计模式</h1><h2 id="1、实际问题导出-12"><a href="#1、实际问题导出-12" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、游戏角色状态恢复需求"><a href="#1-、游戏角色状态恢复需求" class="headerlink" title="(1)、游戏角色状态恢复需求"></a>(1)、游戏角色状态恢复需求</h3><p>游戏角色有攻击力和防御力，在大战 Boss 前保存自身的状态(攻击力和防御力)，当大战 Boss 后攻击力和防御<br>力下降，从备忘录对象恢复到大战前的状态，就是要恢复一个对象原先的状态，游戏存档回档功能</p>
<h3 id="2-、传统方案-3"><a href="#2-、传统方案-3" class="headerlink" title="(2)、传统方案"></a>(2)、传统方案</h3><img src="设计模式/QQ截图20200223110914.png" style="zoom:50%;" />
传统方案就是倒酱油，每次再创建一个对象，拷贝所有的属性和状态，再拷贝回去

<h3 id="3-、传统的方式的问题分析-1"><a href="#3-、传统的方式的问题分析-1" class="headerlink" title="(3)、传统的方式的问题分析"></a>(3)、传统的方式的问题分析</h3><ol>
<li>一个对象，就对应一个保存对象状态的对象， 这样当我们游戏的对象很多时，不利于管理，开销也很大.</li>
<li>传统的方式是简单地做备份，new 出另外一个对象出来，再把需要备份的数据放到这个新对象，但这就暴露了对象内部的细节</li>
<li>解决方案： =&gt;  备忘录模式</li>
</ol>
<h2 id="2、备忘录模式"><a href="#2、备忘录模式" class="headerlink" title="2、备忘录模式"></a>2、备忘录模式</h2><h3 id="1-、基本介绍-20"><a href="#1-、基本介绍-20" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol>
<li>备忘录模式（Memento Pattern）在 不破坏封装性的前提下，捕获 一个对象的内部状态，并在该对象之外保存这个状态。这样以后就 可将该对象恢复到原先保存的状态</li>
<li>可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作</li>
<li>备忘录模式属于行为型模式</li>
</ol>
<h3 id="2-、原理类图-9"><a href="#2-、原理类图-9" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="设计模式/QQ截图20200223111242.png" style="zoom:80%;" />

<p>对原理类图的说明-即(备忘录模式的角色及职责)</p>
<ol>
<li>originator : 对象(需要保存状态的对象)</li>
<li>Memento ： 备忘录对象,负责保存好记录，即 Originator 内部状态</li>
<li>Caretaker: 守护者对象,负责保存多个备忘录对象， 使用集合管理，提高效率</li>
<li>说明：如果希望保存多个 originator 对象的不同时间的状态，也可以，只需要使用 HashMap &lt;String, 集合&gt;改进一下即可</li>
</ol>
<h3 id="3-、原理代码实现"><a href="#3-、原理代码实现" class="headerlink" title="(3)、原理代码实现"></a>(3)、原理代码实现</h3><p>首先写一个要保存的类，主要是两个方法，存档和回档</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>{

   <span class="keyword">private</span> String state;<span class="comment">//状态信息</span>

   <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> state;
   }

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>{
      <span class="keyword">this</span>.state = state;
   }

   <span class="comment">//编写一个方法，可以保存一个状态对象 Memento，因此编写一个方法，返回 Memento</span>
   <span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateMemento</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);
   }

   <span class="comment">//通过备忘录对象，恢复状态</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span> </span>{
      state = memento.getState();
   }
}</code></pre>
<p>一个备忘录类，构造方法传进了存的状态</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>{
   <span class="keyword">private</span> String state;

   <span class="comment">//构造器</span>
   <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>{
      <span class="keyword">super</span>();
      <span class="keyword">this</span>.state = state;
   }

   <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> state;
   }
}</code></pre>
<p>Caretaker一个管理状态类，设计一个ArrayList链表，存放所有的状态（能回到游戏的任意档）</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>{

   <span class="comment">//在List 集合中会有很多的备忘录对象</span>
   <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();

   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento memento)</span> </span>{
      mementoList.add(memento);
   }

   <span class="comment">//获取到第index个Originator 的 备忘录对象(即保存状态)</span>
   <span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{
      <span class="keyword">return</span> mementoList.get(index);
   }
}</code></pre>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{

   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
      Originator originator = <span class="keyword">new</span> Originator();
      Caretaker caretaker = <span class="keyword">new</span> Caretaker();

      originator.setState(<span class="string">" 状态#1 攻击力 100 "</span>);

      <span class="comment">//保存了当前的状态</span>
      caretaker.add(originator.saveStateMemento());

      originator.setState(<span class="string">" 状态#2 攻击力 80 "</span>);

      caretaker.add(originator.saveStateMemento());

      originator.setState(<span class="string">" 状态#3 攻击力 50 "</span>);
      caretaker.add(originator.saveStateMemento());

      System.out.println(<span class="string">"当前的状态是 ="</span> + originator.getState());

      <span class="comment">//希望得到状态 1, 将 originator 恢复到状态1</span>

      originator.getStateFromMemento(caretaker.get(<span class="number">0</span>));
      System.out.println(<span class="string">"恢复到状态1 , 当前的状态是"</span>);
      System.out.println(<span class="string">"当前的状态是 ="</span> + originator.getState());
   }
}

<span class="comment">//结果</span>
当前的状态是 = 状态#3 攻击力 50 
恢复到状态<span class="number">1</span> , 当前的状态是
当前的状态是 = 状态#1 攻击力 100 </code></pre>
<h2 id="3、备忘录模式的注意事项和细节"><a href="#3、备忘录模式的注意事项和细节" class="headerlink" title="3、备忘录模式的注意事项和细节"></a>3、备忘录模式的注意事项和细节</h2><ol>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li>
<li>实现了信息的封装，使得用户不需要关心状态的保存细节</li>
<li>如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存, 这个需要注意</li>
<li>适用的应用场景：<ul>
<li>后悔药。 </li>
<li>打游戏时的存档。</li>
<li>Windows 里的 ctri + z。 </li>
<li>IE 中的后退。 </li>
<li>数据库的事务管理</li>
</ul>
</li>
<li>为了节约内存，<font color="red">备忘录模式可以和原型模式配合使用</font></li>
</ol>
