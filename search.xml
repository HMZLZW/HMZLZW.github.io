<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/16/hello-world/"/>
      <url>/2020/04/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="你好，新世界！！！"><a href="#你好，新世界！！！" class="headerlink" title="你好，新世界！！！"></a>你好，新世界！！！</h1><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC详解</title>
      <link href="/2020/04/16/JUC/"/>
      <url>/2020/04/16/JUC/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-JUC"><a href="#第一章-JUC" class="headerlink" title="第一章 JUC"></a>第一章 JUC</h1><h2 id="1、JUC是什么"><a href="#1、JUC是什么" class="headerlink" title="1、JUC是什么"></a>1、JUC是什么</h2><p>java.util.concurrent在并发编程中使用的工具类,主要由以下3个包组成</p><img src="/2020/04/16/JUC/QQ截图20200220203545.png" style="zoom:150%;"><h2 id="2、进程-线程？-并发-并行？"><a href="#2、进程-线程？-并发-并行？" class="headerlink" title="2、进程/线程？  并发/并行？"></a>2、进程/线程？  并发/并行？</h2><h3 id="1-、进程-线程是什么？"><a href="#1-、进程-线程是什么？" class="headerlink" title="(1)、进程/线程是什么？"></a>(1)、进程/线程是什么？</h3><p>进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p><p>线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p><h3 id="2-、进程-线程例子？"><a href="#2-、进程-线程例子？" class="headerlink" title="(2)、进程/线程例子？"></a>(2)、进程/线程例子？</h3><p>线程依附于进程进行一些操作</p><p>使用QQ，查看进程一定有一个QQ.exe的进程，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。 QQ就是一个进程  </p><p>大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。  </p><p>word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个线程：容灾备份，语法检查</p><h3 id="3-、什么是并发？什么是并行？"><a href="#3-、什么是并发？什么是并行？" class="headerlink" title="(3)、什么是并发？什么是并行？"></a>(3)、什么是并发？什么是并行？</h3><p><strong>并发：同一时刻多个线程在访问同一个资源，多个线程对一个点</strong><br>      例子：小米9今天上午10点，限量抢购<br>            春运抢票<br>            电商秒杀…<br><strong>并行：多项工作一起执行，之后再汇总</strong><br>      例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p><h3 id="4-、线程状态"><a href="#4-、线程状态" class="headerlink" title="(4)、线程状态"></a>(4)、线程状态</h3><p>Thread.State的java源码，共如下几个状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,(新建)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,（准备就绪）</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,（阻塞）</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,（不见不散）【一直等，没有时间限制】</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,（过时不候）【比如说就等<span class="number">10</span>s中，有时间限制】</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;(终结)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-、wait-sleep的区别？"><a href="#5-、wait-sleep的区别？" class="headerlink" title="(5)、wait/sleep的区别？"></a>(5)、wait/sleep的区别？</h3><p>功能都是当前线程暂停，有什么区别？</p><p>wait放开手去睡，放开手里的锁</p><p>sleep握紧手去睡，醒了手里还有锁</p><h1 id="第二章-Lock接口"><a href="#第二章-Lock接口" class="headerlink" title="第二章 Lock接口"></a>第二章 Lock接口</h1><h2 id="1、创建线程的方式"><a href="#1、创建线程的方式" class="headerlink" title="1、创建线程的方式"></a>1、创建线程的方式</h2><h3 id="1-、类直接继承Thread"><a href="#1-、类直接继承Thread" class="headerlink" title="(1)、类直接继承Thread"></a>(1)、类直接继承Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure><p>java是单继承，资源宝贵，要用接口方式</p><p><font color="red">不能这样写</font></p><h3 id="2-、new-Thread"><a href="#2-、new-Thread" class="headerlink" title="(2)、new Thread();"></a>(2)、new Thread();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line"> t1.start();</span><br></pre></td></tr></table></figure><p>这样写太low了<br><font color="red">不要这样写</font></p><h3 id="3-、第三种"><a href="#3-、第三种" class="headerlink" title="(3)、第三种"></a>(3)、第三种</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">//具体业务逻辑的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br></pre></td></tr></table></figure><h2 id="2、复习Synchronized（卖票练习1）"><a href="#2、复习Synchronized（卖票练习1）" class="headerlink" title="2、复习Synchronized（卖票练习1）"></a>2、复习Synchronized（卖票练习1）</h2><p>核心思想，线程操作（暴露接口）资源类</p><p><strong>使用synchronized同步锁</strong></p><p>首先创建资源类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"卖出第"</span> + number-- + <span class="string">"张票,还剩"</span> + number + <span class="string">"张"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">                    ticket.saleTicket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">                    ticket.saleTicket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">                    ticket.saleTicket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Lock接口"><a href="#3、Lock接口" class="headerlink" title="3、Lock接口"></a>3、Lock接口</h2><h3 id="1-、Lock是什么"><a href="#1-、Lock是什么" class="headerlink" title="(1)、Lock是什么"></a>(1)、Lock是什么</h3><p>Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects. </p><p>锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。</p><p>Lock定义为一个接口，具体的实现由子类完成</p><h3 id="2-、ReentrantLock可重复锁"><a href="#2-、ReentrantLock可重复锁" class="headerlink" title="(2)、ReentrantLock可重复锁"></a>(2)、ReentrantLock可重复锁</h3><p>ReentrantLock是接口Lock的一个具体实现类，可重复使用的锁</p><p>使用模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// ... method body</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-、synchronized与Lock的区别"><a href="#3-、synchronized与Lock的区别" class="headerlink" title="(3)、synchronized与Lock的区别"></a>(3)、synchronized与Lock的区别</h3><p>两者区别：</p><ol><li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li><li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li><li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li><li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li><li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</li><li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。反正Lock比synchronized牛逼就完事了。</li></ol><h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p>层次: java层次</p><p>前提: 线程等待时会被挂起，轮到他时会被唤醒</p><ul><li><p>公平锁： 新进程发出请求，如果此时一个线程正持有锁，或有其他线程正在等待队列中等待这个锁，那么新的线程将被放入到队列中被挂起。相当于一堆嗜睡的低血糖病人排队看医生，进去的病人门一关，外面的人便排队候着打瞌睡，轮到他时再醒醒进去</p></li><li><p>非公平锁: 新进程发出请求，如果此时一个线程正持有锁，新的线程将被放入到队列中被挂起，但如果发出请求的同时该锁变成可用状态，那么这个线程会跳过队列中所有的等待线程而获得锁。相当于排队看医生，进去的病人门一关，外面的人便排队候着打瞌睡，这时新人来了，碰巧门一开，外面的人还没完全醒来，他就乘机冲了进去。</p></li></ul><p>非公平锁性能高于公平锁性能的原因：</p><p>在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。相当于人从被叫醒要完全醒过来需要时间。</p><p>假设线程A持有一个锁，并且线程B请求这个锁。由于锁被A持有，因此B将被挂起。当A释放锁时，B将被唤醒，因此B会再次尝试获取这个锁。与此同时，如果线程C也请求这个锁，那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样就是一种双赢的局面：B获得锁的时刻并没有推迟，C更早的获得了锁，并且吞吐量也提高了。</p><p>当持有锁的时间相对较长或者请求锁的平均时间间隔较长，应该使用公平锁。在这些情况下，插队带来的吞吐量提升（当锁处于可用状态时，线程却还处于被唤醒的过程中）可能不会出现。</p><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p><p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><p>要点：</p><ul><li>可重入锁的一个优点是可一定程度避免死锁</li><li>AQS通过控制status状态来判断锁的状态，对于非可重入锁状态不是0则去阻塞；对于可重入锁如果是0则执行，非0则判断当前线程是否是获取到这个锁的线程，是的话把status状态＋1，释放的时候，只有status为0，才将锁释放。</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"获得"</span>+lockA);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"获得"</span>+lockB);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeathLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA = <span class="string">"lockA"</span>;</span><br><span class="line">        String lockB = <span class="string">"lockB"</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldThread(lockA, lockB), <span class="string">"threadAAA"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldThread(lockB, lockA), <span class="string">"threadBBB"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/16/JUC/QQ%E6%88%AA%E5%9B%BE20200403180852.png" alt></p><p><strong>排查流程</strong></p><p>首先使用jsp -l命令查看是哪个进程惹事注意，（不加-l，不显示类的全路径，增加排查难度）</p><img src="/2020/04/16/JUC/QQ截图20200403181044.png" style="zoom:80%;"><img src="/2020/04/16/JUC/QQ截图20200403181757.png" style="zoom:80%;"><p>主要是下面这一段代码，检测出了死锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"threadBBB":</span><br><span class="line">  waiting to lock monitor 0x0000000003308fa8 (object 0x000000076b6a08e8, a java.lang.String),</span><br><span class="line">  which is held by "threadAAA"</span><br><span class="line">"threadAAA":</span><br><span class="line">  waiting to lock monitor 0x000000000330b8e8 (object 0x000000076b6a0920, a java.lang.String),</span><br><span class="line">  which is held by "threadBBB"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"threadBBB":</span><br><span class="line">        at lzw.juc.lock.death.HoldThread.run(HoldThread.java:27)</span><br><span class="line">        - waiting to lock &lt;0x000000076b6a08e8&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x000000076b6a0920&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">"threadAAA":</span><br><span class="line">        at lzw.juc.lock.death.HoldThread.run(HoldThread.java:27)</span><br><span class="line">        - waiting to lock &lt;0x000000076b6a0920&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x000000076b6a08e8&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><p>也可以使用jconsole命令,会弹出这个可视化工具，一键自动检测</p><img src="/2020/04/16/JUC/QQ截图20200403194758.png" style="zoom:80%;"><img src="/2020/04/16/JUC/QQ截图20200403194905.png" style="zoom:80%;"><h2 id="4、Lock卖票改进（卖票练习2）"><a href="#4、Lock卖票改进（卖票练习2）" class="headerlink" title="4、Lock卖票改进（卖票练习2）"></a>4、Lock卖票改进（卖票练习2）</h2><p><strong>版本2：使用Lock锁</strong></p><p>资源类改为Lock锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"卖出第"</span> + number-- + <span class="string">"张票,还剩"</span> + number + <span class="string">"张"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三章-Java8之lambda表达式复习"><a href="#第三章-Java8之lambda表达式复习" class="headerlink" title="第三章 Java8之lambda表达式复习"></a>第三章 Java8之lambda表达式复习</h1><h2 id="1、什么是Lambda"><a href="#1、什么是Lambda" class="headerlink" title="1、什么是Lambda"></a>1、什么是Lambda</h2><p>Lambda 是一个匿名函数，我们可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p><p>Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或剪头操作符。它将 Lambda 分为两个部分：<br>左侧：指定了 Lambda 表达式需要的所有参数<br>右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能</p><p>在上面的接口</p><h2 id="2、Lambda表达式接口实现语法"><a href="#2、Lambda表达式接口实现语法" class="headerlink" title="2、Lambda表达式接口实现语法"></a>2、Lambda表达式接口实现语法</h2><p>lambda表达式，如果一个接口只有一个方法(一个非default，非static方法)，我们可以把方法名省略</p><p><strong>写法：</strong></p><p><strong>照抄拷贝小括号（），写死右箭头-&gt;，落地大括号{…}</strong></p><h2 id="3、Lambda卖票改进（卖票练习2）"><a href="#3、Lambda卖票改进（卖票练习2）" class="headerlink" title="3、Lambda卖票改进（卖票练习2）"></a>3、Lambda卖票改进（卖票练习2）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++)&#123; ticket.saleTicket();&#125;&#125;,<span class="string">"A"</span>).start();</span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++)&#123; ticket.saleTicket();&#125;&#125;,<span class="string">"B"</span>).start();</span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++)&#123; ticket.saleTicket();&#125;&#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、详解Lambda表达式接口实现"><a href="#4、详解Lambda表达式接口实现" class="headerlink" title="4、详解Lambda表达式接口实现"></a>4、详解Lambda表达式接口实现</h2><p>lambda表达式，必须是函数式接口`@FunctionalInterface），必须只有一个方法<br>如果接口只有一个方法java默认它为函数式接口。<br>为了正确使用Lambda表达式，需要给接口加个注解（默认加）：@FunctionalInterface<br>如有两个方法，立刻报错</p><p>Runnable接口为什么可以用lambda表达式？ –》只有一个Run方法</p><p>但是</p><p>java8后接口里容许有接口default的实现(默认实现)<br>default int div(int x,int y) {<br>  return x/y;<br> }<br><strong>接口里default方法可以有几个？  多个</strong></p><p>且允许静态方法实现<br>public static int sub(int x,int y){<br>  return x-y;<br>}<br><strong>可以有几个？  多个</strong></p><p>但是在调用的时候要改成<code>Foo.sub</code>即可，不是接口的实现类去调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x/y;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x-y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Lambda Express-----&gt; 函数式编程</span></span><br><span class="line"><span class="comment"> * 1 拷贝小括号(形参列表)，写死右箭头 -&gt;，落地大括号 &#123;方法实现&#125;</span></span><br><span class="line"><span class="comment"> * 2 有且只有一个public方法<span class="doctag">@FunctionalInterface</span>注解增强定义</span></span><br><span class="line"><span class="comment"> * 3 default方法默认实现</span></span><br><span class="line"><span class="comment"> * 4 静态方法实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   Foo foo = (x,y)-&gt;&#123;</span><br><span class="line">   System.out.println(<span class="string">"Hello!! lambda !!"</span>);</span><br><span class="line">   <span class="keyword">return</span> x+y;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> result = foo.add(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">   System.out.println(<span class="string">"******result="</span>+result);</span><br><span class="line">   System.out.println(<span class="string">"******result div="</span>+foo.div(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line">   System.out.println(<span class="string">"******result sub="</span>+Foo.sub(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第四章-线程间通信"><a href="#第四章-线程间通信" class="headerlink" title="第四章 线程间通信"></a>第四章 线程间通信</h1><h2 id="1、生产者消费者问题"><a href="#1、生产者消费者问题" class="headerlink" title="1、生产者消费者问题"></a>1、生产者消费者问题</h2><p>两个核心思想</p><p>1、生产者+消费者</p><p>2、通知等待唤醒机制</p><p>Resources资源类，一个生产方法，一个消费方法，使用synchronized锁，然后产品为0生产，产品不为0消费，使用<code>this.notifyAll();</code>  唤醒线程，进行线程通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br></pre></td></tr></table></figure><p>两个线程之间的调度，没有问题，但是如果4个线程，两个生产，两个消费就会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br><span class="line">C <span class="number">1</span></span><br><span class="line">A <span class="number">2</span></span><br><span class="line">C <span class="number">3</span></span><br><span class="line">A <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这个问题就是多线程之间的中断和虚假唤醒导致的，Java官方给出了解决方法</p><p>像在一个参数版本中，中断和虚假唤醒是可能的，并且该方法应该始终在循环中使用： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"> <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">                obj.wait();</span><br><span class="line">            ... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>所以上面的if换成while就可以了，根本原因就是if只会判断一次，而while会一直判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br><span class="line">A <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br><span class="line">C <span class="number">1</span></span><br><span class="line">B <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="2、java8新版实现生产者消费者问题"><a href="#2、java8新版实现生产者消费者问题" class="headerlink" title="2、java8新版实现生产者消费者问题"></a>2、java8新版实现生产者消费者问题</h2><p>在java8里使用新的Lock和Condition解决买票问题</p><p>Java官方解释</p><p>public interface Condition Condition因素出Object监视器方法（ wait ， notify和notifyAll ）成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果Lock个实现。 Lock替换synchronized方法和语句的使用， Condition取代了对象监视器方法的使用。<br>条件（也称为条件队列或条件变量 ）为一个线程暂停执行（“等待”）提供了一种方法，直到另一个线程通知某些状态现在可能为真。 因为访问此共享状态信息发生在不同的线程中，所以它必须被保护，因此某种形式的锁与该条件相关联。 等待条件的关键属性是它原子地释放相关的锁并挂起当前线程，就像Object.wait 。 </p><p>一个Condition实例本质上绑定到一个锁。 要获得特定Condition实例的Condition实例，请使用其newCondition()方法。 </p><p>例如，假设我们有一个有限的缓冲区，它支持put和take方法。 如果在一个空的缓冲区尝试一个take ，则线程将阻塞直到一个项目可用; 如果put试图在一个完整的缓冲区，那么线程将阻塞，直到空间变得可用。 我们希望在单独的等待集中等待put线程和take线程，以便我们可以在缓冲区中的项目或空间可用的时候使用仅通知单个线程的优化。 这可以使用两个Condition实例来实现。 </p><p>Java官方给出的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">     <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">     <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">     <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       lock.lock(); <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == items.length)</span><br><span class="line">           notFull.await();</span><br><span class="line">         items[putptr] = x;</span><br><span class="line">         <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">         ++count;</span><br><span class="line">         notEmpty.signal();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       lock.lock(); <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">           notEmpty.await();</span><br><span class="line">         Object x = items[takeptr];</span><br><span class="line">         <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">         --count;</span><br><span class="line">         notFull.signal();</span><br><span class="line">         <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面的资源类继续进行改进，改成Java8新的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、线程间精准通知顺序访问"><a href="#3、线程间精准通知顺序访问" class="headerlink" title="3、线程间精准通知顺序访问"></a>3、线程间精准通知顺序访问</h2><p>要求：3个线程，顺序执行，a打印5次，b打印10次，c打印15次</p><p>思路</p><p>1、有顺序通知，需要有标识位</p><p>2、有一个锁Lock，3把钥匙Condition</p><p>3、判断标志位</p><p>4、输出线程名+第几次+第几轮</p><p>5、修改标志位，通知下一个</p><p>继续使用ReentrantLock可重复使用锁类和Condition钥匙</p><p>number定义为标记量，三把钥匙对应三个线程，完成一个线程操作后，&lt;font color=”red&gt;”精准通知下一个要唤醒的线程。使用c2.signal();  而不是上面的 signalAll();  精准通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//A 就要停止</span></span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t totalLoopNumber: "</span> + totalLoopNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3 通知</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//A 就要停止</span></span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t totalLoopNumber: "</span> + totalLoopNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3 通知</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">//A 就要停止</span></span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t totalLoopNumber: "</span> + totalLoopNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3 通知</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第五章-8锁问题"><a href="#第五章-8锁问题" class="headerlink" title="第五章 8锁问题"></a>第五章 8锁问题</h1><h2 id="1、锁的8个问题"><a href="#1、锁的8个问题" class="headerlink" title="1、锁的8个问题"></a>1、锁的8个问题</h2><p>1 标准访问，先打印短信还是邮件<br>2 停4秒在短信方法内，先打印短信还是邮件<br>3 普通的hello方法，是先打短信还是hello<br>4 现在有两部手机，先打印短信还是邮件<br>5 两个静态同步方法，1部手机，先打印短信还是邮件<br>6 两个静态同步方法，2部手机，先打印短信还是邮件<br>7 1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件<br>8 1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------sendSMS"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"------sendEmail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------getHello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 8锁</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 1 标准访问，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 2 停4秒在短信方法内，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 3 新增普通的hello方法，是先打短信还是hello</span></span><br><span class="line"><span class="comment"> * 4 现在有两部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 5 两个静态同步方法，1部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 6 两个静态同步方法，2部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 7 1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * 8 1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</span></span><br><span class="line"><span class="comment"> * ---------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock_8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"AA"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">                <span class="comment">//phone.getHello();</span></span><br><span class="line">                <span class="comment">//phone2.sendEmail();</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"BB"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 标准访问，先打印短信还是邮件<br>2 停4秒在短信方法内，先打印短信还是邮件<br>3 普通的hello方法，是先打短信还是hello<br>4 现在有两部手机，先打印短信还是邮件<br>5 两个静态同步方法，1部手机，先打印短信还是邮件<br>6 两个静态同步方法，2部手机，先打印短信还是邮件<br>7 1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件<br>8 1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件</p><p> 运行答案：<br>1、短信<br>2、短信<br>3、Hello<br>4、邮件<br>5、短信<br>6、短信<br>7、邮件<br>8、邮件</p><h2 id="2、8锁分析"><a href="#2、8锁分析" class="headerlink" title="2、8锁分析"></a>2、8锁分析</h2><p>A 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，<font color="red">某一个时刻内，只能有唯一一个线程进入类中去访问这些synchronized方法，锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</font>，而加个普通方法后发现和同步锁无关</p><p>换成两个对象后，不是同一把锁了，情况立刻变化。</p><p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。<br>具体表现为以下3种形式。</p><ol><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。改Class对象的所有实例全部锁上，相当于小米公司停电，小米红米全部拉闸被锁了</li><li>对于同步方法块，锁是Synchonized括号里配置的对象</li></ol><p>总而言之，就是 静态同步方法会锁定整个类，普通同步方法会锁定该类的实例</p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，<br>所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p><p>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p><h1 id="第六章-多线程集合类"><a href="#第六章-多线程集合类" class="headerlink" title="第六章 多线程集合类"></a>第六章 多线程集合类</h1><h2 id="1、ArrayList不安全"><a href="#1、ArrayList不安全" class="headerlink" title="1、ArrayList不安全"></a>1、ArrayList不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.print(Thread.currentThread().getName()+<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;list.size();j++)&#123;</span><br><span class="line">                    System.out.print(list.get(j)+<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 执行后会抛出java.util.ConcurrentModificationException异常</p><p>ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常并发修改异常</p><p><strong>原因剖析：</strong></p><p>查看ArrayList源码，看其中的add方法,其中并没有<code>synchronized</code>同步锁，这就从根本导致了ArrayList不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理 HashSet，HashMap也不安全（HashSet的add是放一个值，而HashMap是放K、V键值对）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、解决办法"><a href="#2、解决办法" class="headerlink" title="2、解决办法"></a>2、解决办法</h2><h3 id="1-、Vector"><a href="#1-、Vector" class="headerlink" title="(1)、Vector"></a>(1)、Vector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加了synchronized同步锁就完事了，但是这个Vector不常用，比较陌生，不推荐</p><h3 id="2-、Collections"><a href="#2-、Collections" class="headerlink" title="(2)、Collections"></a>(2)、Collections</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>Collections提供了方法synchronizedList保证list是同步线程安全的</p><p>这个也不常用，比较陌生，不推荐</p><h3 id="3-、写时复制"><a href="#3-、写时复制" class="headerlink" title="(3)、写时复制"></a>(3)、写时复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>不加锁性能提升出错误，加锁数据一致性能下降</p><p>A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.<br>CopyOnWriteArrayList是arraylist的一种线程安全变体，其中所有可变操作（add、set等）都是通过生成底层数组的新副本来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。添加元素后，再将原容器的引用指向新的容器setArray(newElements)。这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><p>可是这个效率低，每次写的时候都要复制一下，适合于读需求大，写需求小的地方</p><p>这个比较好，<font color="red">推荐使用，底层还是一个ArrayList，比较熟悉，推荐使用，以后单线程就用ArrayList，多线程就用CopyOnWriteArrayList</font></p><h2 id="3、多说一点集合类"><a href="#3、多说一点集合类" class="headerlink" title="3、多说一点集合类"></a>3、多说一点集合类</h2><p>这个不属于多线程的内容，是集合的基本知识，看到了写一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap在构建的时候，如果什么都不写，默认的初始容量是16和负载因子是0.75，当前的容量大于初始容量<em>负载因子时，即 16 \</em> 0.75=12 ，大于12时，扩容为2倍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt;map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>1、为什么初始容量是16</p><p>当容量为2的幂时，上述n -1 对应的二进制数全为1，这样才能保证它和key的hashcode做&amp;运算后，能够均匀分布，这样才能减少hash碰撞的次数。至于默认值为什么是16，而不是2 、4、8，或者32、64、1024等，我想应该就是个折中处理，过小会导致放不下几个元素，就要进行扩容了，而扩容是一个很消耗性能的操作。取值过大的话，无疑会浪费更多的内存空间。因此在日常开发中，如果可以预估HashMap会存入节点的数量，则应该在初始化时，指定其容量。</p><p>2、为什么负载因子是0.75</p><p>也是一个综合考虑，如果设置过小，HashMap每put少量的数据，都要进行一次扩容，而扩容操作会消耗大量的性能。如果设置过大的话，如果设成1，容量还是16，假设现在数组上已经占用的15个，再要put数据进来，计算数组index时，发生hash碰撞的概率将达到15/16，这违背的HashMap减少hash碰撞的原则。</p><p>HashMap扩容为原来的两倍</p><p>ArrayList扩容为原来的1.5倍（加上原来的一半）</p><h1 id="第七章-Callable接口"><a href="#第七章-Callable接口" class="headerlink" title="第七章 Callable接口"></a>第七章 Callable接口</h1><h2 id="1、Callable接口介绍"><a href="#1、Callable接口介绍" class="headerlink" title="1、Callable接口介绍"></a>1、Callable接口介绍</h2><p><strong>面试题：获得多线程的方法几种？</strong><br>（1）继承thread类（2）runnable接口<br>如果只回答这两个你连被问到JUC的机会都没有 </p><p>第三种 Callable接口</p><p>Callable接口是一个函数式接口，因此可以用作lambda表达式或方法引用的赋值对象。</p><img src="/2020/04/16/JUC/QQ截图20200221220621.png" style="zoom:1200%;"><h2 id="2、与runnable接口对比"><a href="#2、与runnable接口对比" class="headerlink" title="2、与runnable接口对比"></a>2、与runnable接口对比</h2><p>创建新类MyThread实现runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新类MyThread2实现callable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 面试题:callable接口与runnable接口的区别？</p><ol><li>是否有返回值</li><li>是否抛异常</li><li>落地方法不一样，一个是run，一个是call</li></ol><h2 id="3、怎么用？"><a href="#3、怎么用？" class="headerlink" title="3、怎么用？"></a>3、怎么用？</h2><img src="/2020/04/16/JUC/QQ截图20200221220912.png" style="zoom:100%;"><p>可以看到一个很尴尬的事情，在线程的8个构造方法里面没有涉及到callable接口参数的构造方法，最常用的第三个方法也是runnable接口参数的构造方法。</p><p>Java官方早就知道了这个问题，所以神奇的设计模式他来了，适配器模式完美解决</p><p>RunnableFuture接口继承了Runnable接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</span><br></pre></td></tr></table></figure><p>而有一个FutureTask类实现了RunnableFuture接口，且其中的构造方法涉及到了callable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">     <span class="title">public</span> <span class="title">FutureTask</span>(<span class="title">Callable</span>&lt;<span class="title">V</span>&gt; <span class="title">callable</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所以在使用的时候，先使用FutureTask过度一下，然后就可以Thread来创建线程了</p><p>这就是Java多态和设计模式的妙啊</p><h2 id="4、FutureTask"><a href="#4、FutureTask" class="headerlink" title="4、FutureTask"></a>4、FutureTask</h2><h3 id="1-、是什么"><a href="#1-、是什么" class="headerlink" title="(1)、是什么"></a>(1)、是什么</h3><p>未来的任务，用它就干一件事，异步调用main方法就像一个冰糖葫芦，一个个方法由main串起来。<br>但解决不了一个问题：正常调用挂起堵塞问题</p><p> 例子：<br>（1）老师上着课，口渴了，去买水不合适，讲课线程继续，我可以单起个线程找班长帮忙买水，<br>水买回来了放桌上，我需要的时候再去get。<br>（2）4个同学，A算1+20,B算21+30,C算31*到40,D算41+50，是不是C的计算量有点大啊，<br>FutureTask单起个线程给C计算，我先汇总ABD，最后等C计算完了再汇总C，拿到最终结果<br>（3）高考：会做的先做，不会的放在后面做</p><h3 id="2-、原理"><a href="#2-、原理" class="headerlink" title="(2)、原理"></a>(2)、原理</h3><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，<br>当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。</p><p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。 </p><p>只会使用计算一次，get方法放到最后</p><h3 id="3-、代码"><a href="#3-、代码" class="headerlink" title="(3)、代码"></a>(3)、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" come in callable"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"A"</span>).start();</span><br><span class="line">        System.out.println(<span class="string">"Main Finish"</span>);</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Main Finish</span><br><span class="line">A come in callable</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><p>futureTask会另开一个线程，单独计算，不影响其他线程运行</p><h1 id="第八章-JUC强大的辅助类讲解"><a href="#第八章-JUC强大的辅助类讲解" class="headerlink" title="第八章 JUC强大的辅助类讲解"></a>第八章 JUC强大的辅助类讲解</h1><h2 id="1、CountDownLatch-减少计数"><a href="#1、CountDownLatch-减少计数" class="headerlink" title="1、CountDownLatch 减少计数"></a>1、CountDownLatch 减少计数</h2><p>例子：CountDownLatchDemo        </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//6个上自习的同学，各自离开教室的时间不一致</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName()+<span class="string">"\t 号同学离开教室"</span>);</span><br><span class="line">          &#125;, String.valueOf(i)).start();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">"\t****** 班长关门走人，main线程是班长"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span> 号同学离开教室</span><br><span class="line"><span class="number">2</span> 号同学离开教室</span><br><span class="line">main****** 班长关门走人，main线程是班长</span><br><span class="line"><span class="number">3</span> 号同学离开教室</span><br><span class="line"><span class="number">4</span> 号同学离开教室</span><br><span class="line"><span class="number">5</span> 号同学离开教室</span><br><span class="line"><span class="number">6</span> 号同学离开教室</span><br></pre></td></tr></table></figure><p>这样的话班长关门走人了，而其他线程还在教室，这样就不对，为了方便规定线程之间的顺序，使用CountDownLatch</p><p><strong>原理</strong></p><ul><li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</li><li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</li><li>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。    </li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;        </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">  *  *让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</span></span><br><span class="line"><span class="comment">  * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</span></span><br><span class="line"><span class="comment">  * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 解释：6个同学陆续离开教室后值班同学才可以关门。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">         CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//6个上自习的同学，各自离开教室的时间不一致</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName()+<span class="string">"\t 号同学离开教室"</span>);</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">          &#125;, String.valueOf(i)).start();</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">"\t****** 班长关门走人，main线程是班长"</span>);</span><br><span class="line">          </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">2</span> 号同学离开教室</span><br><span class="line"><span class="number">1</span> 号同学离开教室</span><br><span class="line"><span class="number">3</span> 号同学离开教室</span><br><span class="line"><span class="number">5</span> 号同学离开教室</span><br><span class="line"><span class="number">6</span> 号同学离开教室</span><br><span class="line"><span class="number">4</span> 号同学离开教室</span><br><span class="line">main****** 班长关门走人，main线程是班长</span><br></pre></td></tr></table></figure><p>只关心线程是否全部做完，而不管具体的顺序。</p><h2 id="2、CyclicBarrier-循环栅栏"><a href="#2、CyclicBarrier-循环栅栏" class="headerlink" title="2、CyclicBarrier 循环栅栏"></a>2、CyclicBarrier 循环栅栏</h2><p>例子：CyclicBarrierDemo<br>        原理</p><ul><li>CyclicBarrier</li><li>的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</li><li>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</li><li>直到最后一个线程到达屏障时，屏障才会开门，所有</li><li>被屏障拦截的线程才会继续干活。</li><li>线程进入屏障通过CyclicBarrier的await()方法。</li></ul><p>上面的<code>CountDownLatch</code>是所有线程都执行完后，才放行下一个要做的，做减法</p><p>这个<code>CyclicBarrier</code>是所有线程都到齐之后，才执行下一个要做，做加法</p><p>​    </p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CyclicBarrier</span></span><br><span class="line"><span class="comment"> * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</span></span><br><span class="line"><span class="comment"> * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</span></span><br><span class="line"><span class="comment"> * 直到最后一个线程到达屏障时，屏障才会开门，所有</span></span><br><span class="line"><span class="comment"> * 被屏障拦截的线程才会继续干活。</span></span><br><span class="line"><span class="comment"> * 线程进入屏障通过CyclicBarrier的await()方法。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 集齐7颗龙珠就可以召唤神龙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//CyclicBarrier(int parties, Runnable barrierAction)</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(NUMBER, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"*****集齐7颗龙珠就可以召唤神龙"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 星龙珠被收集 "</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span> 星龙珠被收集 </span><br><span class="line"><span class="number">3</span> 星龙珠被收集 </span><br><span class="line"><span class="number">2</span> 星龙珠被收集 </span><br><span class="line"><span class="number">4</span> 星龙珠被收集 </span><br><span class="line"><span class="number">6</span> 星龙珠被收集 </span><br><span class="line"><span class="number">5</span> 星龙珠被收集 </span><br><span class="line"><span class="number">7</span> 星龙珠被收集 </span><br><span class="line">*****集齐<span class="number">7</span>颗龙珠就可以召唤神龙</span><br></pre></td></tr></table></figure><h2 id="3、Semaphore-信号灯（PV原语操作）"><a href="#3、Semaphore-信号灯（PV原语操作）" class="headerlink" title="3、Semaphore 信号灯（PV原语操作）"></a>3、Semaphore 信号灯（PV原语操作）</h2><p><strong>原理</strong></p><p> 在信号量上我们定义两种操作：</p><ul><li>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），</li><li>要么一直等下去，直到有线程释放信号量，或超时。</li><li>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</li><li>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</li></ul><p>其实就是PV原语操作</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在信号量上我们定义两种操作：</span></span><br><span class="line"><span class="comment">  * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），</span></span><br><span class="line"><span class="comment">  *     要么一直等下去，直到有线程释放信号量，或超时。</span></span><br><span class="line"><span class="comment">  * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);<span class="comment">//模拟3个停车位</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//模拟6部汽车</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> </span><br><span class="line">          &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 抢到了车位"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t------- 离开"</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span> 抢到了车位</span><br><span class="line"><span class="number">2</span> 抢到了车位</span><br><span class="line"><span class="number">3</span> 抢到了车位</span><br><span class="line"><span class="number">2</span>------- 离开</span><br><span class="line"><span class="number">4</span> 抢到了车位</span><br><span class="line"><span class="number">4</span>------- 离开</span><br><span class="line"><span class="number">5</span> 抢到了车位</span><br><span class="line"><span class="number">1</span>------- 离开</span><br><span class="line"><span class="number">3</span>------- 离开</span><br><span class="line"><span class="number">6</span> 抢到了车位</span><br><span class="line"><span class="number">6</span>------- 离开</span><br><span class="line"><span class="number">5</span>------- 离开</span><br></pre></td></tr></table></figure><p>就是PV原语操作，抢资源 -1，为0等待，释放资源+1</p><h2 id="4、ReentrantReadWriteLock读写锁"><a href="#4、ReentrantReadWriteLock读写锁" class="headerlink" title="4、ReentrantReadWriteLock读写锁"></a>4、ReentrantReadWriteLock读写锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在写"</span> + key);</span><br><span class="line">        <span class="comment">//暂停一会儿线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 写完了"</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在读"</span> + key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        result = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 读完了"</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(num + <span class="string">""</span>, num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span> 正在写<span class="number">1</span></span><br><span class="line"><span class="number">2</span> 正在写<span class="number">2</span></span><br><span class="line"><span class="number">3</span> 正在写<span class="number">3</span></span><br><span class="line"><span class="number">4</span> 正在写<span class="number">4</span></span><br><span class="line"><span class="number">5</span> 正在写<span class="number">5</span></span><br><span class="line"><span class="number">1</span> 正在读<span class="number">1</span></span><br><span class="line"><span class="number">2</span> 正在读<span class="number">2</span></span><br><span class="line"><span class="number">3</span> 正在读<span class="number">3</span></span><br><span class="line"><span class="number">4</span> 正在读<span class="number">4</span></span><br><span class="line"><span class="number">5</span> 正在读<span class="number">5</span></span><br><span class="line"><span class="number">1</span> 写完了<span class="number">1</span></span><br><span class="line"><span class="number">2</span> 读完了<span class="keyword">null</span></span><br><span class="line"><span class="number">1</span> 读完了<span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到没有锁的情况下，违反了原子性，1还没有写完，其他的操作又进来了，使用读写锁解决</p><ul><li>读-读可共享</li><li>读-写不可共享</li><li>写-写不可可共享</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在写"</span> + key);</span><br><span class="line">            <span class="comment">//暂停一会儿线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 写完了"</span> + key);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在读"</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 读完了"</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(num + <span class="string">""</span>, num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span> 正在写<span class="number">1</span></span><br><span class="line"><span class="number">1</span> 写完了<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 正在写<span class="number">2</span></span><br><span class="line"><span class="number">2</span> 写完了<span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="第九章-阻塞队列"><a href="#第九章-阻塞队列" class="headerlink" title="第九章 阻塞队列"></a>第九章 阻塞队列</h1><h2 id="1、阻塞队列是什么"><a href="#1、阻塞队列是什么" class="headerlink" title="1、阻塞队列是什么"></a>1、阻塞队列是什么</h2><p>阻塞：必须要阻塞/不得不阻塞<br>阻塞队列是一个队列，在数据结构中起的作用如下图：</p><img src="/2020/04/16/JUC/批注 2020-02-22 134107.png" style="zoom: 60%;">线程1往阻塞队列里添加元素，线程2从阻塞队列里移除元素<p>当队列是空的，从队列中获取元素的操作将会被阻塞<br>当队列是满的，从队列中添加元素的操作将会被阻塞</p><p>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</p><p>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</p><h2 id="2、阻塞队列的用处"><a href="#2、阻塞队列的用处" class="headerlink" title="2、阻塞队列的用处"></a>2、阻塞队列的用处</h2><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p><p>为什么需要BlockingQueue<br>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p><p>有的时候需要线程进行阻塞，比如海底捞 候客区 一直等里面的空位置</p><h2 id="3、架构梳理-种类分析"><a href="#3、架构梳理-种类分析" class="headerlink" title="3、架构梳理 种类分析"></a>3、架构梳理 种类分析</h2><p>BlockingQueue是Queue下的一个接口，</p><img src="/2020/04/16/JUC/批注 2020-02-22 134700.png" style="zoom:67%;"><p>而具体的实现类有以下7个（红色的具体掌握）<br><img src="/2020/04/16/JUC/批注 2020-02-22 134813.png" style="zoom:120%;"></p><ul><li><font color="red">ArrayBlockingQueue：由数组结构组成的有界阻塞队列。</font></li><li><font color="red">LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</font></li><li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</li><li><font color="red">SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。</font></li><li>LinkedTransferQueue：由链表组成的无界阻塞队列。</li><li>LinkedBlockingDeque：由链表组成的双向阻塞队列。(Deque是Double Queue的意思)</li></ul><h2 id="4、BlockingQueue核心方法API"><a href="#4、BlockingQueue核心方法API" class="headerlink" title="4、BlockingQueue核心方法API"></a>4、BlockingQueue核心方法API</h2><img src="/2020/04/16/JUC/QQ截图20200222162827.png" style="zoom:80%;"><p>*<em>抛出异常 *</em></p><ul><li>当阻塞队列满时，再往队列里add插入元素会抛IllegalStateException:Queue full</li><li>当阻塞队列空时，再往队列里remove移除元素会抛NoSuchElementException</li></ul><p><strong>特殊值</strong></p><ul><li>插入方法，成功ture失败false</li><li>移除方法，成功返回出队列的元素，队列里没有就返回null</li></ul><p><strong>一直阻塞</strong></p><ul><li>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出</li><li>当阻塞队列空时，消费者线程试图从队列里take元素队列会一直阻塞消费者线程直到队列可用</li></ul><p><strong>超时退出</strong></p><ul><li>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</li></ul><h1 id="第十章-ThreadPool线程池"><a href="#第十章-ThreadPool线程池" class="headerlink" title="第十章 ThreadPool线程池"></a>第十章 ThreadPool线程池</h1><h2 id="1、为什么用线程池"><a href="#1、为什么用线程池" class="headerlink" title="1、为什么用线程池"></a>1、为什么用线程池</h2><p>例子：<br>10年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需要来回切换。<br>现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。</p><p>线程池的优势：<br>线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为：<font color="red">线程复用  控制最大并发数 管理线程。</font></p><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h2 id="2、线程池如何使用"><a href="#2、线程池如何使用" class="headerlink" title="2、线程池如何使用"></a>2、线程池如何使用</h2><h3 id="1-、架构说明"><a href="#1-、架构说明" class="headerlink" title="(1)、架构说明"></a>(1)、架构说明</h3><p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类</p><img src="/2020/04/16/JUC/QQ截图20200222170202.png" style="zoom:80%;"><h3 id="2-、线程池三大实现"><a href="#2-、线程池三大实现" class="headerlink" title="(2)、线程池三大实现"></a>(2)、线程池三大实现</h3><ol><li>Executors.newFixedThreadPool(int) 执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程</li><li>Executors.newSingleThreadExecutor() 一个任务一个任务的执行，一池一线程</li><li>Executors.newCachedThreadPool() 执行很多短期异步任务，线程池根据需要创建新线程，但在先前构建的线程可用时将重用它们。可扩容，遇强则强  （这个类似于ArrayList，可以扩容，能根据线程使用情况自动分配最合适的线程数，任务来的慢，可以是一个线程，任务来的快，自动变成多线程）</li></ol><p>下面代码中的<code>Executors</code> 是线程池中的一个工具类，里面都是静态方法，类似于Arrays工具类，提供了不同线程池的创建方法，不用new了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//固定数的线程池，一池五线程，一个银行网点，5个受理业务的窗口</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个银行网点，1个受理业务的窗口</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool =  Executors.newSingleThreadExecutor();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个银行网点，可扩展受理业务的窗口</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool =  Executors.newCachedThreadPool();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"\t 办理业务"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、ThreadPoolExecutor底层原理"><a href="#3、ThreadPoolExecutor底层原理" class="headerlink" title="3、ThreadPoolExecutor底层原理"></a>3、ThreadPoolExecutor底层原理</h2><h3 id="1-、三大实现都是ThreadPoolExecutor"><a href="#1-、三大实现都是ThreadPoolExecutor" class="headerlink" title="(1)、三大实现都是ThreadPoolExecutor"></a>(1)、三大实现都是ThreadPoolExecutor</h3><p>看起来线程池三大实现有三个实现方法，但是抽丝剥茧，代码在下面，可以看出都是一个方法，不同的5个参数罢了，使用到了TimeUnit.MILLISECONDS和阻塞队列</p><p>初始化的线程数</p><p>newFixedThreadPool是自己设定</p><p>newSingleThreadExecutor恒为1</p><p>newCachedThreadPool的是0和 Integer.MAX_VALUE  还有阻塞队列上面都是LinkedBlockingQueue，而它是SynchronousQueue，当前线程被锁了，就创建新的，妙啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-、ThreadPoolExecutor-七大参数"><a href="#2-、ThreadPoolExecutor-七大参数" class="headerlink" title="(2)、ThreadPoolExecutor 七大参数"></a>(2)、ThreadPoolExecutor 七大参数</h3><p>不是看上面的参数，只有5个，点进ThreadPoolExecutor里面去，一共7大参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure><ol><li>corePoolSize：线程池中的常驻核心线程数</li><li>maximumPoolSize：线程池中能够容纳同时执行的最大线程数，<font color="red">此值必须大于等于1</font></li><li>keepAliveTime：多余的空闲线程的存活时间当前池中线程数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止</li><li>unit：keepAliveTime的单位 </li><li>workQueue：阻塞任务队列，被提交但尚未被执行的任务</li><li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，<font color="red">一般默认的即可</font></li><li>handler：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略</li></ol><p>拒绝策略下面会详讲</p><p>上面的三大实现都是指定1<del>5的内容，6</del>7采用默认即可</p><h3 id="3-、线程池底层工作原理"><a href="#3-、线程池底层工作原理" class="headerlink" title="(3)、线程池底层工作原理"></a>(3)、线程池底层工作原理</h3><img src="/2020/04/16/JUC/QQ截图20200222175107.png" style="zoom: 200%;"><ol><li>在创建了线程池后，开始等待请求。</li><li>当调用execute()方法添加一个请求任务时，线程池会做出如下判断：<ul><li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</li><li>如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</li></ul></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：<ul><li>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。</li><li>所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</li></ul></li></ol><h3 id="4-、线程池的拒绝策略"><a href="#4-、线程池的拒绝策略" class="headerlink" title="(4)、线程池的拒绝策略"></a>(4)、线程池的拒绝策略</h3><h2 id="4、手写线程池"><a href="#4、手写线程池" class="headerlink" title="4、手写线程池"></a>4、手写线程池</h2><h3 id="1-、超级大坑"><a href="#1-、超级大坑" class="headerlink" title="(1)、超级大坑"></a>(1)、超级大坑</h3><p>在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？超级大坑</p><p><strong><font color="red">答案是一个都不用，我们工作中只能使用自定义的</font></strong>    Executors中JDK已经给你提供了，为什么不用？</p><p>阿里巴巴Java开发手册中明确写出不允许使用 Executors 去创建</p><p><img src="/2020/04/16/JUC/QQ%E6%88%AA%E5%9B%BE20200222181114.png" alt></p><h3 id="2-、手写线程池"><a href="#2-、手写线程池" class="headerlink" title="(2)、手写线程池"></a>(2)、手写线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">2</span>,  <span class="comment">//corePoolSize：线程池中的常驻核心线程数</span></span><br><span class="line">        Runtime.getRuntime().availableProcessors(), <span class="comment">//maximumPoolSize 最大线程数</span></span><br><span class="line">        <span class="number">3</span>,  <span class="comment">//存活时间</span></span><br><span class="line">        TimeUnit.SECONDS, <span class="comment">//存活时间单位</span></span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>),  <span class="comment">//阻塞任务队列</span></span><br><span class="line">        Executors.defaultThreadFactory(),   <span class="comment">//默认线程工厂</span></span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());  <span class="comment">//拒绝策略</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">"\t办理业务"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中最大线程数应当和本机线程数一致？</p><p>阻塞任务队列初始化的时候一定要复制，默认的话，直接就是Integer最大值 21亿多了，没用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中手写的线程池最大可容纳任务为最大线程数+阻塞任务队列容量，这个线程池是3+5=8，超过8个，就使用拒绝策略</p><h4 id="合理配置线程池的最大数量"><a href="#合理配置线程池的最大数量" class="headerlink" title="合理配置线程池的最大数量"></a>合理配置线程池的最大数量</h4><ul><li><p>CPU密集型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());<span class="comment">//查看CPU核数</span></span><br></pre></td></tr></table></figure><p>一般CPU密集型的都是CPU核数+1,8核CPU配9个</p></li><li><p>IO密集型</p></li></ul><ol><li>IO密集型任务 可以使用稍大的线程池，一般为2*CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。混合型任务 可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。 因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</li><li><img src="/2020/04/16/JUC/%E5%9B%BE%E5%83%8F.bmp" alt></li></ol><p>8/(1-0.9)=80</p><p>下面详解拒绝策略</p><h3 id="3-、拒绝策略"><a href="#3-、拒绝策略" class="headerlink" title="(3)、拒绝策略"></a>(3)、拒绝策略</h3><p>等待队列已经排满了，再也塞不下新任务了同时，线程池中的max线程也达到了，无法继续为新任务服务。这个是时候我们就需要拒绝策略机制合理的处理这个问题。</p><p>JDK内置了4种拒绝策略</p><ol><li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.RejectedExecutionException: Task test.MyThreadPoolDemo.MyPoolDemo$$Lambda$<span class="number">1</span>/<span class="number">1096979270</span>@<span class="number">7</span>cca494b rejected from java.util.concurrent.ThreadPoolExecutor@<span class="number">7</span>ba4f24f[Running, pool size = <span class="number">4</span>, active threads = <span class="number">4</span>, queued tasks = <span class="number">5</span>, completed tasks = <span class="number">0</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。这里直接返回给了main线程，从哪来，回哪去</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 办理业务</span><br></pre></td></tr></table></figure><ol start="3"><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。</li></ol><p>只办理了9个，第10个被抛弃了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 办理业务</span><br></pre></td></tr></table></figure><ol start="4"><li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。和上面的DiscardOldestPolicy差不多</li></ol><p>这4种拒绝策略均实现了RejectedExecutionHandle接口，可以直接使用</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSe </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>设计模式就像一本书的目录，会起到提纲挈领的作用。<br>但是光靠目录，是无法完全掌握这本书的。<br>当我们看完这本书，再回过头来看看这个目录，会觉得这个目录的总结挺到位的。</p><p>后面我们自己写书的时候，可以参考前一本书的目录大纲的方式，高效完成一部书。</p><p>总之，没有编码经验，初学设计模式，<strong>囫囵吞枣即可</strong>，后面有一定编码经验，<strong>再细细回味</strong>。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p><h1 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h1><p>​        所谓类的单例设计模式，就是 采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，<br>并且该类只提供一个取得其对象实例的方法(静态方法)。<br>​        比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。</p><ul><li><p><font color="red">饿汉式( 静态常量) </font>      饿汉式 通过反射或者序列化会破坏单例？</p></li><li><p><font color="red">饿汉式（静态代码块） </font></p></li><li><p>懒汉式(线程不安全)</p></li><li><p>懒汉式(线程安全，同步方法)</p></li><li><p>懒汉式(线程安全，同步代码块)</p></li><li><p><font color="red">双重检查 </font></p></li><li><p><font color="red">静态内部类 </font></p></li><li><p><font color="red">枚举 </font></p><p><font color="red">（红色推荐使用）</font></p></li></ul><h2 id="1、八种实现方法"><a href="#1、八种实现方法" class="headerlink" title="1、八种实现方法"></a>1、八种实现方法</h2><h3 id="（1）、饿汉式（静态常量）"><a href="#（1）、饿汉式（静态常量）" class="headerlink" title="（1）、饿汉式（静态常量）"></a>（1）、饿汉式（静态常量）</h3><ol><li><p>步骤如下：<br>1) 构造器私有化 (防止 new )<br>2) 类的内部创建对象<br>3) 向外暴露一个静态的公共方法。getInstance<br>4) 代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line"><span class="comment">//        Singleton a=new Singleton();</span></span><br><span class="line"><span class="comment">//        System.out.println("a.hashCode=" + a.hashCode());</span></span><br><span class="line"></span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 构造器私有化, 外部能 new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="补：构造器私有化"><a href="#补：构造器私有化" class="headerlink" title="补：构造器私有化"></a>补：构造器私有化</h4><p>构造方法是私有的，则意味着无法从除自身之外的任何类访问它。这是Java提供的访问控制机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton() ;    <span class="comment">// 在内部产生本类的实例化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;        <span class="comment">// 将构造方法进行了封装，私有化    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!!!"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo04</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Singleton s1 = <span class="keyword">null</span> ;    <span class="comment">// 声明对象</span></span><br><span class="line">        s1 = Singleton.instance ;    <span class="comment">// 通过类取得实例化对象</span></span><br><span class="line">        s1.print() ;        <span class="comment">// 调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">运行结果：hello world！！</span><br></pre></td></tr></table></figure><h4 id="优缺点说明："><a href="#优缺点说明：" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。<br>2) 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则<br>会造成内存的浪费<br>3) 这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大<br>多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静<br>态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果<br><strong><font color="red">4) 结论：这种单例模式可用，可能造成内存浪费,不管有没有使用，反正就加载了，资源浪费</font></strong></p><h3 id="（2）、饿汉式（静态代码块）"><a href="#（2）、饿汉式（静态代码块）" class="headerlink" title="（2）、饿汉式（静态代码块）"></a>（2）、饿汉式（静态代码块）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 构造器私有化, 外部能 new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在静态代码块中，创建单例对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点说明：-1"><a href="#优缺点说明：-1" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了<strong>静态代码块</strong>中，也是在类装载的时候，就执<br>行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。<br><strong><font color="red">2) 结论：这种单例模式可用，但是可能造成内存浪费</font></strong></p><p><strong>饿汉式：都是在类加载的时候产生这个类的实例，只是实现方法有些许差异</strong></p><h3 id="（3）、懒汉式-线程不安全"><a href="#（3）、懒汉式-线程不安全" class="headerlink" title="（3）、懒汉式(线程不安全)"></a>（3）、懒汉式(线程不安全)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance，即懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点说明：-2"><a href="#优缺点说明：-2" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 起到了 <strong>Lazy Loading</strong> 的效果，但是只能在单线程下使用。<br>2) 如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过<br>了这个判断语句，这时便会 产生多个实例。所以在多线程环境下不可使用这种方式<br><strong><font color="red">3) 结论：在实际开发中， 不要使用这种方式.</font></strong></p><h3 id="（4）、懒汉式-线程安全，同步方法"><a href="#（4）、懒汉式-线程安全，同步方法" class="headerlink" title="（4）、懒汉式(线程安全，同步方法)"></a>（4）、懒汉式(线程安全，同步方法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance，即懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补：synchronized"><a href="#补：synchronized" class="headerlink" title="补：synchronized"></a>补：synchronized</h4><p>在并发编程中存在线程安全问题，主要原因有：1.存在共享数据 2.多线程共同操作共享数据。关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。</p><p><a href="https://blog.csdn.net/zjy15203167987/article/details/82531772" target="_blank" rel="noopener">【Java并发编程之深入理解】Synchronized的使用</a></p><h4 id="优缺点说明：-3"><a href="#优缺点说明：-3" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 解决了 线程安全问题<br>2) 效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行<br>一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。 方法进行同步效率太低。<br><strong><font color="red">3) 结论：在实际开发中， 不推荐使用这种方式</font></strong></p><h3 id="（5）、懒汉式-线程安全，同步代码块"><a href="#（5）、懒汉式-线程安全，同步代码块" class="headerlink" title="（5）、懒汉式(线程安全，同步代码块)"></a>（5）、懒汉式(线程安全，同步代码块)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance，即懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这种方法根本就是<font color="red">错误的写法</font>，仍然线程不安全，多个线程同时进入if语句还是没有办法锁住，会创建多个实例，这是一个错误示例，开发中有人曾这么干，面试可能问。<br>   <strong><font color="red">结论：在实际开发中， 不能使用这种方式</font></strong></p><h3 id="（6）、双重检查"><a href="#（6）、双重检查" class="headerlink" title="（6）、双重检查"></a>（6）、双重检查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">    <span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;   <span class="comment">//进来的时候检查一次</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;   <span class="comment">//进锁之后，再检查一次</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检锁虽然是线程安全的，会出现内部成员变量空指针异常，如果要使用，需将类实例用volatile修饰</p><h4 id="补：volatile"><a href="#补：volatile" class="headerlink" title="补：volatile"></a>补：volatile</h4><p>在并发编程中存在线程安全问题，主要原因有：1.存在共享数据 2.多线程共同操作共享数据。关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。</p><p><a href="https://www.jianshu.com/p/b05e4da39de9" target="_blank" rel="noopener">volatile详解</a></p><h4 id="优缺点说明：-4"><a href="#优缺点说明：-4" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这<br>样就可以保证线程安全了。<br>2) 这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避<br>免的反复进行方法同步.<br><strong>3) 线程安全； 延迟加载； 效率较高</strong><br><strong><font color="red">4) 结论：在实际开发中， 推荐使用这种单例设计模式。</font></strong></p><h3 id="（7）、静态内部类"><a href="#（7）、静态内部类" class="headerlink" title="（7）、静态内部类"></a>（7）、静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，直接返回 SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点说明：-5"><a href="#优缺点说明：-5" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。<br>2) 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才<br>会装载 SingletonInstance 类，从而完成 Singleton 的实例化。<br>3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行<br>初始化时，别的线程是无法进入的。<br>4) 优点： 避免了线程不安全，利用 静态内部类特点实现延迟加载，效率高<br><strong><font color="red">5) 结论：在实际开发中， 推荐使用这种单例设计模式。</font></strong></p><h3 id="（8）、枚举"><a href="#（8）、枚举" class="headerlink" title="（8）、枚举"></a>（8）、枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.INSTANCE;</span><br><span class="line">        Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance2.hashCode());</span><br><span class="line">        instance.sayOK();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE; <span class="comment">//属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ok~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点说明：-6"><a href="#优缺点说明：-6" class="headerlink" title="优缺点说明："></a><strong>优缺点说明：</strong></h4><p>1) 这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建<br>新的对象。<br>2) 这种方式是 Effective Java  作者 Josh Bloch  提倡的方式<br>3) 枚举真正实现了单例，把反序列化和反射创建第二对象的路都堵死了！<br><strong><font color="red">4) 结论：在实际开发中， 推荐使用这种单例设计模式。</font></strong></p><h2 id="2、单例模式在-JDK-应用的源码分析"><a href="#2、单例模式在-JDK-应用的源码分析" class="headerlink" title="2、单例模式在 JDK 应用的源码分析"></a>2、单例模式在 JDK 应用的源码分析</h2><p> 单例模式在 JDK 应用的源码分析</p><p>  我们 JDK 中，java.lang.Runtime 就是经典的单例模式(饿汉式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK源码 Runtime类（局部）使用  饿汉式（静态常量）进行实现单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the runtime object associated with the current Java application.</span></span><br><span class="line"><span class="comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span></span><br><span class="line"><span class="comment">     * methods and must be invoked with respect to the current runtime object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span></span><br><span class="line"><span class="comment">     *          Java application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Don't let anyone else instantiate this class */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、单例模式注意事项和细节说明"><a href="#3、单例模式注意事项和细节说明" class="headerlink" title="3、单例模式注意事项和细节说明"></a>3、单例模式注意事项和细节说明</h2><ol><li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使<br>用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而<strong>不是使用 new</strong></li><li>单例模式 使用的场景：需要 频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：<strong>重量级</strong><br><strong>对象</strong>)，但又经常用到的对象、 工具类对象、频繁访问数据库或文件的对象(比如 <strong>数据源</strong>、<strong>session  工厂</strong>等)</li></ol><h1 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h1><h2 id="1、简单工厂模式"><a href="#1、简单工厂模式" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h2><h3 id="1-、看一个具体的需求"><a href="#1-、看一个具体的需求" class="headerlink" title="(1)、看一个具体的需求"></a>(1)、看一个具体的需求</h3><p>​    看一个披萨的项目：要便于披萨种类的扩展，要便于维护</p><ol><li><p>披萨的种类很多(比如 GreekPizz、CheesePizz 等)</p></li><li><p>披萨的制作有 prepare，bake, cut, box</p></li><li><p>完成披萨店订购功能。</p></li></ol><h3 id="2-、使用传统的方式来完成"><a href="#2-、使用传统的方式来完成" class="headerlink" title="(2)、使用传统的方式来完成"></a>(2)、使用传统的方式来完成</h3><h4 id="1-、UML类图分析"><a href="#1-、UML类图分析" class="headerlink" title="1)、UML类图分析"></a>1)、UML类图分析</h4><p>这样设计耦合性很高，一个orderPizza类也依赖了具体的实现GreekPizza和CheessPizza，如果增加新的披萨种类，会有更多的依赖，<strong>违反了OCP原则</strong>。</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200116163455.png" style="zoom:80%;"><h4 id="2-、关键代码"><a href="#2-、关键代码" class="headerlink" title="2)、关键代码"></a>2)、关键代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">   String orderType; <span class="comment">// 订购披萨的类型</span></span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      orderType = getType();</span><br><span class="line">       <span class="comment">//这里每次增加新的种类披萨都要修改代码</span></span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span> (orderType.equals(<span class="string">"greek"</span>)) &#123;</span><br><span class="line">         pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">         pizza.setName(<span class="string">" 希腊披萨 "</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">         pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">         pizza.setName(<span class="string">" 奶酪披萨 "</span>);</span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//输出pizza 制作过程</span></span><br><span class="line">      pizza.prepare();</span><br><span class="line">      pizza.bake();</span><br><span class="line">      pizza.cut();</span><br><span class="line">      pizza.box();</span><br><span class="line">   &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">      System.out.println(<span class="string">"input pizza 种类:"</span>);</span><br><span class="line">      String str = strin.readLine();</span><br><span class="line">      <span class="keyword">return</span> str;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-、传统的方式的优缺点"><a href="#3-、传统的方式的优缺点" class="headerlink" title="3)、传统的方式的优缺点"></a>3)、传统的方式的优缺点</h4><ol><li><p>优点是比较好理解，简单易操作。</p></li><li><p>缺点是违反了设计模式的 ocp  原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</p></li><li><p>比如我们这时 要新增加一个 Pizza  的种类(Pepper  披萨)，我们需要做如下修改.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (orderType.equals(<span class="string">"greek"</span>)) &#123;</span><br><span class="line">   pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">   pizza.setName(<span class="string">" 希腊披萨 "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">   pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">   pizza.setName(<span class="string">" 奶酪披萨 "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) &#123;</span><br><span class="line">   pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">   pizza.setName(<span class="string">"胡椒披萨"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们增加一个 Pizza 类，只要是订购 Pizza 的代码都需要修改.</p></li><li><p>改进的思路分析<br>分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza的代码，往往有多处。<br>思路： <strong>把创建 Pizza  对象封装到一个类中</strong> ， <strong>这样我们有新的 Pizza  种类时</strong>， 只需要修改该类就可，其它有创建到 Pizza<br>对象的代码就不需要修改了.-&gt;  简单工厂模式</p></li></ol><h3 id="3-、简单工厂基本介绍"><a href="#3-、简单工厂基本介绍" class="headerlink" title="(3)、简单工厂基本介绍"></a>(3)、简单工厂基本介绍</h3><p>1) 简单工厂模式是属于 <strong>创建型模式</strong>，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品<br>类的实例。简单工厂模式是 工厂模式家族中<strong>最简单实用的模式</strong><br>2) 简单工厂模式：定义了一个创建对象的类，由<strong>这个类来 封装实例化对象的行为(代码)</strong><br>3) 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.</p><h3 id="4-、简单工厂实现"><a href="#4-、简单工厂实现" class="headerlink" title="(4)、简单工厂实现"></a>(4)、简单工厂实现</h3><h4 id="1-、UML类图分析-1"><a href="#1-、UML类图分析-1" class="headerlink" title="1)、UML类图分析"></a>1)、UML类图分析</h4><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200116170558.png" style="zoom:80%;"><p>####2)、关键代码（普通方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个简单工厂对象</span></span><br><span class="line">SimpleFactory simpleFactory;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">   setFactory(simpleFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">   String orderType = <span class="string">""</span>; <span class="comment">//用户输入的</span></span><br><span class="line">   <span class="keyword">this</span>.simpleFactory = simpleFactory; <span class="comment">//设置简单工厂对象</span></span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      orderType = getType();</span><br><span class="line">      pizza = <span class="keyword">this</span>.simpleFactory.createPizza(orderType);</span><br><span class="line">      <span class="comment">//输出pizza</span></span><br><span class="line">      <span class="keyword">if</span>(pizza != <span class="keyword">null</span>) &#123; <span class="comment">//订购成功</span></span><br><span class="line">         pizza.prepare();</span><br><span class="line">         pizza.bake();</span><br><span class="line">         pizza.cut();</span><br><span class="line">         pizza.box();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">" 订购披萨失败 "</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码还可以升级为下面一种静态方法，不用new SimpleFactory实例，直接就可以调用。</p><p>工厂模式，<strong>工厂一般都有很多地方调用。一般要配合单例模式来进行使用。</strong></p><h4 id="3-、关键代码（改成静态方法）"><a href="#3-、关键代码（改成静态方法）" class="headerlink" title="3)、关键代码（改成静态方法）"></a>3)、关键代码（改成静态方法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderPizza2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      orderType = getType();</span><br><span class="line">      pizza = SimpleFactory.createPizza2(orderType);</span><br><span class="line">      <span class="comment">// 输出pizza</span></span><br><span class="line">      <span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">// 订购成功</span></span><br><span class="line">         pizza.prepare();</span><br><span class="line">         pizza.bake();</span><br><span class="line">         pizza.cut();</span><br><span class="line">         pizza.box();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">" 订购披萨失败 "</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       每一个OrderPizza去使用SimpleFactory时，只需要用createPizza2(创建对象)方法即可，不需要关注里面的实现细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleFactory里面的createPizza2方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title">createPizza2</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">    Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(<span class="string">"使用简单工厂模式2"</span>);</span><br><span class="line">    <span class="keyword">if</span> (orderType.equals(<span class="string">"greek"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">        pizza.setName(<span class="string">" 希腊披萨 "</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        pizza.setName(<span class="string">" 奶酪披萨 "</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">        pizza.setName(<span class="string">"胡椒披萨"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-、简单工厂优缺点"><a href="#5-、简单工厂优缺点" class="headerlink" title="(5)、简单工厂优缺点"></a>(5)、简单工厂优缺点</h3><p><strong>优点：</strong></p><ul><li>将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；</li><li>把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。</li></ul><p><strong>缺点：</strong></p><ul><li>工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；</li><li>违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</li><li>简单工厂模式由于使用了静态工厂方法，<strong>静态方法不能被继承和重写</strong>，会造成工厂角色无法形成基于继承的等级结构。</li></ul><h3 id="6-、-应用场景"><a href="#6-、-应用场景" class="headerlink" title="(6)、 应用场景"></a>(6)、 应用场景</h3><p>在了解了优缺点后，我们知道了简单工厂模式的应用场景：</p><ul><li>客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；</li><li>当工厂类负责创建的对象（具体产品）比较少时。</li></ul><h2 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h2><h3 id="1-、一个新的需求"><a href="#1-、一个新的需求" class="headerlink" title="(1)、一个新的需求"></a>(1)、一个新的需求</h3><p>披萨项目新的需求：客户在点披萨时，可以点 不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或<br>者是伦敦的奶酪 pizza、伦敦的胡椒 pizza。</p><ul><li>思路 1：使用 简单工厂模式，创建 不同的简单工厂类，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等。从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好。不停的创建SimpleFactory类，会有类爆炸的问题。</li><li>思路 2：使用工厂方法模式</li></ul><h3 id="2-、工厂方法模式介绍"><a href="#2-、工厂方法模式介绍" class="headerlink" title="(2)、工厂方法模式介绍"></a>(2)、工厂方法模式介绍</h3><ol><li>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。</li><li>工厂方法模式： 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类</li></ol><h3 id="3-、工厂方法模式应用案例"><a href="#3-、工厂方法模式应用案例" class="headerlink" title="(3)、工厂方法模式应用案例"></a>(3)、工厂方法模式应用案例</h3><h4 id="1-披萨项目新的需求："><a href="#1-披萨项目新的需求：" class="headerlink" title="1) 披萨项目新的需求："></a>1) 披萨项目新的需求：</h4><p>客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza</p><h4 id="2-UML类图分析"><a href="#2-UML类图分析" class="headerlink" title="2) UML类图分析"></a>2) UML类图分析</h4><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200116192605.png" style="zoom:80%;"><p>说白了就是一个大工厂分解成若干个小工厂，由子类决定要实例化的类</p><h4 id="3-关键代码"><a href="#3-关键代码" class="headerlink" title="3)关键代码"></a>3)关键代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String loc = <span class="string">"bj"</span>;</span><br><span class="line">      <span class="keyword">if</span> (loc.equals(<span class="string">"bj"</span>)) &#123;</span><br><span class="line">         <span class="comment">//创建北京口味的各种Pizza</span></span><br><span class="line">         <span class="keyword">new</span> BJOrderPizza();   <span class="comment">//原本一个大工厂，现在搞出不同的小工厂来了</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//创建伦敦口味的各种Pizza</span></span><br><span class="line">         <span class="keyword">new</span> LDOrderPizza();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BJOrderPizza类（其中的一个小工厂）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">      Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span>(orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">         pizza = <span class="keyword">new</span> BJCheesePizza();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) &#123;</span><br><span class="line">         pizza = <span class="keyword">new</span> BJPepperPizza();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> pizza;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LDOrderPizza类（其中的一个小工厂）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LDOrderPizza</span> <span class="keyword">extends</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function">Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">      Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span>(orderType.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">         pizza = <span class="keyword">new</span> LDCheesePizza();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">"pepper"</span>)) &#123;</span><br><span class="line">         pizza = <span class="keyword">new</span> LDPepperPizza();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> pizza;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-、工厂方法优缺点"><a href="#4-、工厂方法优缺点" class="headerlink" title="(4)、工厂方法优缺点"></a>(4)、工厂方法优缺点</h3><p><strong>优点：</strong></p><ul><li><p>更符合开-闭原则<br>新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</p><blockquote><p>简单工厂模式需要修改工厂类的判断逻辑</p></blockquote></li><li><p>符合单一职责原则<br>每个具体工厂类只负责创建对应的产品</p><blockquote><p>简单工厂中的工厂类存在复杂的switch逻辑判断</p></blockquote></li><li><p>不使用静态工厂方法，可以形成基于继承的等级结构。</p><blockquote><p>简单工厂模式的工厂类使用静态工厂方法</p></blockquote></li></ul><p><strong>缺点：</strong></p><ul><li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li><li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li><li>一个具体工厂只能创建一种具体产品</li></ul><p><strong>总结：</strong></p><p>工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</p><h3 id="5-、应用场景"><a href="#5-、应用场景" class="headerlink" title="(5)、应用场景"></a>(5)、应用场景</h3><p>在了解了优缺点后，总结了工厂方法模式的应用场景：</p><ul><li>当一个类不知道它所需要的对象的类时<br>在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；</li><li>当一个类希望通过其子类来指定创建对象时<br>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h2 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h2><h3 id="1-、基本介绍"><a href="#1-、基本介绍" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>抽象工厂模式：定义了一个 interface  用于创建相关或有依赖关系的对象簇，而无需指明具体的类</li><li>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</li><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</li><li>将工厂抽象成 两层，AbsFactory( 抽象工厂) 和  具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</li></ol><h3 id="2-、抽象工厂模式应用实例"><a href="#2-、抽象工厂模式应用实例" class="headerlink" title="(2)、抽象工厂模式应用实例"></a>(2)、抽象工厂模式应用实例</h3><h4 id="1）UML类图分析"><a href="#1）UML类图分析" class="headerlink" title="1）UML类图分析"></a>1）UML类图分析</h4><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200116200607.png" style="zoom: 67%;"><p> OrderPizza类中聚合AbsFactory接口（或抽象类），就代表聚合进去了BeiJing Orderpizza或London Orderpizza，这里可以进行选择实际子类的工厂究竟是哪一个。</p><h4 id="2）关键代码"><a href="#2）关键代码" class="headerlink" title="2）关键代码"></a>2）关键代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个抽象工厂模式的抽象层(接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line">   <span class="comment">//让下面的工厂子类来 具体实现</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BJFactory类实现AbsFactory接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这是工厂子类</span><br><span class="line">public class BJFactory implements AbsFactory &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public Pizza createPizza(String orderType) &#123;</span><br><span class="line">      System.out.println(&quot;~使用的是抽象工厂模式~&quot;);</span><br><span class="line">      Pizza pizza &#x3D; null;</span><br><span class="line">      if(orderType.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">         pizza &#x3D; new BJCheesePizza();</span><br><span class="line">      &#125; else if (orderType.equals(&quot;pepper&quot;))&#123;</span><br><span class="line">         pizza &#x3D; new BJPepperPizza();</span><br><span class="line">      &#125;</span><br><span class="line">      return pizza;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-、抽象工厂优缺点"><a href="#3-、抽象工厂优缺点" class="headerlink" title="(3)、抽象工厂优缺点"></a>(3)、抽象工厂优缺点</h3><p>  <strong>优点：</strong></p><ul><li>降低耦合<br> 抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；</li><li>更符合开-闭原则<br> 新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可</li></ul><blockquote><p>简单工厂模式需要修改工厂类的判断逻辑</p></blockquote><ul><li>符合单一职责原则<br> 每个具体工厂类只负责创建对应的产品</li></ul><blockquote><p>简单工厂中的工厂类存在复杂的switch逻辑判断</p></blockquote><ul><li>不使用静态工厂方法，可以形成基于继承的等级结构。</li></ul><blockquote><p>简单工厂模式的工厂类使用静态工厂方法</p></blockquote><hr><p><strong>缺点：</strong></p><p>抽象工厂模式很难支持新种类产品的变化。<br>这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。</p><p>如果实现要增加一个新的产品，在接口里面增加一个方法。这种直接修改抽象接口的做法，会导致其所有实现子类都需要进行修改，重写这个未实现的方法，<strong>违反了开闭原则</strong>。当然，如果这种修改是长期稳定的，那么也可以接受。</p><blockquote><p>对于新的产品族符合开-闭原则；对于新的产品种类不符合开-闭原则，这一特性称为开-闭原则的倾斜性。</p><p><strong>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦</strong>，抽象工厂模式的这种性质称为<strong>“开闭原则”的倾斜性</strong>。</p></blockquote><h3 id="4-、补充"><a href="#4-、补充" class="headerlink" title="(4)、补充"></a>(4)、补充</h3><p> 弹幕大神：</p><ul><li>这里要是换成上衣和裤子区别比较好，上衣工厂和裤子工厂都是抽象衣服工厂子类。</li><li>工厂方法就是父类已经实现了一个整合方法，子类直接继承；抽象工厂就是接口没有实现任何逻辑</li><li>继承是侵入性的 而且java是单继承，抽成接口，那么工厂类可以实现接口，不需要改变继承关系，目的就是拓展某各类功能</li></ul><p>这个披萨的案例其实讲的不是很好，配合网上资料，大概能明白，网上有几篇文章将的不错</p><p><a href="https://blog.csdn.net/u014727260/article/details/82560912" target="_blank" rel="noopener">CSDN：抽象工厂</a></p><p><a href="https://www.jianshu.com/p/7deb64f902db" target="_blank" rel="noopener">简书：抽象工厂模式（Abstract Factory）- 最易懂的设计模式解析</a></p><h2 id="4、工厂模式Java源码分析"><a href="#4、工厂模式Java源码分析" class="headerlink" title="4、工厂模式Java源码分析"></a>4、工厂模式Java源码分析</h2><h3 id="1-、JDK-中的-Calendar-类中，简单工厂模式"><a href="#1-、JDK-中的-Calendar-类中，简单工厂模式" class="headerlink" title="(1)、JDK 中的 Calendar 类中，简单工厂模式"></a>(1)、JDK 中的 Calendar 类中，简单工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// getInstance 是 Calendar 静态方法</span></span><br><span class="line">      Calendar cal = Calendar.getInstance();</span><br><span class="line">      <span class="comment">// 注意月份下标从0开始，所以取月份要+1</span></span><br><span class="line">      System.out.println(<span class="string">"年:"</span> + cal.get(Calendar.YEAR));</span><br><span class="line">      System.out.println(<span class="string">"月:"</span> + (cal.get(Calendar.MONTH) + <span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 Calendar cal = Calendar.getInstance(); 不是new出来的,而是通过getInstance（）一个静态方法得到对象，debug进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createCalendar(TimeZone.getDefault(),Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有设定时区和位置，这里直接回返回默认的对象，</p><p>继续debug进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Locale aLocale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CalendarProvider provider =</span><br><span class="line">        LocaleProviderAdapter.getAdapter(CalendarProvider<span class="class">.<span class="keyword">class</span>, <span class="title">aLocale</span>)</span></span><br><span class="line"><span class="class">                             .<span class="title">getCalendarProvider</span>()</span>;</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> provider.getInstance(zone, aLocale);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">            <span class="comment">// fall back to the default instantiation</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Calendar cal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">        String caltype = aLocale.getUnicodeLocaleType(<span class="string">"ca"</span>);</span><br><span class="line">        <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"buddhist"</span>:</span><br><span class="line">            cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"japanese"</span>:</span><br><span class="line">                cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"gregory"</span>:</span><br><span class="line">                cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cal == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aLocale.getLanguage() == <span class="string">"th"</span> &amp;&amp; aLocale.getCountry() == <span class="string">"TH"</span>) &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aLocale.getVariant() == <span class="string">"JP"</span> &amp;&amp; aLocale.getLanguage() == <span class="string">"ja"</span></span><br><span class="line">                   &amp;&amp; aLocale.getCountry() == <span class="string">"JP"</span>) &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中初始化Calendar cal = null;</p><p>然后通过switch使用不同工厂进行创建对象，使用了简单方法工厂模式，</p><p>最后return回去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Calendar cal = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">    String caltype = aLocale.getUnicodeLocaleType(<span class="string">"ca"</span>);</span><br><span class="line">    <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"buddhist"</span>:</span><br><span class="line">        cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"japanese"</span>:</span><br><span class="line">            cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"gregory"</span>:</span><br><span class="line">            cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-、JDK-中的-sql-Connection类中，抽象工厂模式"><a href="#2-、JDK-中的-sql-Connection类中，抽象工厂模式" class="headerlink" title="(2)、JDK 中的 sql.Connection类中，抽象工厂模式"></a>(2)、JDK 中的 sql.Connection类中，抽象工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connection</span>  <span class="keyword">extends</span> <span class="title">Wrapper</span>, <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"><span class="comment">//...    </span></span><br><span class="line">    <span class="comment">//返回普通的sql执行器</span></span><br><span class="line">        <span class="function">Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">//返回具有参数化预编译功能的sql执行器</span></span><br><span class="line">    <span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="comment">//返回可以执行存储过程的sql执行器</span></span><br><span class="line">        <span class="function">CallableStatement <span class="title">prepareCall</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;   </span><br><span class="line">    <span class="comment">//...         </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的注释就可以看出，这就是典型的抽象工厂接口，描述了不同的产品等级Statement、PreparedStatement、CallableStatement，它们都位于抽象接口Statement产品等级结构中。我们可以继续寻找该抽象工厂接口的实现类</p><p>这里就以Mysql为例，可以找到Mysql对这个工厂接口的实现类ConnectionImpl，ConnectionImpl并不是直接实现了java.sql.Connection,而是通过实现自己扩展的MySQLConnection接口，该接口也是间接继承了java.sql.Connection</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20180909172407.png" style="zoom:80%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionImpl</span> <span class="keyword">extends</span> <span class="title">ConnectionPropertiesImpl</span> <span class="keyword">implements</span> <span class="title">MySQLConnection</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"> <span class="keyword">public</span> java.sql.<span class="function">Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createStatement(DEFAULT_RESULT_SET_TYPE, DEFAULT_RESULT_SET_CONCURRENCY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> java.sql.<span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prepareStatement(sql, DEFAULT_RESULT_SET_TYPE, DEFAULT_RESULT_SET_CONCURRENCY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> java.sql.<span class="function">CallableStatement <span class="title">prepareCall</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prepareCall(sql, DEFAULT_RESULT_SET_TYPE, DEFAULT_RESULT_SET_CONCURRENCY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<code>createStatement</code>为例，跟踪其调用代码可以看到<strong>StatementImpl</strong>这个类就是实现了java.sql.Statement的具体产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.sql.<span class="function">Statement <span class="title">createStatement</span><span class="params">(<span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    checkClosed();</span><br><span class="line"></span><br><span class="line">    StatementImpl stmt = <span class="keyword">new</span> StatementImpl(getMultiHostSafeProxy(), <span class="keyword">this</span>.database);</span><br><span class="line">    stmt.setResultSetType(resultSetType);</span><br><span class="line">    stmt.setResultSetConcurrency(resultSetConcurrency);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-、Mybatis中的SqlSessionFactory类，抽象工厂模式"><a href="#3-、Mybatis中的SqlSessionFactory类，抽象工厂模式" class="headerlink" title="(3) 、Mybatis中的SqlSessionFactory类，抽象工厂模式"></a>(3) 、Mybatis中的SqlSessionFactory类，抽象工厂模式</h3><ul><li>mybatis中的SqlSessionFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@link</span> SqlSession&#125; out of a connection or a DataSource</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSessionFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">SqlSession <span class="title">openSession</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span></span>;</span><br><span class="line">  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(Connection connection)</span></span>;</span><br><span class="line">  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(TransactionIsolationLevel level)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType)</span></span>;</span><br><span class="line">  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType, <span class="keyword">boolean</span> autoCommit)</span></span>;</span><br><span class="line">  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level)</span></span>;</span><br><span class="line">  <span class="function">SqlSession <span class="title">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSessionFactory也是抽象工厂接口，Configuration和SqlSession都是在不同的产品等级上。通过IDEA工具可以通过UML图清晰得看到SqlSessionFactory的工厂实现类</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20180909180700.png" style="zoom: 67%;"><h2 id="5、工厂模式小结"><a href="#5、工厂模式小结" class="headerlink" title="5、工厂模式小结"></a>5、工厂模式小结</h2><ol><li><p>工厂模式的意义：<br>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项<br>目的扩展和维护性。</p></li><li><p>三种工厂模式 ：</p><p>(简单工厂模式、工厂方法模式、抽象工厂模式)</p></li><li><p>设计模式的依赖抽象原则 ：</p></li></ol><ul><li>创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。</li><li>不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)</li><li>不要覆盖基类中已经实现的方法。</li></ul><h1 id="三、原型模式"><a href="#三、原型模式" class="headerlink" title="三、原型模式"></a>三、原型模式</h1><h2 id="问题提出：克隆羊问题"><a href="#问题提出：克隆羊问题" class="headerlink" title="问题提出：克隆羊问题"></a>问题提出：克隆羊问题</h2><p>现在有一只羊 tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊 属性完全相同的 10<br>只羊。</p><h2 id="1、传统模式解决问题"><a href="#1、传统模式解决问题" class="headerlink" title="1、传统模式解决问题"></a>1、传统模式解决问题</h2><h3 id="1-UML类图分析"><a href="#1-UML类图分析" class="headerlink" title="(1)UML类图分析"></a>(1)UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117100134.png" style="zoom:80%;"><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="(2)代码实现"></a>(2)代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//传统的方法</span></span><br><span class="line">   Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">"tom"</span>, <span class="number">1</span>, <span class="string">"白色"</span>);</span><br><span class="line">   </span><br><span class="line">   Sheep sheep2 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">   Sheep sheep3 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">   Sheep sheep4 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">   Sheep sheep5 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">   System.out.println(sheep);</span><br><span class="line">   System.out.println(sheep2);</span><br><span class="line">   System.out.println(sheep3);</span><br><span class="line">   System.out.println(sheep4);</span><br><span class="line">   System.out.println(sheep5);</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-传统的方式的优缺点"><a href="#3-传统的方式的优缺点" class="headerlink" title="(3)传统的方式的优缺点"></a>(3)传统的方式的优缺点</h3><ol><li>优点是比较好理解，简单易操作。</li><li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li><li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活</li><li>改进的思路分析<br>思路：Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 =&gt;<strong><font color="red">原型模式</font></strong></li></ol><h2 id="2、原型模式"><a href="#2、原型模式" class="headerlink" title="2、原型模式"></a>2、原型模式</h2><h3 id="1-、基本介绍-1"><a href="#1-、基本介绍-1" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>原型模式(Prototype 模式)是指：用 原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li><li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li><li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即  <strong><font color="red">对象.clone()</font></strong></li><li>形象的理解：孙大圣拔出猴毛， 变出其它孙大圣</li></ol><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117103029.png" style="zoom: 80%;"><h3 id="2-、UML类图分析"><a href="#2-、UML类图分析" class="headerlink" title="(2)、UML类图分析"></a>(2)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117103209.png" style="zoom:80%;"><p><strong>原理结构图说明</strong></p><ol><li>Prototype : 原型类，声明一个克隆自己的接口</li><li>ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作</li><li>Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样)</li></ol><h3 id="3-、原型模式解决克隆羊问题"><a href="#3-、原型模式解决克隆羊问题" class="headerlink" title="(3)、原型模式解决克隆羊问题"></a>(3)、原型模式解决克隆羊问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"原型模式完成对象的创建"</span>);</span><br><span class="line">   Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">"tom"</span>, <span class="number">1</span>, <span class="string">"白色"</span>);</span><br><span class="line">   </span><br><span class="line">   Sheep sheep2 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">   Sheep sheep3 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">   Sheep sheep4 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">   Sheep sheep5 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line"></span><br><span class="line">   System.out.println(sheep +<span class="string">"sheep.hashCode "</span>+sheep.hashCode());</span><br><span class="line">   System.out.println(sheep2 +<span class="string">"sheep2.hashCode "</span>+sheep2.hashCode());</span><br><span class="line">   System.out.println(sheep3 +<span class="string">"sheep3.hashCode "</span>+sheep3.hashCode());</span><br><span class="line">   System.out.println(sheep4 +<span class="string">"sheep4.hashCode "</span>+sheep4.hashCode());</span><br><span class="line">   System.out.println(sheep5 +<span class="string">"sheep5.hashCode "</span>+sheep5.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">原型模式完成对象的创建</span><br><span class="line">Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep.hashCode <span class="number">1956725890</span></span><br><span class="line">Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep2.hashCode <span class="number">356573597</span></span><br><span class="line">Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep3.hashCode <span class="number">1735600054</span></span><br><span class="line">Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep4.hashCode <span class="number">21685669</span></span><br><span class="line">Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep5.hashCode <span class="number">2133927002</span></span><br></pre></td></tr></table></figure><h2 id="3、原型模式在-Spring-框架中源码分析"><a href="#3、原型模式在-Spring-框架中源码分析" class="headerlink" title="3、原型模式在 Spring 框架中源码分析"></a>3、原型模式在 Spring 框架中源码分析</h2><p>Spring 中原型 bean 的创建，就是原型模式的应用。</p><p>bean1.xml文件  scope=”prototype” 决定是单例还是多例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ioc"</span> <span class="attr">class</span>=<span class="string">"cn.lzw.ioc.User"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- &lt;bean id="ioc" class="cn.lzw.ioc.User" &gt;&lt;/bean&gt;  --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean1.xml"</span>);</span><br><span class="line"></span><br><span class="line">User user1=(User)context.getBean(<span class="string">"ioc"</span>);</span><br><span class="line">User user2=(User)context.getBean(<span class="string">"ioc"</span>);</span><br><span class="line">System.out.println(user1);</span><br><span class="line">System.out.println(user2);</span><br></pre></td></tr></table></figure><p>Debug追踪到<code>AbstractBeanFactory</code>的<code>protected &lt;T&gt; T doGetBean</code>时下列代码选择是单例还是原型（多例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">   sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">            <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">            <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">   <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">   Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      beforePrototypeCreation(beanName);</span><br><span class="line">      prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      afterPrototypeCreation(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117113334.png" style="zoom:80%;"><h2 id="4、深入讨论-浅拷贝和深拷贝"><a href="#4、深入讨论-浅拷贝和深拷贝" class="headerlink" title="4、深入讨论-浅拷贝和深拷贝"></a>4、深入讨论-浅拷贝和深拷贝</h2><h3 id="1-、浅拷贝的介绍"><a href="#1-、浅拷贝的介绍" class="headerlink" title="(1)、浅拷贝的介绍"></a>(1)、浅拷贝的介绍</h3><ol><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</li><li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行<br>引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成<br>员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li><li>前面我们克隆羊就是浅拷贝</li><li>浅拷贝是使用默认的 clone()方法来实现<br>sheep = (Sheep) super.clone();</li></ol><p>代码演示</p><p>Sheep羊实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> String color;</span><br><span class="line">   <span class="keyword">private</span> String address = <span class="string">"蒙古羊"</span>;</span><br><span class="line">   <span class="keyword">public</span> Sheep friend; <span class="comment">//是对象, 克隆是会如何处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//克隆该实例，使用默认的clone方法来完成</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sheep = (Sheep)<span class="keyword">super</span>.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sheep;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//省略了getset，tostring方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"原型模式完成对象的创建"</span>);</span><br><span class="line">   Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">"tom"</span>, <span class="number">1</span>, <span class="string">"白色"</span>);</span><br><span class="line"></span><br><span class="line">   Sheep sheep2 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">   Sheep sheep3 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">   Sheep sheep4 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">   Sheep sheep5 = (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line"></span><br><span class="line">   sheep.friend = <span class="keyword">new</span> Sheep(<span class="string">"jack"</span>, <span class="number">2</span>, <span class="string">"黑色"</span>);</span><br><span class="line">   System.out.println(<span class="string">"sheep2 ="</span> + sheep2 + <span class="string">"sheep2.friend="</span> + sheep2.friend.hashCode());</span><br><span class="line">   System.out.println(<span class="string">"sheep3 ="</span> + sheep3 + <span class="string">"sheep3.friend="</span> + sheep3.friend.hashCode());</span><br><span class="line">   System.out.println(<span class="string">"sheep4 ="</span> + sheep4 + <span class="string">"sheep4.friend="</span> + sheep4.friend.hashCode());</span><br><span class="line">   System.out.println(<span class="string">"sheep5 ="</span> + sheep5 + <span class="string">"sheep5.friend="</span> + sheep5.friend.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">sheep2 =Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep2.friend=<span class="number">1836019240</span></span><br><span class="line">sheep3 =Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep3.friend=<span class="number">1836019240</span></span><br><span class="line">sheep4 =Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep4.friend=<span class="number">1836019240</span></span><br><span class="line">sheep5 =Sheep [name=tom, age=<span class="number">1</span>, color=白色, address=蒙古羊]sheep5.friend=<span class="number">1836019240</span></span><br></pre></td></tr></table></figure><p>可以看到，这里friend属性是一个羊对象，并没有真正的克隆，只是把引用的地址给复制过去了。浅拷贝</p><p><font color="red"> <strong>默认的clone方法只会对基本的数据类型和字符串进行克隆（值传递），其他的复杂类型和对象只会进行引用传递</strong></font></p><h3 id="2-、深拷贝基本介绍"><a href="#2-、深拷贝基本介绍" class="headerlink" title="(2)、深拷贝基本介绍"></a>(2)、深拷贝基本介绍</h3><ol><li><p>复制对象的所有基本数据类型的成员变量值</p></li><li><p>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象<br>可达的所有对象。也就是说， 对象进行深拷贝要对整个对象( 包括对象的引用类型) 进行拷贝</p></li></ol><h3 id="3-、深拷贝实现"><a href="#3-、深拷贝实现" class="headerlink" title="(3)、深拷贝实现"></a>(3)、深拷贝实现</h3><h4 id="方式-1：重写-clone-方法来实现深拷贝"><a href="#方式-1：重写-clone-方法来实现深拷贝" class="headerlink" title="方式 1：重写 clone 方法来实现深拷贝"></a>方式 1：重写 clone 方法来实现深拷贝</h4><p>   说白了就是俄罗斯套娃，在每个用到的类中，<strong>再写一个<code>Clone</code>方法，一层套一层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">   <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <code>DeepProtoType</code>用到<code>DeepCloneableTarget</code>类，<code>DeepCloneableTarget</code>单独写一个Clone方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">   <span class="keyword">private</span> String cloneName;</span><br><span class="line">   <span class="keyword">private</span> String cloneClass;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.cloneName = cloneName;</span><br><span class="line">      <span class="keyword">this</span>.cloneClass = cloneClass;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有对象的继续引用，继续写下去即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   DeepProtoType p = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">   p.name = <span class="string">"宋江"</span>;</span><br><span class="line">   p.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">"大牛"</span>, <span class="string">"小牛"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//方式1 完成深拷贝</span></span><br><span class="line">   DeepProtoType p2 = (DeepProtoType) p.clone();</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"p.name="</span> + p.name + <span class="string">"p.deepCloneableTarget="</span> + p.deepCloneableTarget.hashCode());</span><br><span class="line">   System.out.println(<span class="string">"p2.name="</span> + p.name + <span class="string">"p2.deepCloneableTarget="</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">p.name=宋江p.deepCloneableTarget=<span class="number">1956725890</span></span><br><span class="line">p2.name=宋江p2.deepCloneableTarget=<span class="number">356573597</span></span><br></pre></td></tr></table></figure><h4 id="方式-2：通过-对象序列化实现深拷贝-推荐"><a href="#方式-2：通过-对象序列化实现深拷贝-推荐" class="headerlink" title="方式 2：通过 对象序列化实现深拷贝(推荐)"></a>方式 2：通过 对象序列化实现深拷贝(推荐)</h4><p>通过巧妙的<strong>IO</strong>流对象操作，将对象写出在写入，相当于文件的复制一份，得到了两个不同的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝 - 方式2 通过对象的序列化实现 (推荐)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建流对象</span></span><br><span class="line">   ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">   ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">   ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">   ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//序列化</span></span><br><span class="line">      bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">      oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">      System.out.println(<span class="string">"aaa"</span>+<span class="keyword">this</span>);</span><br><span class="line">      oos.writeObject(<span class="keyword">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span></span><br><span class="line">       </span><br><span class="line">      <span class="comment">//反序列化</span></span><br><span class="line">      bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">      ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">      DeepProtoType copyObj = (DeepProtoType)ois.readObject();</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">return</span> copyObj;</span><br><span class="line">       </span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//关闭流</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         bos.close();</span><br><span class="line">         oos.close();</span><br><span class="line">         bis.close();</span><br><span class="line">         ois.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">         e2.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">aaalzw.Prototype.deepclone1.DeepProtoType@<span class="number">74</span>a14482</span><br><span class="line">p.name=宋江p.deepCloneableTarget=<span class="number">856419764</span></span><br><span class="line">p2.name=宋江p2.deepCloneableTarget=<span class="number">1595428806</span></span><br></pre></td></tr></table></figure><h2 id="5、原型模式的注意事项和细节"><a href="#5、原型模式的注意事项和细节" class="headerlink" title="5、原型模式的注意事项和细节"></a>5、原型模式的注意事项和细节</h2><ol><li>创建新的对象比较复杂时，可以利用原型模式简化 对象的创建过程，同时也能够提高效率</li><li>不用重新初始化对象，而是 动态地获得对象运行时的状态</li><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li><li>在实现深克隆的时候可能需要比较复杂的代码</li><li><strong>缺点</strong>：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改<br>其源代码，<strong>违背了 ocp 原则</strong>，这点请同学们注意.</li></ol><h1 id="四、建造者模式"><a href="#四、建造者模式" class="headerlink" title="四、建造者模式"></a>四、建造者模式</h1><h2 id="问题提出：盖房项目需求"><a href="#问题提出：盖房项目需求" class="headerlink" title="问题提出：盖房项目需求"></a>问题提出：盖房项目需求</h2><ol><li>需要建房子：这一过程为打桩、砌墙、封顶</li><li>房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.</li><li>请编写程序，完成需求.</li></ol><h2 id="1、传统模式解决问题-1"><a href="#1、传统模式解决问题-1" class="headerlink" title="1、传统模式解决问题"></a>1、传统模式解决问题</h2><h3 id="1-、UML类图分析-2"><a href="#1-、UML类图分析-2" class="headerlink" title="(1)、UML类图分析"></a>(1)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117151539.png" style="zoom:80%;"><h3 id="2-、代码实现"><a href="#2-、代码实现" class="headerlink" title="(2)、代码实现"></a>(2)、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHouse</span> </span>&#123;</span><br><span class="line">   <span class="comment">//打地基</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//砌墙</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//封顶</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      buildBasic();</span><br><span class="line">      buildWalls();</span><br><span class="line">      roofed();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类比接口更好实现build(),可以去调用自己的方法，接口没法掉用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">AbstractHouse</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">" 普通房子打地基 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>CommonHouse</code>继承<code>AbstractHouse</code>类，重写3个抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">   commonHouse.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-、传统的方式的优缺点-1"><a href="#3-、传统的方式的优缺点-1" class="headerlink" title="(3)、传统的方式的优缺点"></a>(3)、传统的方式的优缺点</h3><ol><li><p>优点是比较好理解，简单易操作。</p></li><li><p>设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产<br>品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。</p></li><li><p>解决方案：将产品和产品建造过程解耦 =&gt; <font color="red"><strong>建造者模式.</strong></font></p></li></ol><h2 id="2、建造者模式"><a href="#2、建造者模式" class="headerlink" title="2、建造者模式"></a>2、建造者模式</h2><h3 id="1-、基本介绍-2"><a href="#1-、基本介绍-2" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>建造者模式（Builder Pattern )又叫生成器模式，是一种对象构建模式。它可以<br>将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方<br>法可以构造出不同表现（属性）的对象。</li><li>建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象<br>的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</li></ol><p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ%E6%88%AA%E5%9B%BE20200117153251.png" alt></p><p>比如说宝马汽车，用户只需要知道汽车由方向盘、轮胎、发动机构成，而不用知道方向盘、轮胎、发动机这些组件是怎么来的。</p><h3 id="2-、建造者模式的四个角色"><a href="#2-、建造者模式的四个角色" class="headerlink" title="(2)、建造者模式的四个角色"></a>(2)、建造者模式的四个角色</h3><ol><li><strong>Product （产品角色）：</strong> 一个具体的产品对象。</li><li><strong>Builder （抽象建造者）：</strong> 创建一个Product对象的各个部件指定的 接口/ 抽象类。（只需要指定大体的流程怎么搞，具体的实现细节并不管。）</li><li><strong>ConcreteBuilder （具体建造者）：</strong> 实现接口，构建和装配各个部件。（具体的细节由它实现）</li><li><strong>Director （指挥者）：</strong> 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</li></ol><h3 id="3-、UML类图分析"><a href="#3-、UML类图分析" class="headerlink" title="(3)、UML类图分析"></a>(3)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117155436.png" style="zoom:80%;"><h2 id="3、建造者模式解决盖房需求应用实例"><a href="#3、建造者模式解决盖房需求应用实例" class="headerlink" title="3、建造者模式解决盖房需求应用实例"></a>3、建造者模式解决盖房需求应用实例</h2><p>需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们<br>使用建造者模式(Builder Pattern)来完成。</p><h3 id="1-、UML类图分析-3"><a href="#1-、UML类图分析-3" class="headerlink" title="(1)、UML类图分析"></a>(1)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117160514.png" style="zoom:80%;"><h3 id="2-、代码实现-1"><a href="#2-、代码实现-1" class="headerlink" title="(2)、代码实现"></a>(2)、代码实现</h3><p><code>House</code>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String baise;</span><br><span class="line">   <span class="keyword">private</span> String wall;</span><br><span class="line">   <span class="keyword">private</span> String roofed;</span><br><span class="line">   <span class="comment">//...省略get，set，toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HouseBuilder</code>抽象类，聚合<code>House</code>实体类，定义三个建房的方法，最后返回。抽象类中抽象方法子类必须实现，普通方法没有强制要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象的建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> House house = <span class="keyword">new</span> House();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将建造的流程写好, 抽象的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//建造房子好， 将产品(房子) 返回</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> house;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CommonHouse</code>继承<code>HouseBuilder</code>抽象类，实现3个抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      house.setBaise(<span class="string">" 普通房子打地基5米"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      house.setWall(<span class="string">" 普通房子砌墙10cm "</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      house.setRoofed(<span class="string">" 普通房子屋顶 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HouseDirector</code>组合<code>HouseBuilder</code>，完成实际的房子创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指挥者，这里去指定制作流程，返回产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   HouseBuilder houseBuilder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//构造器传入 houseBuilder</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如何处理建造房子的流程，交给指挥者</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> House <span class="title">constructHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      houseBuilder.buildBasic();</span><br><span class="line">      houseBuilder.buildWalls();</span><br><span class="line">      houseBuilder.roofed();</span><br><span class="line">      <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Client</code>进行调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//盖普通房子</span></span><br><span class="line">      CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">      <span class="comment">//准备创建房子的指挥者</span></span><br><span class="line">      HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector(commonHouse);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//完成盖房子，返回产品(普通房子)</span></span><br><span class="line">      House house = houseDirector.constructHouse();</span><br><span class="line">      System.out.println(house);</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"--------------------------"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//盖高楼</span></span><br><span class="line">      HighBuilding highBuilding = <span class="keyword">new</span> HighBuilding();</span><br><span class="line">      <span class="comment">//重置建造者</span></span><br><span class="line">      houseDirector = <span class="keyword">new</span> HouseDirector(highBuilding);</span><br><span class="line">      house = houseDirector.constructHouse();</span><br><span class="line">      System.out.println(house);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、建造者模式在-JDK-的应用和源码分析"><a href="#4、建造者模式在-JDK-的应用和源码分析" class="headerlink" title="4、建造者模式在 JDK 的应用和源码分析"></a>4、建造者模式在 JDK 的应用和源码分析</h2><p><code>java.lang.StringBuilder</code> 中用到了建造者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"hello,world"</span>);</span><br><span class="line">        System.out.println(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>StringBuilder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br></pre></td></tr></table></figure><p>可以看到<code>StringBuilder</code>继承了抽象类<code>AbstractStringBuilder</code>，进入<code>AbstractStringBuilder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span></span></span><br></pre></td></tr></table></figure><p>可以看到<code>AbstractStringBuilder</code>实现了<code>Appendable</code>，进入<code>Appendable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Appendable</span> </span>&#123;</span><br><span class="line">    <span class="function">Appendable <span class="title">append</span><span class="params">(CharSequence csq)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function">Appendable <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function">Appendable <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Appendable</code>为接口，就三个方法</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117172909.png" style="zoom:80%;"><h3 id="源码中建造者模式角色分析"><a href="#源码中建造者模式角色分析" class="headerlink" title="源码中建造者模式角色分析"></a>源码中建造者模式角色分析</h3><ol><li><code>Appendable</code>接口定义了多个 append 方法(抽象方法), 即 <code>Appendable</code> 为抽象建造者, 定义了抽象方法</li><li><code>AbstractStringBuilder</code> 实现了 Appendable 接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化</li><li><code>StringBuilder</code>即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由<code>AbstractStringBuilder</code> 完成, 而 <code>StringBuilder</code> 继承了 <code>AbstractStringBuilder</code></li></ol><p>JDK实现的比设计模式正统思想更早，早期写JDK的人太牛逼了，在不经意间就使用到了一定的设计模式，但和现在所提出的标准的设计模式有些许不一样，思想大致相同，是一个变种的Builder建造者模式。</p><h2 id="5、建造者模式的注意事项和细节"><a href="#5、建造者模式的注意事项和细节" class="headerlink" title="5、建造者模式的注意事项和细节"></a>5、建造者模式的注意事项和细节</h2><ol><li><p>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可<br>以创建不同的产品对象</p></li><li><p>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具<br>体建造者， 用户使用不同的具体建造者即可得到不同的产品对象</p></li><li><p>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加晰，也更方便使用程序来控制创建过程</p></li><li><p>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭<br>原则”，举个例子</p><p>增加一个<code>OtherHouse</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      house.setBaise(<span class="string">" 其他房子打地基10米"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      house.setWall(<span class="string">" 其他房子砌墙20cm "</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      house.setRoofed(<span class="string">" 其他房子屋顶 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上了这个<code>OtherHouse</code>实体类后，所有代码都不需要变动，直接在<code>Client</code>拿来用即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//盖其他房子</span></span><br><span class="line">OtherHouse otherHouse = <span class="keyword">new</span> OtherHouse();</span><br><span class="line"><span class="comment">//重置建造者</span></span><br><span class="line">houseDirector = <span class="keyword">new</span> HouseDirector(otherHouse);</span><br><span class="line">house = houseDirector.constructHouse();</span><br><span class="line">System.out.println(house);</span><br></pre></td></tr></table></figure></li><li><p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<font color="red"><strong>如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</strong></font></p></li><li><p>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因<br>此在这种情况下，要考虑是否选择建造者模式.</p></li></ol><h2 id="6、-抽象工厂模式-VS-建造者模式"><a href="#6、-抽象工厂模式-VS-建造者模式" class="headerlink" title="6、 抽象工厂模式 VS 建造者模式"></a>6、 抽象工厂模式 VS 建造者模式</h2><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采<br>用抽象工厂模式不需要关心构建过程（过程已经指定好了），只关心什么产品由什么工厂生产即可。<strong>什么工厂给我提供产品</strong>。</p><p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品，<strong>什么流程给我提供产品</strong>。</p><p>确实很微妙，只可意会，不可言传，在实践中慢慢体会。。。。。。</p><h1 id="五、适配器设计模式"><a href="#五、适配器设计模式" class="headerlink" title="五、适配器设计模式"></a>五、适配器设计模式</h1><h2 id="1、实际问题导出"><a href="#1、实际问题导出" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="现实生活中的适配器例子"><a href="#现实生活中的适配器例子" class="headerlink" title="现实生活中的适配器例子"></a>现实生活中的适配器例子</h3><p>泰国插座用的是两孔的（欧标），可以买个多功能转换插头 (适配器) ，这样就可以使用了</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117213618.png" style="zoom:80%;"><h3 id="适配器模式基本介绍"><a href="#适配器模式基本介绍" class="headerlink" title="适配器模式基本介绍"></a>适配器模式基本介绍</h3><ol><li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示， 主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li><li>适配器模式属于<strong>结构型模式</strong></li><li><font color="red">主要分为三类：<strong>类适配器模式、对象适配器模式、接口适配器模式</strong></font></li></ol><h3 id="适配器模式工作原理"><a href="#适配器模式工作原理" class="headerlink" title="适配器模式工作原理"></a>适配器模式工作原理</h3><ol><li><p>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</p></li><li><p>从用户的角度看不到被适配者，是解耦的</p></li><li><p>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</p></li><li><p>用户收到反馈结果，感觉只是和目标接口交互，如图</p></li></ol><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117214313.png" style="zoom: 67%;"><h2 id="2、类适配器模式"><a href="#2、类适配器模式" class="headerlink" title="2、类适配器模式"></a>2、类适配器模式</h2><h3 id="1-、基本介绍-3"><a href="#1-、基本介绍-3" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><p>Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。</p><h3 id="2-、应用实例说明"><a href="#2-、应用实例说明" class="headerlink" title="(2)、应用实例说明"></a>(2)、应用实例说明</h3><p>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们<br>的目 dst(即 目标)是 5V 直流电</p><h3 id="3-、UML类图分析-1"><a href="#3-、UML类图分析-1" class="headerlink" title="(3)、UML类图分析"></a>(3)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117215410.png" style="zoom:80%;"><h3 id="4-、代码实现"><a href="#4-、代码实现" class="headerlink" title="(4)、代码实现"></a>(4)、代码实现</h3><p><code>Voltage220V</code>类提供220V电压</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">   <span class="comment">//输出220V的电压</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">      System.out.println(<span class="string">"电压="</span> + src + <span class="string">"伏"</span>);</span><br><span class="line">      <span class="keyword">return</span> src;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IVoltage5V</code>适配接口，必须要为接口才能让<code>VoltageAdapter</code>类同时继承和实现两个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VoltageAdapter</code>提供转换方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取到220V电压</span></span><br><span class="line">      <span class="keyword">int</span> srcV = output220V();</span><br><span class="line">      <span class="comment">//转成 5v</span></span><br><span class="line">      System.out.println(<span class="string">"开始转换"</span>);</span><br><span class="line">      <span class="keyword">int</span> dstV = srcV / <span class="number">44</span> ;</span><br><span class="line">      <span class="keyword">return</span> dstV;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Phone</code>提供充电方法，<code>IVoltage5V</code>为形参，调用时使用多态将<code>VoltageAdapter</code>传进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">   <span class="comment">//充电</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">"电压为5V, 可以充电~~"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">"电压大于5V, 不能充电~~"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">" === 类适配器模式 ===="</span>);</span><br><span class="line">   Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">   phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-、类适配器模式注意事项和细节"><a href="#5-、类适配器模式注意事项和细节" class="headerlink" title="(5)、类适配器模式注意事项和细节"></a>(5)、类适配器模式注意事项和细节</h3><ol><li><p>Java 是<strong>单继承机制</strong>，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性;</p></li><li><p>src 类的方法在 Adapter 中都会<strong>暴露出来</strong>，也增加了使用的成本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取到220V电压</span></span><br><span class="line">      <span class="keyword">int</span> srcV = output220V();</span><br></pre></td></tr></table></figure></li></ol><p>这里暴露了<code>output220V();</code>方法，如果src类中有很多方法，一个个调增加了使用的成本</p><ol start="3"><li>由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。</li></ol><p>所谓，祸兮福所倚，福兮祸所伏。。。。。。</p><h2 id="3、对象适配器模式"><a href="#3、对象适配器模式" class="headerlink" title="3、对象适配器模式"></a>3、对象适配器模式</h2><h3 id="1-、基本介绍-4"><a href="#1-、基本介绍-4" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配</li><li>根据“ 合成复用原则”，在系统中尽量使用 关联关系（聚合）来替代继承关系。</li><li>对象适配器模式是适配器模式常用的一种</li></ol><h3 id="2-、应用实例说明-1"><a href="#2-、应用实例说明-1" class="headerlink" title="(2)、应用实例说明"></a>(2)、应用实例说明</h3><p>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们<br>的目 dst(即目标)是 5V 直流电，使用<strong>对象适配器模式</strong>完成。</p><h3 id="3-、UML类图分析-2"><a href="#3-、UML类图分析-2" class="headerlink" title="(3)、UML类图分析"></a>(3)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117222715.png" style="zoom:80%;"><p>和上面的类适配器的UML图，就是<code>Voltage220V</code>和<code>VoltageAdapter</code>由继承转变为了聚合（由此<code>Client</code>也会多一个依赖<code>Voltage220V</code>）</p><h3 id="4-、代码实现-1"><a href="#4-、代码实现-1" class="headerlink" title="(4)、代码实现"></a>(4)、代码实现</h3><p>只写上变动的代码,<code>VoltageAdapter</code>设一个成员<code>Voltage220V</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span>  <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Voltage220V voltage220V; <span class="comment">// 关联关系-聚合</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//通过构造器，传入一个 Voltage220V 实例</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220v)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.voltage220V = voltage220v;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">null</span> != voltage220V) &#123;</span><br><span class="line">         <span class="keyword">int</span> src = voltage220V.output220V();<span class="comment">//获取220V 电压</span></span><br><span class="line">         System.out.println(<span class="string">"使用对象适配器，进行适配~~"</span>);</span><br><span class="line">         dst = src / <span class="number">44</span>;</span><br><span class="line">         System.out.println(<span class="string">"适配完成，输出的电压为="</span> + dst);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dst;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>phone.charging(new VoltageAdapter(new Voltage220V()));</code>里多<code>new Voltage220V()</code>,其他都是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">" === 对象适配器模式 ===="</span>);</span><br><span class="line">   Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">   phone.charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-、类适配器模式注意事项和细节-1"><a href="#5-、类适配器模式注意事项和细节-1" class="headerlink" title="(5)、类适配器模式注意事项和细节"></a>(5)、类适配器模式注意事项和细节</h3><ol><li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。<br>根据合成复用原则，使用<strong>聚合代替继承</strong>， 所以它解决了类适配器必须继承 src 的局限性问题，也<strong>不再要求 dst</strong><br><strong>必须是接口</strong>。</li><li><strong>使用成本更低，更灵活。</strong></li></ol><h2 id="4、接口适配器模式"><a href="#4、接口适配器模式" class="headerlink" title="4、接口适配器模式"></a>4、接口适配器模式</h2><h3 id="1-、基本介绍-5"><a href="#1-、基本介绍-5" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>一些书籍称为：适配器模式(DefaultAdapter Pattern)或 缺省适配器模式。</li><li>核心思路：当 不需要全部实现接口提供的方法时，可先 设计一个抽象类实现 接口，并为该接口中每个方法提供一个 默认实现（空方法），那么该 抽象类的子类可有选择地覆盖父类的某些方法来实现需求</li><li>适用于一个接口不想使用其所有的方法的情况。</li></ol><h3 id="2-、UML类图分析-1"><a href="#2-、UML类图分析-1" class="headerlink" title="(2)、UML类图分析"></a>(2)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200117225627.png" style="zoom:80%;"><h3 id="3-、代码实现"><a href="#3-、代码实现" class="headerlink" title="(3)、代码实现"></a>(3)、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbsAdapter</code>默认实现，空实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在AbsAdapter 我们将 Interface4 的方法进行默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">   <span class="comment">//默认实现，空实现</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验内部类，选择性重写要用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter() &#123;</span><br><span class="line">      <span class="comment">//只需要去覆盖我们 需要使用 接口方法</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"使用了m1的方法"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   absAdapter.m1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这个接口适配器有点瓜皮。。。。。。</p><h2 id="5、适配器模式在-SpringMVC-框架应用的源码剖析"><a href="#5、适配器模式在-SpringMVC-框架应用的源码剖析" class="headerlink" title="5、适配器模式在 SpringMVC 框架应用的源码剖析"></a>5、适配器模式在 SpringMVC 框架应用的源码剖析</h2><ol><li>SpringMvc 中的 HandlerAdapter, 就使用了适配器模式</li><li>SpringMVC 处理请求的流程回顾<img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118103630.png" style="zoom:80%;"></li><li>使用 HandlerAdapter 的原因分析:<br>可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller 方法，需要调用的时候就得不断是使用 if else 来进行判断是哪一种子类然后执行。那么如果后面要扩展Controller，就得修改原来的代码，这样违背了 OCP 原则。</li></ol><p>在<code>DispatcherServlet</code>里面研究，进入源码,有一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doDispatch</code>拿到浏览器传过来的HTTP请求地址，进行解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">   Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      processedRequest = checkMultipart(request);</span><br><span class="line">      multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">      <span class="comment">// 通过HandlerMapping来映射Controller</span></span><br><span class="line">      mappedHandler = getHandler(processedRequest);</span><br></pre></td></tr></table></figure><p>首先会创建<code>processedRequest</code>，这个<code>processedRequest</code>就是<code>request</code>,然后  <code>mappedHandler = getHandler(processedRequest);</code>拿到对应的控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">   noHandlerFound(processedRequest, response);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line"><span class="comment">//获取适配器</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">    <span class="comment">// 通过适配器调用controller的方法并返回ModelAndView</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到对应的控制器之后，先判断是否为空，然后通过<code>getHandlerAdapter(mappedHandler.getHandler());</code></p><p>拿到对应的适配器，不同的Handler要调用不同的适配器进行处理，追踪<code>getHandlerAdapter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="comment">//一个for循环，如果为真（这个请求我能处理，就返回了）</span></span><br><span class="line">   <span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Testing handler adapter ["</span> + ha + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line">         <span class="keyword">return</span> ha;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</span><br><span class="line">         <span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HandlerAdapter</code>是一个接口，继续追踪</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br></pre></td></tr></table></figure><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118094615.png" style="zoom:80%;"><p>HandlerAdapter 的实现子类使得每一种Controller有一种对应的适配器实现类，每种Controller 有不同的实现方式。</p><p>这看源码还是有点懵逼，下面手写一下，领会精神。</p><h2 id="6、手写-SpringMVC适配器"><a href="#6、手写-SpringMVC适配器" class="headerlink" title="6、手写 SpringMVC适配器"></a>6、手写 SpringMVC适配器</h2><h3 id="1-、UML类图分析-4"><a href="#1-、UML类图分析-4" class="headerlink" title="(1)、UML类图分析"></a>(1)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118100841.png" style="zoom:80%;"><h3 id="2-、代码实现-2"><a href="#2-、代码实现-2" class="headerlink" title="(2)、代码实现"></a>(2)、代码实现</h3><p>定义<code>HandlerAdapter</code>，然后<code>SimpleHandlerAdapter</code>,<code>HttpHandlerAdapter</code>,<code>AnnotationHandlerAdapter</code>分别实现<code>public boolean supports(Object handler);</code>和<code>public void handle(Object handler);</code>两个方法</p><p><code>supports</code>方法是判断当期传过来的请求我能不能处理，这里简单的使用<code>instanceof</code>类型判断</p><p><code>handle</code>方法调用对应 <code>Controller</code> 真正的<code>handle</code>方法进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///定义一个Adapter接口 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多种适配器类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">      ((SimpleController) handler).doSimplerHandler();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> SimpleController);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">      ((HttpController) handler).doHttpHandler();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpController);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">      ((AnnotationController) handler).doAnnotationHandler();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> AnnotationController);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多种Controller实现  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHttpHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"http..."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSimplerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"simple..."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnnotationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"annotation..."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DispatchServlet</code>讲究，先定义一个静态的空列表，把所有的<code>handlerAdapters</code>在构造器里给装载进去，<code>getHandler</code>遍历所有请求，能被<code>controller</code>（指定的）处理的就返回对象，最后使用<code>doDispatch()</code>进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;HandlerAdapter&gt; handlerAdapters = <span class="keyword">new</span> ArrayList&lt;HandlerAdapter&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DispatchServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      handlerAdapters.add(<span class="keyword">new</span> AnnotationHandlerAdapter());</span><br><span class="line">      handlerAdapters.add(<span class="keyword">new</span> HttpHandlerAdapter());</span><br><span class="line">      handlerAdapters.add(<span class="keyword">new</span> SimpleHandlerAdapter());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 此处模拟SpringMVC从request取handler的对象，</span></span><br><span class="line">      <span class="comment">// 适配器可以获取到希望的Controller</span></span><br><span class="line">       HttpController controller = <span class="keyword">new</span> HttpController();</span><br><span class="line">      <span class="comment">// AnnotationController controller = new AnnotationController();</span></span><br><span class="line">      <span class="comment">//SimpleController controller = new SimpleController();</span></span><br><span class="line">      <span class="comment">// 得到对应适配器</span></span><br><span class="line">      HandlerAdapter adapter = getHandler(controller);</span><br><span class="line">      <span class="comment">// 通过适配器执行对应的controller对应方法</span></span><br><span class="line">      adapter.handle(controller);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HandlerAdapter <span class="title">getHandler</span><span class="params">(Controller controller)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//遍历：根据得到的controller(handler), 返回对应适配器</span></span><br><span class="line">      <span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">         <span class="keyword">if</span> (adapter.supports(controller)) &#123;</span><br><span class="line">            <span class="keyword">return</span> adapter;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> DispatchServlet().doDispatch(); <span class="comment">// http...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个设计模式完全遵守OCP原则，测试一把，加一个新的<code>OtherController</code>和<code>OtherHandlerAdapter</code>,只需要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.加入列表中</span></span><br><span class="line">handlerAdapters.add(<span class="keyword">new</span> OtherHandlerAdapter());</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.直接用即可</span></span><br><span class="line">OtherController controller=<span class="keyword">new</span> OtherController();</span><br></pre></td></tr></table></figure><h3 id="3-、说明"><a href="#3-、说明" class="headerlink" title="(3)、说明"></a><strong>(3)、说明</strong></h3><p>• Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类<br>• 适配器代替controller执行相应的方法<br>• 扩展Controller 时，只需要增加一个适配器类就完成了SpringMVC的扩展了,<br>• <strong><font color="red">这就 是设计模式的力量</font></strong></p><h2 id="7、适配器模式的注意事项和细节"><a href="#7、适配器模式的注意事项和细节" class="headerlink" title="7、适配器模式的注意事项和细节"></a>7、适配器模式的注意事项和细节</h2><ol><li><p>三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来<br>命名的。</p><ul><li>类适配器：以类给到，在Adapter里，就是将src当做类，继承</li><li>对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有</li><li>接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现</li></ul></li><li><p>Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。</p></li><li><p>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</p></li></ol><h1 id="六、桥接设计模式"><a href="#六、桥接设计模式" class="headerlink" title="六、桥接设计模式"></a>六、桥接设计模式</h1><h2 id="1、实际问题导出-1"><a href="#1、实际问题导出-1" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="手机操作问题"><a href="#手机操作问题" class="headerlink" title="手机操作问题"></a>手机操作问题</h3><p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118104421.png" style="zoom:80%;"><h3 id="传统方案解决手机操作问题"><a href="#传统方案解决手机操作问题" class="headerlink" title="传统方案解决手机操作问题"></a>传统方案解决手机操作问题</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118104511.png" style="zoom:90%;"><h3 id="传统方案弊端分析"><a href="#传统方案弊端分析" class="headerlink" title="传统方案弊端分析"></a>传统方案弊端分析</h3><ol><li><p>扩展性问题(类爆炸)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</p></li><li><p>违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.</p></li><li><p><strong>解决方案-使用桥接模式</strong></p></li></ol><h2 id="2、桥接模式-Bridge"><a href="#2、桥接模式-Bridge" class="headerlink" title="2、桥接模式(Bridge)"></a>2、桥接模式(Bridge)</h2><h3 id="1-、基本介绍-6"><a href="#1-、基本介绍-6" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>桥接模式(Bridge 模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</li><li>是一种结构型设计模式</li><li>Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。</li></ol><h3 id="2-、原理类图"><a href="#2-、原理类图" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118161531.png" style="zoom: 67%;"><p>上图说明</p><ol><li>Client 类：桥接模式的调用者</li><li>抽象类(Abstraction) :维护了 Implementor / 即它的实现类ConcreteImplementorA/B, 二者是聚合关系, Abstraction充当桥接类</li><li>RefinedAbstraction : 是 Abstraction 抽象类的子类</li><li>Implementor : 行为实现类的接口</li><li>ConcreteImplementorA/B ：行为的具体实现类</li><li>从 UML 图：这里的抽象类和接口是聚合的关系，其实调用和被调用关系</li></ol><h2 id="3、桥接模式解决手机操作问题"><a href="#3、桥接模式解决手机操作问题" class="headerlink" title="3、桥接模式解决手机操作问题"></a>3、桥接模式解决手机操作问题</h2><h3 id="1-、UML类图分析-5"><a href="#1-、UML类图分析-5" class="headerlink" title="(1)、UML类图分析"></a>(1)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118162636.png" style="zoom:80%;"><h3 id="2-、代码实现-3"><a href="#2-、代码实现-3" class="headerlink" title="(2)、代码实现"></a>(2)、代码实现</h3><p><code>Brand</code>定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>XiaoMi</code>手机类实现<code>Brand</code>，写上自己的方法，<code>Vivo</code>类同理，不列出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMi</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">" 小米手机开机 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">" 小米手机关机 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">" 小米手机打电话 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Phone</code>设计为抽象类，便于聚合<code>Brand</code>接口，调用时，实际实现的确是<code>XiaoMi</code>或<code>Vivo</code>类，这个桥接模式设计的确实好，方法前面不加<code>abstract</code>可以有选择性的重写还是不重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">   <span class="comment">//聚合品牌</span></span><br><span class="line">   <span class="keyword">private</span> Brand brand;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.brand = brand;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.brand.open();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.brand.close();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.brand.call();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FoldedPhone</code>继承抽象类<code>Phone</code>，子类选择性重写方法。<code>UpRightPhone</code>和这个一样，不单独列出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折叠式手机类，继承 抽象类 Phone</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoldedPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FoldedPhone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(brand);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.open();</span><br><span class="line">      System.out.println(<span class="string">" 折叠样式手机 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.close();</span><br><span class="line">      System.out.println(<span class="string">" 折叠样式手机 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.call();</span><br><span class="line">      System.out.println(<span class="string">" 折叠样式手机 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个桥接模式确实设计的十分巧妙，2*2直接可以搞出4个不同的产品来，有效的解决了类爆炸的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取折叠式手机 (样式 + 品牌 )</span></span><br><span class="line">   Phone phone1 = <span class="keyword">new</span> FoldedPhone(<span class="keyword">new</span> XiaoMi());</span><br><span class="line"></span><br><span class="line">   phone1.open();</span><br><span class="line">   phone1.call();</span><br><span class="line">   phone1.close();</span><br><span class="line">    </span><br><span class="line">   System.out.println(<span class="string">"=============="</span>);</span><br><span class="line"></span><br><span class="line">   UpRightPhone phone4 = <span class="keyword">new</span> UpRightPhone(<span class="keyword">new</span> Vivo());</span><br><span class="line"></span><br><span class="line">   phone4.open();</span><br><span class="line">   phone4.call();</span><br><span class="line">   phone4.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、桥接模式在-JDBC-的源码剖析"><a href="#4、桥接模式在-JDBC-的源码剖析" class="headerlink" title="4、桥接模式在 JDBC 的源码剖析"></a>4、桥接模式在 JDBC 的源码剖析</h2><p>Jdbc 的 Driver  接口，如果从桥接模式来看，Driver 就是一个接口，下面可以有 MySQL 的 Driver，Oracle 的<br>Driver，这些就可以当做实现接口类</p><p>进入<code>MySQL</code>的ConnectionImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.cj.jdbc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionImpl</span> <span class="keyword">implements</span> <span class="title">JdbcConnection</span>, <span class="title">SessionEventListener</span>, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>继续进入<code>JdbcConnection</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.cj.jdbc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JdbcConnection</span> <span class="keyword">extends</span> <span class="title">Connection</span>, <span class="title">MysqlConnection</span>, <span class="title">TransactionEventHandler</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>继续进入<code>MysqlConnection</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.cj;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MysqlConnection</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>进入<code>Connection</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.sql;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connection</span>  <span class="keyword">extends</span> <span class="title">Wrapper</span>, <span class="title">AutoCloseable</span> </span>&#123;</span><br></pre></td></tr></table></figure><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118173053.png" style="zoom:67%;"><p><code>DriverManager</code>使用<code>getConnection</code>开启连接</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118173015.png" style="zoom:67%;"><h2 id="5、桥接模式的注意事项和细节"><a href="#5、桥接模式的注意事项和细节" class="headerlink" title="5、桥接模式的注意事项和细节"></a>5、桥接模式的注意事项和细节</h2><ol><li><p>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</p></li><li><p>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。</p></li><li><p>桥接模式替代多层继承方案，可以减少 子类的个数，降低系统的管理和维护成本。</p></li><li><p>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</p></li><li><p>桥接模式要求 正确识别出系统中两个独立变化的维度( 抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。</p></li><li><p>桥接模式其它应用场景，对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.</p></li></ol><h2 id="7、常见的应用场景"><a href="#7、常见的应用场景" class="headerlink" title="7、常见的应用场景"></a>7、常见的应用场景</h2><ul><li>JDBC 驱动程序</li><li>银行转账系统<br>转账分类: 网上转账，柜台转账，AMT 转账<strong>（抽象）</strong><br>转账用户类型：普通用户，银卡用户，金卡用户..<strong>（实际）</strong></li><li>消息管理<br>消息类型：即时消息，延时消息<strong>（抽象）</strong><br>消息分类：手机短信，邮件消息，QQ 消息…<strong>（实际）</strong></li></ul><h1 id="七、装饰者设计模式"><a href="#七、装饰者设计模式" class="headerlink" title="七、装饰者设计模式"></a>七、装饰者设计模式</h1><h2 id="1、实际问题导出-2"><a href="#1、实际问题导出-2" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、星巴克咖啡订单项目（咖啡馆）："><a href="#1-、星巴克咖啡订单项目（咖啡馆）：" class="headerlink" title="(1)、星巴克咖啡订单项目（咖啡馆）："></a>(1)、星巴克咖啡订单项目（咖啡馆）：</h3><ol><li><p>咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)</p></li><li><p>调料：Milk、Soy(豆浆)、Chocolate</p></li><li><p>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</p></li><li><p>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</p></li></ol><h3 id="2-、方案-1-较差"><a href="#2-、方案-1-较差" class="headerlink" title="(2)、方案 1(较差)"></a>(2)、方案 1(较差)</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118210456.png" style="zoom:67%;"><p> <strong>方案 1-解决星巴克咖啡订单问题分析</strong></p><ol><li>Drink 是一个抽象类，表示饮料</li><li>des 就是对咖啡的描述, 比如咖啡的名字</li><li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法.</li><li>Decaf 就是单品咖啡， 继承 Drink, 并实现 cost</li><li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li><li>问题:这样设计，会有很多类 ，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增 ，就会出现类爆炸。</li></ol><p>为什么不搞成4个单品，3种调料，然后每一个定义一个成员数量和静态常量单价，初始化时设置数量，最后计算时，数量乘单价计算总金额？</p><h3 id="3-、方案-2-好一点"><a href="#3-、方案-2-好一点" class="headerlink" title="(3)、方案 2(好一点)"></a>(3)、方案 2(好一点)</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118212302.png" style="zoom:67%;"><p> <strong>方案 2-解决星巴克咖啡订单问题分析</strong></p><ol><li>方案2可以控制类的数量，不至于造成很多的类</li><li>在 增加或者删除调料种类时，代码的维护量很大</li><li>考虑到用户可以添加多份 调料时，可以将hasMilk 返回一个对应int</li><li>考虑使用 <font color="red"><strong>装饰者</strong></font> 模式</li></ol><h2 id="2、装饰者模式"><a href="#2、装饰者模式" class="headerlink" title="2、装饰者模式"></a>2、装饰者模式</h2><h3 id="1-、装饰者模式原理"><a href="#1-、装饰者模式原理" class="headerlink" title="(1)、装饰者模式原理"></a>(1)、装饰者模式原理</h3><ol><li>装饰者模式就像打包一个快递<br>主体：比如：陶瓷、衣服 (Component)       // 被装饰者<br>包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)   // 装饰者</li><li>Component 主体：比如类似前面的 Drink</li><li>ConcreteComponent 和 DecoratorConcreteComponent：具体的主体，比如前面的各个单品咖啡</li><li>Decorator: 装饰者，比如各调料.在如图的 Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类。</li></ol><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118214054.png" style="zoom:67%;"><h3 id="2-、装饰者模式解决星巴克咖啡订单"><a href="#2-、装饰者模式解决星巴克咖啡订单" class="headerlink" title="(2)、装饰者模式解决星巴克咖啡订单"></a>(2)、装饰者模式解决星巴克咖啡订单</h3><h3 id="3-、UML类图分析-3"><a href="#3-、UML类图分析-3" class="headerlink" title="(3)、UML类图分析"></a>(3)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118215001.png" style="zoom:67%;"><p><strong>装饰者模式下的订单：2 份巧克力+ 一份牛奶的LongBlack</strong></p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200118215150.png" style="zoom:67%;"><p><strong>说明</strong></p><ol><li>Milk包含了LongBlack</li><li>一份Chocolate包含了(Milk+LongBlack)</li><li>一份Chocolate包含了(Chocolate+Milk+LongBlack)</li><li>这样不管是什么形式的单品咖啡+调料组合，通过递归方式可以方便的组合和维护。</li></ol><h3 id="4-、代码实现-2"><a href="#4-、代码实现-2" class="headerlink" title="(4)、代码实现"></a>(4)、代码实现</h3><p><code>Drink</code>定义为<code>abstract</code>抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 描述</span></span><br><span class="line">   <span class="keyword">public</span> String des;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//省略了get，set方法</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//计算费用的抽象方法</span></span><br><span class="line">   <span class="comment">//子类来实现</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个所有咖啡种类的都要继承的<code>Coffee</code>缓冲类，直接返回父类的<code>getPrice()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span>  <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getPrice();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Espresso</code>和<code>LongBlack</code>,<code>ShortBlack</code>为具体的咖啡种类，继承<code>Coffee</code>缓冲类，在构造时设置描述和价格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      setDes(<span class="string">" 意大利咖啡 "</span>);</span><br><span class="line">      setPrice(<span class="number">6.0f</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>Decorator</code>设计的妙啊，即把被装饰者单品咖啡的价格和描述拿到了，又加上了自己调料的价格和描述，</p><p><strong>继承加聚合，妙哉！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Drink obj;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink obj)</span> </span>&#123; <span class="comment">//组合</span></span><br><span class="line">      <span class="keyword">this</span>.obj = obj;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// getPrice是等下谁实现Decorator就是谁自己的价格</span></span><br><span class="line">      <span class="comment">//obj.cost()是成员变量obj所传过来的单独咖啡的价格</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + obj.cost();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// obj.getDes() 输出被装饰者的信息</span></span><br><span class="line">     <span class="keyword">return</span> des + <span class="string">" "</span> + getPrice() + <span class="string">" &amp;&amp; "</span> + obj.getDes()+ <span class="string">" "</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调料类<code>Milk</code>,<code>Soy</code>和<code>Chocolate</code>继承<code>Decorator</code>，直接调用父类的构造方法，既拿到被装饰者单品咖啡的价格和描述，又设置自己单独的价格和描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的Decorator， 这里就是调味品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(obj);</span><br><span class="line">      setDes(<span class="string">" 牛奶 "</span>);</span><br><span class="line">      setPrice(<span class="number">2.0f</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 点一份 LongBlack</span></span><br><span class="line">   Drink order = <span class="keyword">new</span> LongBlack();</span><br><span class="line">   System.out.println(<span class="string">"order点一份 LongBlack  费用="</span> + order.cost());</span><br><span class="line">   System.out.println(<span class="string">"order点一份 LongBlack  描述="</span> + order.getDes());</span><br><span class="line">   System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. order 加入一份牛奶</span></span><br><span class="line">   order = <span class="keyword">new</span> Milk(order);</span><br><span class="line">   System.out.println(<span class="string">"order 加入一份牛奶 费用 ="</span> + order.cost());</span><br><span class="line">   System.out.println(<span class="string">"order 加入一份牛奶 描述 = "</span> + order.getDes());</span><br><span class="line">   System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. order 加入一份巧克力</span></span><br><span class="line">   order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">   System.out.println(<span class="string">"order 加入一份牛奶 加入一份巧克力  费用 ="</span> + order.cost());</span><br><span class="line">   System.out.println(<span class="string">"order 加入一份牛奶 加入一份巧克力 描述 = "</span> + order.getDes());</span><br><span class="line">   System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. order 再加入一份巧克力</span></span><br><span class="line">   order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">   System.out.println(<span class="string">"order 加入一份牛奶 加入2份巧克力   费用 ="</span> + order.cost());</span><br><span class="line">   System.out.println(<span class="string">"order 加入一份牛奶 加入2份巧克力 描述 = "</span> + order.getDes());</span><br><span class="line">   System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">order点一份 LongBlack  费用=<span class="number">5.0</span></span><br><span class="line">order点一份 LongBlack  描述= longblack </span><br><span class="line">===========================</span><br><span class="line">order 加入一份牛奶 费用 =<span class="number">7.0</span></span><br><span class="line">order 加入一份牛奶 描述 =  牛奶  <span class="number">2.0</span> &amp;&amp;  longblack  </span><br><span class="line">===========================</span><br><span class="line">order 加入一份牛奶 加入一份巧克力  费用 =<span class="number">10.0</span></span><br><span class="line">order 加入一份牛奶 加入一份巧克力 描述 =  巧克力  <span class="number">3.0</span> &amp;&amp;  牛奶  <span class="number">2.0</span> &amp;&amp;  longblack   </span><br><span class="line">===========================</span><br><span class="line">order 加入一份牛奶 加入<span class="number">2</span>份巧克力   费用 =<span class="number">13.0</span></span><br><span class="line">order 加入一份牛奶 加入<span class="number">2</span>份巧克力 描述 =  巧克力  <span class="number">3.0</span> &amp;&amp;  巧克力  <span class="number">3.0</span> &amp;&amp;  牛奶  <span class="number">2.0</span> &amp;&amp;  longblack</span><br></pre></td></tr></table></figure><p>这种<strong>装饰者模式</strong>的遵守OCP原则，加入一种新品咖啡只需要就创建一个新的实体类就可以用，妙哉！</p><p>举个例子，加入一种<code>DeCaf</code>咖啡，写好后，什么都不用改，直接就能用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeCaf</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DeCaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      setDes(<span class="string">" 无因咖啡 "</span>);</span><br><span class="line">      setPrice(<span class="number">1.0f</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Drink order2 = <span class="keyword">new</span> DeCaf();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"order2 无因咖啡  费用 ="</span> + order2.cost());</span><br><span class="line">System.out.println(<span class="string">"order2 无因咖啡 描述 = "</span> + order2.getDes());</span><br><span class="line"></span><br><span class="line">order2 = <span class="keyword">new</span> Milk(order2);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"order2 无因咖啡 加入一份牛奶  费用 ="</span> + order2.cost());</span><br><span class="line">System.out.println(<span class="string">"order2 无因咖啡 加入一份牛奶 描述 = "</span> + order2.getDes());</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">order2 无因咖啡  费用 =<span class="number">1.0</span></span><br><span class="line">order2 无因咖啡 描述 =  无因咖啡 </span><br><span class="line">order2 无因咖啡 加入一份牛奶  费用 =<span class="number">3.0</span></span><br><span class="line">order2 无因咖啡 加入一份牛奶 描述 =  牛奶  <span class="number">2.0</span> &amp;&amp;  无因咖啡</span><br></pre></td></tr></table></figure><h2 id="3、装饰者模式在-JDK-应用的源码分析"><a href="#3、装饰者模式在-JDK-应用的源码分析" class="headerlink" title="3、装饰者模式在 JDK 应用的源码分析"></a>3、装饰者模式在 JDK 应用的源码分析</h2><p>在JDK 的IO体系中，就是使用<strong>装饰者模式</strong>，分析如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"d:\\abc.txt"</span>));</span><br><span class="line">System.out.println(dis.read());</span><br><span class="line">dis.close();</span><br></pre></td></tr></table></figure><p>进入<code>FileInputStream</code>,可以看到继承了<code>InputStream</code>，继续进去</p><p><code>FileInputStream</code> 是 <code>InputStream</code>子类，类似我们前面的 <code>DeCaf</code>, <code>LongBlack</code>单品咖啡</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><code>InputStream</code> 是抽象类, 类似我们前面讲的<code>Drink</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><code>FilterInputStream</code> 是<code>InputStream</code> 子类：类似我们前面 的 <code>Decorator</code> 修饰者</p><p><code>FilterInputStream</code>类 有  <code>protected volatile InputStream in;</code>即含被装饰者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DataInputStream</code> 是<code>FilterInputStream</code> 子类，具体的修饰者，类似前面的 <code>Milk</code>, <code>Soy</code>等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> <span class="keyword">implements</span> <span class="title">DataInput</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>弹幕补充：</p><p>桥接是抽象聚合接口，装饰者是接口聚合抽象</p><p>个人感觉装饰和桥接的最大区别是：装饰者如咖啡可以同时加冰和加糖,而桥接就像如手机内存一样只能有如4G或者8G</p><h1 id="八、组合设计模式"><a href="#八、组合设计模式" class="headerlink" title="八、组合设计模式"></a>八、组合设计模式</h1><h2 id="1、实际问题导出-3"><a href="#1、实际问题导出-3" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、一个学校院系展示需求"><a href="#1-、一个学校院系展示需求" class="headerlink" title="(1)、一个学校院系展示需求"></a>(1)、一个学校院系展示需求</h3><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，<br>一个学院有多个系。如图</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119094742.png" style="zoom:50%;"><h3 id="2-、传统方案解决学校院系展示"><a href="#2-、传统方案解决学校院系展示" class="headerlink" title="(2)、传统方案解决学校院系展示"></a>(2)、传统方案解决学校院系展示</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119094840.png" style="zoom:33%;"><h3 id="3-、传统方案存在的问题分析"><a href="#3-、传统方案存在的问题分析" class="headerlink" title="(3)、传统方案存在的问题分析"></a>(3)、传统方案存在的问题分析</h3><ol><li>将 学院看做是学校的子类， 系是学院的子类，这样实际上是站在组织大小来进行分层次的</li><li>实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现的管理的操作，比如对学院、系的 添加，删除，遍历等</li><li>解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作。 =&gt;  <strong><font color="red">组合模式</font></strong></li></ol><h2 id="2、组合模式"><a href="#2、组合模式" class="headerlink" title="2、组合模式"></a>2、组合模式</h2><h3 id="1-、基本介绍-7"><a href="#1-、基本介绍-7" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“ 整体- 部分”的层次关系。</li><li>组合模式 依据树形结构来组合对象，用来表示部分以及整体层次。</li><li>这种类型的设计模式属于结构型模式。</li><li>组合模式使得 用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象</li></ol><h3 id="2-、原理类图-1"><a href="#2-、原理类图-1" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119095614.png" style="zoom: 67%;"><p><strong>对原理结构图的说明-即(组合模式的角色及职责)：</strong></p><ol><li>Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component 可以是抽象类或者接口。</li><li>Leaf : 在组合中表示叶子节点，叶子节点没有子节点</li><li>Composite :非叶子节点， 用于存储子部件， 在 Component 接口中实现 子部件的相关操作，比如增加(add),删除(remove)。</li></ol><h3 id="3-、组合模式解决学校院系展示的应用实例"><a href="#3-、组合模式解决学校院系展示的应用实例" class="headerlink" title="(3)、组合模式解决学校院系展示的应用实例"></a>(3)、组合模式解决学校院系展示的应用实例</h3><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，<br>一个学院有多个系。</p><h3 id="4-、UML类图分析"><a href="#4-、UML类图分析" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119100705.png" style="zoom:67%;"><h3 id="5-、代码实现"><a href="#5-、代码实现" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p><code>OrganizationComponent</code>所有组织类的基类，写成<code>abstract</code>抽象类，<code>print</code>写成抽象方法，所有子类都需要去实现各自的打印功能，<code>add</code>和<code>remove</code>不用写成抽象方法，叶子节点的<code>Department</code>不用<code>add</code>和<code>remove</code>功能，(下面没有其他要管理的东西了)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line">   <span class="keyword">private</span> String des; <span class="comment">// 说明</span></span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认实现</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认实现</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法print, 做成抽象的, 子类都需要实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略get，set方法没写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Department</code>叶子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//叶子节点，没有集合，不用聚合其他东西</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(name, des);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//add , remove 就不用写了，因为他是叶子节点</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>College</code>通过<code>OrganizationComponent</code>多态去管理各个专业，这里没有强制，如果把上级学校给装进去了也可以，要十分小心上下级关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//List 中 存放的Department</span></span><br><span class="line">   List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">College</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(name, des);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重写add，将来实际业务中，Colleage 的 add 和  University add 不一定完全一样</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123; </span><br><span class="line">      organizationComponents.add(organizationComponent);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重写remove</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">      organizationComponents.remove(organizationComponent);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"--------------"</span> + getName() + <span class="string">"--------------"</span>);</span><br><span class="line">      <span class="comment">//遍历 organizationComponents</span></span><br><span class="line">      <span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">         organizationComponent.print();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>University</code>和上面的<code>College</code>一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//University 就是 Composite , 可以管理College</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">University</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">University</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(name, des);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重写add</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">      organizationComponents.add(organizationComponent);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重写remove</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">      organizationComponents.remove(organizationComponent);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"--------------"</span> + getName() + <span class="string">"--------------"</span>);</span><br><span class="line">      <span class="comment">//遍历 organizationComponents</span></span><br><span class="line">      <span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">         organizationComponent.print();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//从大到小创建对象 学校</span></span><br><span class="line">   OrganizationComponent university = <span class="keyword">new</span> University(<span class="string">"清华大学"</span>, <span class="string">" 中国顶级大学 "</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建 学院</span></span><br><span class="line">   OrganizationComponent computerCollege = <span class="keyword">new</span> College(<span class="string">"计算机学院"</span>, <span class="string">" 计算机学院 "</span>);</span><br><span class="line">   OrganizationComponent infoEngineercollege = <span class="keyword">new</span> College(<span class="string">"信息工程学院"</span>, <span class="string">" 信息工程学院 "</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建各个学院下面的系(专业)</span></span><br><span class="line">   computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"软件工程"</span>, <span class="string">" 软件工程不错 "</span>));</span><br><span class="line">   computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"网络工程"</span>, <span class="string">" 网络工程不错 "</span>));</span><br><span class="line">   computerCollege.add(<span class="keyword">new</span> Department(<span class="string">"计算机科学与技术"</span>, <span class="string">" 计算机科学与技术是老牌的专业 "</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">"通信工程"</span>, <span class="string">" 通信工程不好学 "</span>));</span><br><span class="line">   infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">"信息工程"</span>, <span class="string">" 信息工程好学 "</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将学院加入到 学校</span></span><br><span class="line">   university.add(computerCollege);</span><br><span class="line">   university.add(infoEngineercollege);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//university.print();</span></span><br><span class="line">   infoEngineercollege.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意上下级关系要程序员手动维护，不然会出错，<code>OrganizationComponent</code>就是个容器，装谁都是装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">computerCollege.add(university);</span><br><span class="line">computerCollege.print();</span><br></pre></td></tr></table></figure><h2 id="3、组合模式在-JDK-集合的源码分析"><a href="#3、组合模式在-JDK-集合的源码分析" class="headerlink" title="3、组合模式在 JDK 集合的源码分析"></a>3、组合模式在 JDK 集合的源码分析</h2><p>Java 的集合类-HashMap 就使用了组合模式</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119105544.png" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; hashMap=<span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">hashMap.put(<span class="number">0</span>, <span class="string">"东游记"</span>);<span class="comment">//直接存放叶子节点(Node)</span></span><br><span class="line"></span><br><span class="line">Map&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"西游记"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"红楼梦"</span>); <span class="comment">//..</span></span><br><span class="line">hashMap.putAll(map);</span><br><span class="line">System.out.println(hashMap);</span><br></pre></td></tr></table></figure><p><code>Map</code>定义为接口，里面定义了许多方法，上面演示的<code>put</code>和<code>putAll</code>就在其中定义了</p><p><code>Map</code> 就是一个抽象的构建 (类似我们的<code>Component</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;</span><br></pre></td></tr></table></figure><p><code>AbstractMap</code>作为一个中间件，缓冲了一下，也是个<code>abstract</code>抽象类，默认实现了一下<code>Map</code>里的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>HashMap</code>真正实现了那些抽象方法，<code>HashMap</code>是一个中间的构建(Composite), 实现/继承了相关方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>其中在<code>HashMap</code>里面有一个<code>Node</code>静态内部类，这个<code>Node</code>静态内部类就没有了<code>put</code>和<code>putAll</code>等方法，只有一些<code>get</code>方法，类似Leaf叶子节点（之前的<code>Department</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br></pre></td></tr></table></figure><h2 id="4、-组合模式的注意事项和细节"><a href="#4、-组合模式的注意事项和细节" class="headerlink" title="4、 组合模式的注意事项和细节"></a>4、 组合模式的注意事项和细节</h2><ol><li>简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。</li><li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。</li><li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从创建出复杂的树形结构</li><li>需要遍历组织机构，或者处理的对象具有树形结构时, <strong>非常适合使用组合模式.</strong></li><li>要求较高的抽象性，如果 节点和叶子有很多差异性的话，比如很多方法和属性都不一样，<strong>不适合使用组合模式</strong></li></ol><h1 id="九、外观设计模式"><a href="#九、外观设计模式" class="headerlink" title="九、外观设计模式"></a>九、外观设计模式</h1><h2 id="1、实际问题导出-4"><a href="#1、实际问题导出-4" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、影院管理项目"><a href="#1-、影院管理项目" class="headerlink" title="(1)、影院管理项目"></a>(1)、影院管理项目</h3><p>组建一个家庭影院：<br>DVD 播放器、投影仪、自动屏幕、环绕立体声、爆米花机,要求完成使用家庭影院的功能，其过程为：<br>直接用遥控器：统筹各设备开关<br>开爆米花机<br>放下屏幕<br>开投影仪<br>开音响<br>开 DVD，选 dvd<br>去拿爆米花<br>调暗灯光<br>播放<br>观影结束后，关闭各种设备</p><h3 id="2-、传统方式解决影院管理"><a href="#2-、传统方式解决影院管理" class="headerlink" title="(2)、传统方式解决影院管理"></a>(2)、传统方式解决影院管理</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119160215.png" style="zoom: 67%;"><h3 id="3-、传统方式存在的问题分析"><a href="#3-、传统方式存在的问题分析" class="headerlink" title="(3)、传统方式存在的问题分析"></a>(3)、传统方式存在的问题分析</h3><ol><li>在 ClientTest 的 main 方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成调用过程混乱，没有清晰的过程</li><li>不利于在 ClientTest 中，去维护对子系统的操作</li><li>解决思路：定义一个高层接口，给子系统中的一组接口提供一个一致的界面(比如在高层接口提供四个方法ready, play, pause, end )，用来访问子系统中的一群接口</li><li>也就是说 就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节 =&gt;   <strong><font color="red">外观模式</font></strong></li></ol><h2 id="2、外观模式"><a href="#2、外观模式" class="headerlink" title="2、外观模式"></a>2、外观模式</h2><h3 id="1-、基本介绍-8"><a href="#1-、基本介绍-8" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口 提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li><li>外观模式通过定义一个一致的接口，用以<strong>屏蔽内部子系统的细节</strong>，使得 调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节</li></ol><h3 id="2-、原理类图-2"><a href="#2-、原理类图-2" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119161206.png" style="zoom:67%;"><p>对类图说明(分类外观模式的角色)</p><ol><li>外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代<br>理给适当子系统对象</li><li>调用者(Client): 外观接口的调用者</li><li>子系统的集合：子模块或者子系统，处理 Facade 对象指派的任务，他是功能的实际提供者</li></ol><h3 id="3-、外观模式解决影院管理"><a href="#3-、外观模式解决影院管理" class="headerlink" title="(3)、外观模式解决影院管理"></a>(3)、外观模式解决影院管理</h3><ol><li>外观模式可以理解为转换一群接口，客户只要调用一个接口，而不用调用多个接口才能达到目的。比如：在 pc上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）。</li><li>外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用</li></ol><h3 id="4-、UML类图分析-1"><a href="#4-、UML类图分析-1" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119162540.png" style="zoom: 60%;"><h3 id="5-、代码实现-1"><a href="#5-、代码实现-1" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p>先定义几个实体类<code>DVDPlayer</code>、<code>Popcorn</code>、<code>Projector</code>、<code>Screen</code>、<code>Stereo</code>和<code>TheaterLight</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DVDPlayer</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用一把单例模式, 使用饿汉式</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">DVDPlayer</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> DVDPlayer instance = <span class="keyword">new</span> DVDPlayer();</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DVDPlayer <span class="title">getInstanc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance;&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;  System.out.println(<span class="string">" dvd on "</span>);  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;  System.out.println(<span class="string">" dvd off "</span>);  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">" dvd is playing "</span>); &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">" dvd pause .."</span>);&#125;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Popcorn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Popcorn</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Popcorn instance = <span class="keyword">new</span> Popcorn();</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Popcorn <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance; &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">" popcorn on "</span>);&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">" popcorn ff "</span>);&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">" popcorn is poping  "</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HomeTheaterFacade</code>聚合各个对象，在构造函数里面加载进来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeTheaterFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//定义各个子系统对象，聚合进来</span></span><br><span class="line">   <span class="keyword">private</span> TheaterLight theaterLight;</span><br><span class="line">   <span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">   <span class="keyword">private</span> Stereo stereo;</span><br><span class="line">   <span class="keyword">private</span> Projector projector;</span><br><span class="line">   <span class="keyword">private</span> Screen screen;</span><br><span class="line">   <span class="keyword">private</span> DVDPlayer dVDPlayer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HomeTheaterFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.theaterLight = TheaterLight.getInstance();</span><br><span class="line">      <span class="keyword">this</span>.popcorn = Popcorn.getInstance();</span><br><span class="line">      <span class="keyword">this</span>.stereo = Stereo.getInstance();</span><br><span class="line">      <span class="keyword">this</span>.projector = Projector.getInstance();</span><br><span class="line">      <span class="keyword">this</span>.screen = Screen.getInstance();</span><br><span class="line">      <span class="keyword">this</span>.dVDPlayer = DVDPlayer.getInstanc();</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//设计不同阶段的方法，调用聚合成员的各个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">popcorn.on();  popcorn.pop();  screen.down();</span><br><span class="line">projector.on(); stereo.on();  dVDPlayer.on();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dVDPlayer.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>方法直接示例化一个调用<code>HomeTheaterFacade</code>，调用其中不同阶段的方法就可以了，不用每个对象new一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   HomeTheaterFacade homeTheaterFacade = <span class="keyword">new</span> HomeTheaterFacade();</span><br><span class="line">   homeTheaterFacade.ready();</span><br><span class="line">   homeTheaterFacade.play();</span><br><span class="line">   homeTheaterFacade.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>话说，这个不是在平常中就会用到的吗。。。。没学设计模式之前，平时就是这么设计的。</strong></p><h2 id="3、外观模式在-MyBatis-框架应用的源码分析"><a href="#3、外观模式在-MyBatis-框架应用的源码分析" class="headerlink" title="3、外观模式在 MyBatis 框架应用的源码分析"></a>3、外观模式在 MyBatis 框架应用的源码分析</h2><p>在MyBatis 中的<code>Configuration</code>有两个成员<code>objectFactory</code>和<code>objectWrapperFactory</code>直接给new出来了，在下面的方法<code>newMetaObject</code>方法中进行了赋值，追踪<code>MetaObject.forObject</code>进去</p><p>特别说明：<code>ObjectWrapperFactory</code>和<code>ObjectFactory</code>是两个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"> <span class="keyword">protected</span> ObjectFactory objectFactory = <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line"> <span class="keyword">protected</span> ObjectWrapperFactory objectWrapperFactory = <span class="keyword">new</span> DefaultObjectWrapperFactory();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MetaObject <span class="title">newMetaObject</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MetaObject.forObject(object, objectFactory, objectWrapperFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>MetaObject.forObject</code>先判断是否为空，然后直接使用构造函数，<code>MetaObject</code>也聚合了这几个成员，在构造器中进行赋值，直接使用<code>instanceof</code>判断类型是否相等，相等直接返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object originalObject;</span><br><span class="line">  <span class="keyword">private</span> ObjectWrapper objectWrapper;</span><br><span class="line">  <span class="keyword">private</span> ObjectFactory objectFactory;</span><br><span class="line">  <span class="keyword">private</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.originalObject = object;</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaObject <span class="title">forObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> SystemMetaObject.NULL_META_OBJECT;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MetaObject(object, objectFactory, objectWrapperFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>MetaObject</code>相当于多搞了一层而且，然后期间使用了接口和多态，大致思想是一样的，外观模式。</p><p><strong>源码类图</strong></p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119172108.png" style="zoom:67%;"><h2 id="4、外观模式的注意事项和细节"><a href="#4、外观模式的注意事项和细节" class="headerlink" title="4、外观模式的注意事项和细节"></a>4、外观模式的注意事项和细节</h2><ol><li>外观模式<font color="red"><strong>对外屏蔽了子系统的细节</strong></font>，因此外观模式降低了客户端对子系统使用的复杂性</li><li>外观模式对客户端与子系统的耦合关系 - 解耦，让子系统内部的模块更易维护和扩展</li><li>通过合理的使用外观模式，可以帮我们更好的<font color="red"><strong>划分访问的层次</strong></font></li><li>当系统需要进行分层设计时，可以考虑使用 Facade 模式</li><li>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性</li><li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的</li></ol><h1 id="十、享元设计模式"><a href="#十、享元设计模式" class="headerlink" title="十、享元设计模式"></a>十、享元设计模式</h1><h2 id="1、实际问题导出-5"><a href="#1、实际问题导出-5" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、展示网站项目需求"><a href="#1-、展示网站项目需求" class="headerlink" title="(1)、展示网站项目需求"></a>(1)、展示网站项目需求</h3><p>小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：</p><ol><li>有客户要求以新闻的形式发布</li><li>有客户人要求以博客的形式发布</li><li>有客户希望以微信公众号的形式发布</li></ol><h3 id="2-、传统方案解决网站展现项目"><a href="#2-、传统方案解决网站展现项目" class="headerlink" title="(2)、传统方案解决网站展现项目"></a>(2)、传统方案解决网站展现项目</h3><ol><li><p>直接复制粘贴一份，然后根据客户不同要求，进行定制修改</p></li><li><p>给每个网站租用一个空间</p></li><li><p>方案设计示意图</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119203759.png" style="zoom: 60%;"></li></ol><h3 id="3-、传统方式存在的问题分析-1"><a href="#3-、传统方式存在的问题分析-1" class="headerlink" title="(3)、传统方式存在的问题分析"></a>(3)、传统方式存在的问题分析</h3><ol><li>需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当一个相同网站的实例对象很多，造成服务器的资源浪费</li><li>解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空等服务器资源都可以达成共享，减少服务器资源</li><li>对于代码来说，由于是一份实例，维护和扩展都更加容易</li><li>上面的解决思路就可以使用 享元模式 来解决</li></ol><h2 id="2、享元模式"><a href="#2、享元模式" class="headerlink" title="2、享元模式"></a>2、享元模式</h2><h3 id="1-、基本介绍-9"><a href="#1-、基本介绍-9" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><p><strong>享–&gt;共享，元–&gt;对象，共享对象模式</strong></p><ol><li>享元模式（Flyweight Pattern） 也叫 <strong>蝇量模式</strong>: 运用共享技术有效地支持大量细粒度的对象</li><li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象<br>中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</li><li>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对<br>象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</li><li>享元模式经典的应用场景就是池技术了，<strong>String 常量池</strong>、<strong>数据库连接池</strong>、<strong>缓冲池</strong>等等都是享元模式的应用，享<br>元模式是池技术的重要实现方</li></ol><p><strong>初步感知</strong></p><p>在Java中创建两个相同的字符串，就用到了享元模式，第2次创建会使用堆地址，指向第一次创建的内存空间，<code>s</code>和<code>s2</code>看起来的两个对象，实际上是同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119205600.png" style="zoom:67%;"><h3 id="2-、原理类图-3"><a href="#2-、原理类图-3" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200119205936.png" style="zoom:67%;"><p><strong>对类图的说明</strong><br>对原理图的说明-即(模式的角色及职责)</p><ol><li><code>FlyWeight</code> 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍) 的接口或实现</li><li><code>ConcreteFlyWeight</code> 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</li><li><code>UnSharedConcreteFlyWeight</code> 是不可共享的角色，一般不会出现在享元工厂。</li><li><code>FlyWeightFactory</code> 享元工厂类，用于构建一个池容器(集合)， 同时提供从池中获取对象方法</li></ol><h3 id="3-、内部状态和外部状态"><a href="#3-、内部状态和外部状态" class="headerlink" title="(3)、内部状态和外部状态"></a>(3)、内部状态和外部状态</h3><p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜<br>色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化<br>的，所以棋子坐标就是棋子的外部状态</p><ol><li>享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：<strong><font color="red">内部状态</font></strong>和<strong><font color="red">外部状态</font></strong></li><li><strong><font color="red">内部状态</font></strong>指对象共享出来的信息， 存储在享元对象内部且不会随环境的改变而改变</li><li><strong><font color="red">外部状态</font></strong>指对象得以依赖的一个标记，是 随环境改变而改变的、不可共享的状态。</li><li>举个例子：围棋理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题。</li></ol><h3 id="4-、UML类图分析-2"><a href="#4-、UML类图分析-2" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120102447.png" style="zoom:67%;"><h3 id="5-、代码实现-2"><a href="#5-、代码实现-2" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p><code>User</code>类，定义为外部状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WebSite</code>定义为<code>abstract</code>抽象类，定义一个抽象方法<code>use</code>，其中使用<code>User</code>这个外部状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcreteWebSite</code>继承<code>WebSite</code>，重写<code>use</code>方法，在这个类中，同时聚集了外部状态<code>user</code>和内部状态<code>type</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//共享的部分，内部状态，网站发布的形式(类型)</span></span><br><span class="line">   <span class="keyword">private</span> String type = <span class="string">""</span>; </span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcreteWebSite</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.type = type;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"网站的发布形式为:"</span> + type + <span class="string">" 在使用中 .. 使用者是"</span> + user.getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WebSiteFactory</code>是这个享元模式的核心，使用一个HashMap定义网站池，根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回，并设计一个方法获取网站分类的总数 (池中有多少个网站类型)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网站工厂类，根据需要返回压一个网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSiteFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//集合， 充当池的作用</span></span><br><span class="line">   <span class="keyword">private</span> HashMap&lt;String, ConcreteWebSite&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> WebSite <span class="title">getWebSiteCategory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!pool.containsKey(type)) &#123;</span><br><span class="line">         <span class="comment">//就创建一个网站，并放入到池中</span></span><br><span class="line">         pool.put(type, <span class="keyword">new</span> ConcreteWebSite(type));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (WebSite)pool.get(type);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取网站分类的总数 (池中有多少个网站类型)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWebSiteCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> pool.size();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 创建一个工厂类</span></span><br><span class="line">   WebSiteFactory factory = <span class="keyword">new</span> WebSiteFactory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 客户要一个以新闻形式发布的网站</span></span><br><span class="line">   WebSite webSite1 = factory.getWebSiteCategory(<span class="string">"新闻"</span>);</span><br><span class="line">   webSite1.use(<span class="keyword">new</span> User(<span class="string">"tom"</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 客户要一个以博客形式发布的网站</span></span><br><span class="line">   WebSite webSite2 = factory.getWebSiteCategory(<span class="string">"博客"</span>);</span><br><span class="line">   webSite2.use(<span class="keyword">new</span> User(<span class="string">"jack"</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 客户要一个以博客形式发布的网站</span></span><br><span class="line">   WebSite webSite3 = factory.getWebSiteCategory(<span class="string">"博客"</span>);</span><br><span class="line">   webSite3.use(<span class="keyword">new</span> User(<span class="string">"smith"</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 客户要一个以博客形式发布的网站</span></span><br><span class="line">   WebSite webSite4 = factory.getWebSiteCategory(<span class="string">"博客"</span>);</span><br><span class="line">   webSite4.use(<span class="keyword">new</span> User(<span class="string">"king"</span>));</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"网站的分类共="</span> + factory.getWebSiteCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">网站的发布形式为:新闻 在使用中 .. 使用者是tom</span><br><span class="line">网站的发布形式为:博客 在使用中 .. 使用者是jack</span><br><span class="line">网站的发布形式为:博客 在使用中 .. 使用者是smith</span><br><span class="line">网站的发布形式为:博客 在使用中 .. 使用者是king</span><br><span class="line">网站的分类共=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>虽然一共看起来有4个网站示例，其实根据内部状态的不同，就创建了2个示例，外部状态变化不影响个数。</p><h2 id="3、享元模式在-JDK-Interger-的应用源码分析"><a href="#3、享元模式在-JDK-Interger-的应用源码分析" class="headerlink" title="3、享元模式在 JDK-Interger 的应用源码分析"></a>3、享元模式在 JDK-Interger 的应用源码分析</h2><p>在Java的<code>Integer</code>类中用到了享元模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Integer x = Integer.valueOf(<span class="number">127</span>); <span class="comment">// 得到 x实例，类型 Integer</span></span><br><span class="line">   Integer y = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">// 得到 y 实例，类型 Integer</span></span><br><span class="line">   Integer z = Integer.valueOf(<span class="number">127</span>);<span class="comment">//..</span></span><br><span class="line">   Integer w = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">   System.out.println(x.equals(y)); <span class="comment">// 大小，true</span></span><br><span class="line">   System.out.println(x == y ); <span class="comment">//  false</span></span><br><span class="line">   System.out.println(x == z ); <span class="comment">// true</span></span><br><span class="line">   System.out.println(w == x ); <span class="comment">// false</span></span><br><span class="line">   System.out.println(w == y ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">   Integer x1 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">   Integer x2 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">   System.out.println(<span class="string">"x1==x2"</span> + (x1 == x2)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">x1==x2false</span><br></pre></td></tr></table></figure><p>进入<code>Integer.valueOf</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果i大于等于<code>IntegerCache.low</code>且小于等于<code>IntegerCache.high</code>就直接从缓存中返回对象示例，不用new,而如果i不在这个区间里面，就new一个对象，追踪<code>IntegerCache.low</code>和<code>IntegerCache.high</code>的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br></pre></td></tr></table></figure><p><code>IntegerCache</code>一开始就设定<code>low</code>=-128，在static里面定义high=h=127，[-128,127]因为较常用 而且这个正数范围是可以配置的,不是固定的,为了省内存空间，所以搞了个缓冲池。</p><p>所以可以解释这个为true，因为都是同一个对象实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Integer x = Integer.valueOf(<span class="number">127</span>); </span><br><span class="line"> Integer z = Integer.valueOf(<span class="number">127</span>); </span><br><span class="line">System.out.println(x == z ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果 Integer.valueOf(x) x 在  -128 — 127 直接，就是使用享元模式返回,如果不在范围类，则仍然 new<br><strong>小结:</strong><br>    1. 在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer(new), 否则，就直接从 缓存池返回<br>    2. valueOf 方法，就使用到享元模式<br>    3. 如果使用valueOf 方法得到一个Integer 实例，范围在 -128 - 127 ，执行速度比 new 快</p><h2 id="4、享元模式的注意事项和细节"><a href="#4、享元模式的注意事项和细节" class="headerlink" title="4、享元模式的注意事项和细节"></a>4、享元模式的注意事项和细节</h2><ol><li>在享元模式这样理解，“享”就表示共享，“元”表示对象</li><li>系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</li><li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable 存储</li><li><font color="red"><strong>享元模式大大减少了对象的创建</strong></font>，降低了程序内存的占用，提高效率</li><li><font color="red"><strong>享元模式提高了 系统的复杂度</strong></font>。需要分离出 内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.</li><li>使用享元模式时，注意划分<font color="red"><strong>内部状态和外部状态</strong></font>，并且需要有一个工厂类加以控制。</li><li>享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池</li></ol><h1 id="十一、代理设计模式"><a href="#十一、代理设计模式" class="headerlink" title="十一、代理设计模式"></a>十一、代理设计模式</h1><h2 id="1、-代理模式"><a href="#1、-代理模式" class="headerlink" title="1、 代理模式"></a>1、 代理模式</h2><h3 id="1-、基本介绍-10"><a href="#1-、基本介绍-10" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。</li><li>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</li><li>代理模式有不同的形式, 主要有三种<strong><font color="red">静态代理</font></strong>、<strong><font color="red">动态代理</font></strong>(JDK代理、接口代理)和 <strong><font color="red">Cglib代理</font></strong> (可以在内存动态的创建对象，而不需要实现接口，他是属于动态代理的范畴)。</li></ol><h3 id="2-、代理模式示意图"><a href="#2-、代理模式示意图" class="headerlink" title="(2)、代理模式示意图"></a>(2)、代理模式示意图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120115608.png" style="zoom:67%;"><h2 id="2、静态代理"><a href="#2、静态代理" class="headerlink" title="2、静态代理"></a>2、静态代理</h2><h3 id="1-、基本介绍-11"><a href="#1-、基本介绍-11" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继<br>承相同父类</p><h3 id="2-、应用实例"><a href="#2-、应用实例" class="headerlink" title="(2)、应用实例"></a>(2)、应用实例</h3><p> <strong>具体要求</strong></p><ol><li>定义一个接口:ITeacherDao</li><li>目标对象 TeacherDAO 实现接口 ITeacherDAO</li><li>使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO</li><li>调用的时候通过调用代理对象的方法来调用目标对象.</li><li>特别提醒：代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法</li></ol><h3 id="3-、UML类图"><a href="#3-、UML类图" class="headerlink" title="(3)、UML类图"></a>(3)、UML类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120122831.png" style="zoom: 67%;"><h3 id="4-、代码实现-3"><a href="#4-、代码实现-3" class="headerlink" title="(4)、代码实现"></a>(4)、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; <span class="comment">// 授课的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">" 老师授课中  。。。。。"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TeacherDaoProxy</code>这里应该是通过无参构造来new出被代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理对象,静态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ITeacherDao target; <span class="comment">// 目标对象，通过接口来聚合</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TeacherDaoProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"开始代理  完成某些操作。。。。。 "</span>);<span class="comment">//方法</span></span><br><span class="line">      target.teach();</span><br><span class="line">      System.out.println(<span class="string">"提交。。。。。"</span>);<span class="comment">//方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时根本就看不见被代理对象才对，只能看见代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//通过代理对象，调用到被代理对象的方法</span></span><br><span class="line">   TeacherDaoProxy teacherDaoProxy = <span class="keyword">new</span> TeacherDaoProxy();</span><br><span class="line">   <span class="comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法</span></span><br><span class="line">   teacherDaoProxy.teach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-、装饰者模式与静态代理的对比"><a href="#5-、装饰者模式与静态代理的对比" class="headerlink" title="(5)、装饰者模式与静态代理的对比"></a>(5)、装饰者模式与静态代理的对比</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol><li><p>装饰者类与代理类都需要实现目标类所实现的接口</p></li><li><p>装饰者类与代理类中都需要声明目标类对象，目的是这些类中都需要调用目标对象的目标方法</p></li><li><p>装饰者类与代理类都可以在不改变目标类的前提下对目标对象进行增强</p></li></ol><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol><li>目的不同：装饰者类的目的就是为了增强目标类；静态代理类的目的是为了保护和隐藏目标对象。</li><li>装饰者类与代理类中都需要声明目标类对象，但对于目标对象的创建方式不同。装饰者类是由带参构造器传入的；<strong>代理类中的目标对象，是在无参构造器中直接创建的</strong>。</li><li>测试类中，装饰者模式，需要先创建一个目标类对象，再将其通过带参构造器传给装饰者类；代理模式，测试类直接创建代理类对象，测试类根本就看不到业务接口的真正的实现类是谁。</li><li>装饰者类一般不具体增强目标类，而是由具体的装饰者子类进行的增强，并且可以形成“装饰者链”；静态代理类，则是具体的增强的实现，所有的增强功能，一般都是在静态代理类中完成的。</li></ol><h3 id="6-、-静态代理优缺点"><a href="#6-、-静态代理优缺点" class="headerlink" title="(6)、 静态代理优缺点"></a>(6)、 静态代理优缺点</h3><p> <strong>优点</strong>：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展<br> <strong>缺点：</strong>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类<br>           一旦接口增加方法,目标对象与代理对象都要维护</p><h2 id="3、动态代理"><a href="#3、动态代理" class="headerlink" title="3、动态代理"></a>3、动态代理</h2><h3 id="1-、基本介绍-12"><a href="#1-、基本介绍-12" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li><li>代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象</li><li>动态代理也叫做：JDK 代理、接口代理</li></ol><h3 id="2-、原理介绍"><a href="#2-、原理介绍" class="headerlink" title="(2)、原理介绍"></a>(2)、原理介绍</h3><p>动态代理的原理是使用了JDK 中生成代理对象的 API</p><ol><li>代理类所在包:java.lang.reflect.Proxy</li><li>JDK 实现代理只需要使用 newProxyInstance 方法,但是该方法需要接收三个参数,完整的写法是:<br>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</li></ol><h3 id="3-、应用实例"><a href="#3-、应用实例" class="headerlink" title="(3)、应用实例"></a>(3)、应用实例</h3><p>将前面的静态代理改进成动态代理模式(即：JDK 代理模式)</p><h3 id="4-、UML类图"><a href="#4-、UML类图" class="headerlink" title="(4)、UML类图"></a>(4)、UML类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120143828.png" style="zoom:67%;"><p>与静态代理而言不需要代理类也实现<code>ITeacherDao</code>接口了，通过反射拿到代理对象的方法</p><h3 id="5-、代码实现-3"><a href="#5-、代码实现-3" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p><code>ITeacherDao</code>和<code>TeacherDao</code>和上面的静态代理一样，没啥说的，加了个<code>sayHello</code>方法为了演示参数的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; <span class="comment">// 授课方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">" 老师授课中.... "</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"hello "</span> + name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个动态代理的<code>ProxyFactory</code>有必要好好说一下，首先聚合的时候只使用了<code>Object</code>类，并不知道自己要代理哪一个类，构造函数将<code>target</code>赋值，这个<code>public Object getProxyInstance()</code>直接使用JDK的API，前两个参数分别为拿到<code>target</code>的所在类和<code>target</code>的所在接口，都是固定写法，没什么好说的。</p><p>第三个参数，在代理类中，对被代理类进行增强，<code>Object proxy, Method method, Object[] args</code>三个参数</p><p><code>Object returnVal = method.invoke(target, args);</code>说明了使用<code>method</code>装载被代理类，<code>args</code>里面是参数列表，这也是为什么上面设计一个<code>sayHello(String name)</code>方法的初衷，为了使用一下</p><p> <code>return returnVal;</code>这个返回会返回被调用方法的返回值，假如说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">" 老师授课中.... "</span>);</span><br><span class="line">   <span class="keyword">return</span>  <span class="string">"hello,world"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么<code>returnVal</code>的值就是<code>hello,world</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个目标对象 , Object</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器 ， 对target 进行初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象 生成一个代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       *  public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                                          InvocationHandler h)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class="line"><span class="comment">            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"JDK代理开始~~"</span>);</span><br><span class="line">                        <span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">                        Object returnVal = method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">"JDK代理提交"</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这一部分涉及到反射的知识，有点懵逼，要去单独的学习一下。</strong></p><h2 id="4、Cglib-代理"><a href="#4、Cglib-代理" class="headerlink" title="4、Cglib 代理"></a>4、Cglib 代理</h2><h3 id="1-、基本介绍-13"><a href="#1-、基本介绍-13" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,<strong><font color="red">并没有实现任何的接口</font></strong>,这个时候可使用目标对象子类来实现代理-这就是 Cglib  代理</li><li>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib代理归属到动态代理。</li><li>Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的框架使用,例如 SpringAOP，实现方法拦截</li><li>在 AOP 编程中如何选择代理模式：<ul><li>目标对象需要实现接口，用 JDK 代理</li><li>目标对象不需要实现接口，用 Cglib 代理</li></ul></li><li>Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类</li></ol><h3 id="2-、实现步骤"><a href="#2-、实现步骤" class="headerlink" title="(2)、实现步骤"></a>(2)、实现步骤</h3><ol><li>需要引入 cglib 的 jar 文件</li><li><strong>在内存中动态构建子类，注意代理的类不能为 final</strong>，否则报错<br>java.lang.IllegalArgumentException:</li><li>目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.</li></ol><h3 id="3-、UML类图-1"><a href="#3-、UML类图-1" class="headerlink" title="(3)、UML类图"></a>(3)、UML类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120154719.png" style="zoom:67%;"><h3 id="4-、代码实现-4"><a href="#4-、代码实现-4" class="headerlink" title="(4)、代码实现"></a>(4)、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">" 老师授课中  ， 我是cglib代理，不需要实现接口 "</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ProxyFactory</code>和动态代理的大致一样，其中<code>getProxyInstance()</code>方法里面的步骤现阶段先对着抄吧，都涉及到了Java底层源码，暂时没法理解不透正常，<code>intercept</code>方法和动态代理的最后一段大致一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">   <span class="comment">//维护一个目标对象</span></span><br><span class="line">   <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.target = target;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1. 创建一个工具类</span></span><br><span class="line">      Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">      <span class="comment">//2. 设置父类</span></span><br><span class="line">      enhancer.setSuperclass(target.getClass());</span><br><span class="line">      <span class="comment">//3. 设置回调函数</span></span><br><span class="line">      enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">      <span class="keyword">return</span> enhancer.create();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cglib代理模式 ~~ 开始"</span>);</span><br><span class="line">      Object returnVal = method.invoke(target, args);</span><br><span class="line">      System.out.println(<span class="string">"Cglib代理模式 ~~ 提交"</span>);</span><br><span class="line">      <span class="keyword">return</span> returnVal;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建目标对象</span></span><br><span class="line">   TeacherDao target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">   <span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">   TeacherDao proxyInstance = (TeacherDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">   <span class="comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class="line">   String res = proxyInstance.teach();</span><br><span class="line">   System.out.println(<span class="string">"res="</span> + res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>弹幕大神：</strong></p><p>简单来说 jdk代理是用实现接口的方式，cglib是通过继承的方式。</p><h2 id="5、代理模式几种变体形式"><a href="#5、代理模式几种变体形式" class="headerlink" title="5、代理模式几种变体形式"></a>5、代理模式几种变体形式</h2><ol><li>防火墙代理<br>内网通过代理穿透防火墙，实现对公网的访问。</li><li>缓存代理<br>比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据库取，然后缓存。</li><li>远程代理<br>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。<img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120155630.png" style="zoom:67%;"></li><li>同步代理<br>主要使用在多线程编程中，完成多线程间同步工作</li></ol><h1 id="十二、模板方法设计模式"><a href="#十二、模板方法设计模式" class="headerlink" title="十二、模板方法设计模式"></a>十二、模板方法设计模式</h1><h2 id="1、实际问题导出-6"><a href="#1、实际问题导出-6" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><p>豆浆制作问题<br>编写制作豆浆的程序，说明如下:</p><ol><li>制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎</li><li>通过添加不同的配料，可以制作出不同口味的豆浆</li><li>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的</li><li>请使用 模板方法模式 完成 (说明：因为模板方法模式，比较简单，很容易就想到这个方案，因此就直接使用，不再使用传统的方案来引出模板方法模式 )</li></ol><h2 id="2、-模板方法模式"><a href="#2、-模板方法模式" class="headerlink" title="2、 模板方法模式"></a>2、 模板方法模式</h2><h3 id="1-、基本介绍-14"><a href="#1-、基本介绍-14" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</li><li>简单说，模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</li><li>这种类型的设计模式属于行为型模式。</li></ol><h3 id="2-、原理类图-4"><a href="#2-、原理类图-4" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120165052.png" style="zoom:67%;"><p>对原理类图的说明-即(模板方法模式的角色及职责)</p><p>1) AbstractClass 抽象类， 类中实现了模板方法(template)，定义了算法的骨架，具体子类需要去实现 其它的抽象<br>方法 operationr2,3,4<br>2) ConcreteClass 实现抽象方法 operationr2,3,4, 以完成算法中特点子类的步骤</p><h3 id="3-、应用实例要求"><a href="#3-、应用实例要求" class="headerlink" title="(3)、应用实例要求"></a>(3)、应用实例要求</h3><p>编写制作豆浆的程序，说明如下:<br>制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎<br>通过添加不同的配料，可以制作出不同口味的豆浆<br>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的(红豆、花生豆浆。。。)</p><h3 id="4-、UML类图分析-3"><a href="#4-、UML类图分析-3" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120173715.png" style="zoom:67%;"><h3 id="5-、代码实现-4"><a href="#5-、代码实现-4" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p><code>SoyaMilk</code>写一个抽象方法<code>addCondiments()</code>让子类去实现具体的配料添加，<code>make()</code>方法写成final , 不让子类去覆盖.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line">   <span class="comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      select();</span><br><span class="line">      addCondiments();</span><br><span class="line">      soak();</span><br><span class="line">      beat();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//选材料</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"第一步：选择好的新鲜黄豆  "</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加不同的配料， 抽象方法, 子类具体实现</span></span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//浸泡</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">soak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"第三步， 黄豆和配料开始浸泡， 需要3小时 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"第四步：黄豆和配料放到豆浆机去打碎  "</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PeanutSoyaMilk</code>和<code>RedBeanSoyaMilk</code>一样，继承<code>SoyaMilk</code>,具体实现<code>addCondiments()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeanutSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">" 加入上好的花生 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">" 加入上好的红豆 "</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用多态，直接调用就完了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//制作红豆豆浆</span></span><br><span class="line">   System.out.println(<span class="string">"----制作红豆豆浆----"</span>);</span><br><span class="line">   SoyaMilk redBeanSoyaMilk = <span class="keyword">new</span> RedBeanSoyaMilk();</span><br><span class="line">   redBeanSoyaMilk.make();</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"----制作花生豆浆----"</span>);</span><br><span class="line">   SoyaMilk peanutSoyaMilk = <span class="keyword">new</span> PeanutSoyaMilk();</span><br><span class="line">   peanutSoyaMilk.make();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、-模板方法模式的钩子方法"><a href="#3、-模板方法模式的钩子方法" class="headerlink" title="3、 模板方法模式的钩子方法"></a>3、 模板方法模式的钩子方法</h2><h3 id="1-、内容介绍"><a href="#1-、内容介绍" class="headerlink" title="(1)、内容介绍"></a>(1)、内容介绍</h3><ol><li>在模板方法模式的父类中，我们可以定义一个方法，它 默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。</li><li>还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，请使用钩子方法对前面的模板方法进行改造</li></ol><h3 id="2-、代码实现-4"><a href="#2-、代码实现-4" class="headerlink" title="(2)、代码实现"></a>(2)、代码实现</h3><p>在<code>SoyaMilk</code>中增加一个新方法<code>customerWantCondiments</code>，默认返回<code>true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//钩子方法，决定是否需要添加配料</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PureSoyaMilk</code>纯豆浆类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class PureSoyaMilk extends SoyaMilk&#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   void addCondiments() &#123;</span><br><span class="line">      &#x2F;&#x2F;空实现</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   boolean customerWantCondiments() &#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、模板方法模式在-Spring-框架应用的源码分析"><a href="#4、模板方法模式在-Spring-框架应用的源码分析" class="headerlink" title="4、模板方法模式在 Spring 框架应用的源码分析"></a>4、模板方法模式在 Spring 框架应用的源码分析</h2><p>Spring IOC 容器初始化时运用到的模板方法模式</p><p>进入<code>ConfigurableApplicationContext</code>，这是一个接口，其中有一个<code>refresh</code>方法，查看他的实现类<code>AbstractApplicationContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span>, <span class="title">Lifecycle</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明了一个模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure><p><code>AbstractApplicationContext</code>是一个抽象类，重写了<code>refresh</code>方法，在<code>refresh</code>方法中，调用了很多方法，其中包括钩子方法，其中<code>obtainFreshBeanFactory()</code>里面的<code>refreshBeanFactory()</code>方法就是一个只有空实现的钩子方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明类图</strong></p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120193346.png" style="zoom:67%;"><h2 id="5、模板方法模式的注意事项和细节"><a href="#5、模板方法模式的注意事项和细节" class="headerlink" title="5、模板方法模式的注意事项和细节"></a>5、模板方法模式的注意事项和细节</h2><ol><li>基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改。</li><li>实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。</li><li>既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。</li><li>该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大。</li><li>一般模板方法都加上 final 关键字， 防止子类重写模板方法。</li><li>模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理。</li></ol><p><strong>弹幕大神</strong></p><p>建造者是用于构建对象的</p><p>建造者模式是有指挥者director和builderde</p><p>建造者目的是获取复杂对象，忽略创建对象时内部复杂的步骤</p><p>此类线程和父类线程会出现多线程竞争资源，多运行几次，顺序会出错，</p><h1 id="十三、命令设计模式"><a href="#十三、命令设计模式" class="headerlink" title="十三、命令设计模式"></a>十三、命令设计模式</h1><h2 id="1、实际问题导出-7"><a href="#1、实际问题导出-7" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><p>智能生活项目需求<br>看一个具体的需求</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120204446.png" style="zoom:67%;"><ol><li>我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装 app 就可以控制对这些家电工作。</li><li>这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个 App，分别控制，我们希望只要一个app<br>就可以控制全部智能家电。</li><li>要实现一个 app 控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口给 app 调用，这时就可以考虑使用命令模式。</li><li>命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来.</li><li>在我们的例子中，动作的请求者是手机 app，动作的执行者是每个厂商的一个家电产品</li></ol><p><strong>感觉和外观模式很像。。。</strong></p><h2 id="2、命令模式"><a href="#2、命令模式" class="headerlink" title="2、命令模式"></a><strong>2、命令模式</strong></h2><h3 id="1-、基本介绍-15"><a href="#1-、基本介绍-15" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计</li><li>命名模式使得 请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。</li><li>在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。</li><li>通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将军和士兵)。将军只需要发出一条攻击命令，甚至都不用知道士兵具体是谁，只要发出了命令，就有响应者接收命令做出反应。<br>Invoker 是调用者（将军），Receiver 是被调用者（士兵），MyCommand 是命令，实现了 Command 接口，持有接收对象</li></ol><h3 id="2-、原理类图-5"><a href="#2-、原理类图-5" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120205232.png" style="zoom:67%;"><p>对原理类图的说明-即(命名模式的角色及职责)</p><ol><li><code>Invoker</code> 是调用者角色</li><li><code>Command</code>: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类</li><li><code>Receiver</code>: 接受者角色，知道如何实施和执行一个请求相关的操作</li><li><code>ConcreteCommand</code>: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现 execute</li></ol><h3 id="3-、应用实例要求-1"><a href="#3-、应用实例要求-1" class="headerlink" title="(3)、应用实例要求"></a>(3)、应用实例要求</h3><p>编写程序，使用命令模式 完成前面的智能家电项目</p><h3 id="4-、UML类图分析-4"><a href="#4-、UML类图分析-4" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120212934.png" style="zoom:67%;"><h3 id="5-、代码实现-5"><a href="#5-、代码实现-5" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p>这个命令模式设计的妙啊，值得好好的说一番。</p><p>首先实现对于电灯开关的操作</p><p>首先定义<code>Command</code>接口，定义两个方法<code>execute()</code>和<code>undo()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">   <span class="comment">//执行动作(操作)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//撤销动作(操作)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个<code>LightReceiver</code>类，也就是电灯的实体类，具体来实现电灯的开关操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightReceiver</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">" 电灯打开了.. "</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">" 电灯关闭了.. "</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LightOnCommand</code>聚合<code>LightReceiver</code>在构造函数里面传进来一个<code>LightReceiver</code>实体类，<code>execute()</code>执行电灯开，<code>undo()</code>执行电灯关，(execute是执行的意思，undo是撤销的意思，在<code>LightOnCommand</code>里面，撤销自然就是电灯关了)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"><span class="comment">//聚合LightReceiver</span></span><br><span class="line">LightReceiver light;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(LightReceiver light)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.light = light;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用接收者的方法</span></span><br><span class="line">light.on();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用接收者的方法</span></span><br><span class="line">light.off();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面一样，<code>LightOffCommand</code>聚合<code>LightReceiver</code>在构造函数里面传进来一个<code>LightReceiver</code>实体类，<code>execute()</code>执行电灯关，<code>undo()</code>执行电灯开，(execute是执行的意思，undo是撤销的意思，在<code>LightOffCommand</code>里面，撤销自然就是电灯开了)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 聚合LightReceiver</span></span><br><span class="line">   LightReceiver light;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(LightReceiver light)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.light = light;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 调用接收者的方法</span></span><br><span class="line">      light.off();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 调用接收者的方法</span></span><br><span class="line">      light.on();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计一个<code>NoCommand</code>空命令类，什么也不干，便于初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有任何命令，即空执行: 用于初始化每个按钮, 当调用空命令时，对象什么都不做</span></span><br><span class="line"><span class="comment">//其实，这样是一种设计模式, 可以省掉对空判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-、心得1"><a href="#1-、心得1" class="headerlink" title="1)、心得1"></a>1)、心得1</h4><p>到这里为止，看起来是把一个电灯类就能搞定的开关操作活生生分出去了4个类，特别是还多了一个莫名其妙的<code>NoCommand</code>，看起来增加了麻烦，其实不然，到后面才能体会到真正设计模式的巧妙之处。这个<code>NoCommand</code>空命令类设计的确是牛逼，避免一些对空的判断和在遥控器初始化时使用。</p><p>现实中的遥控器</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200120215522.png" style="zoom:50%;"><p>继续撸代码</p><p><code>RemoteController</code>这个控制器类(遥控器)写的确是好，定义一个撤销按钮和两个数组，分别是开按钮数组和关按钮数组，初始化时全部指向<code>NoCommand</code>空命令类，也符合现实中遥控器的实际，不开不关就是啥也不干。在按下开或关按钮时，使用对应数组元素的方法并存到撤销按钮里面，在按下撤销按钮时，进行撤销操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteController</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 开 按钮的命令数组</span></span><br><span class="line">   Command[] onCommands;</span><br><span class="line">   Command[] offCommands;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 执行撤销的命令</span></span><br><span class="line">   Command undoCommand;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器，完成对按钮初始化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RemoteController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      onCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line">      offCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         onCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">         offCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 给我们的按钮设置你需要的命令</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> no, Command onCommand, Command offCommand)</span> </span>&#123;</span><br><span class="line">      onCommands[no] = onCommand;</span><br><span class="line">      offCommands[no] = offCommand;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 按下开按钮</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123; </span><br><span class="line">      <span class="comment">// 找到你按下的开的按钮， 并调用对应方法</span></span><br><span class="line">      onCommands[no].execute();</span><br><span class="line">      <span class="comment">// 记录这次的操作，用于撤销</span></span><br><span class="line">      undoCommand = onCommands[no];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 按下关按钮</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123; </span><br><span class="line">      <span class="comment">// 找到你按下的关的按钮， 并调用对应方法</span></span><br><span class="line">      offCommands[no].execute();</span><br><span class="line">      <span class="comment">// 记录这次的操作，用于撤销</span></span><br><span class="line">      undoCommand = offCommands[no];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 按下撤销按钮</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoButtonWasPushed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      undoCommand.undo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main调用时，依次创建对象，<code>new LightOnCommand(lightReceiver);</code>这里就将电灯开按钮和电灯实体类进行了绑定，关按钮同理。<code>remoteController.setCommand(0, lightOnCommand, lightOffCommand);</code>设置数组第0位为电视机的相关操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用命令设计模式，完成通过遥控器，对电灯的操作</span></span><br><span class="line">   <span class="comment">//创建电灯的对象(接受者)</span></span><br><span class="line">   LightReceiver lightReceiver = <span class="keyword">new</span> LightReceiver();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建电灯相关的开关命令</span></span><br><span class="line">   LightOnCommand lightOnCommand = <span class="keyword">new</span> LightOnCommand(lightReceiver);</span><br><span class="line">   LightOffCommand lightOffCommand = <span class="keyword">new</span> LightOffCommand(lightReceiver);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//需要一个遥控器</span></span><br><span class="line">   RemoteController remoteController = <span class="keyword">new</span> RemoteController();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//给我们的遥控器设置命令, 比如 no = 0 是电灯的开和关的操作</span></span><br><span class="line">   remoteController.setCommand(<span class="number">0</span>, lightOnCommand, lightOffCommand);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"--------按下灯的开按钮-----------"</span>);</span><br><span class="line">   remoteController.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">   System.out.println(<span class="string">"--------按下灯的关按钮-----------"</span>);</span><br><span class="line">   remoteController.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">   System.out.println(<span class="string">"--------按下撤销按钮-----------"</span>);</span><br><span class="line">   remoteController.undoButtonWasPushed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-、心得2"><a href="#2-、心得2" class="headerlink" title="2)、心得2"></a>2)、心得2</h4><p>这个设计模式遵循OCP原则，加一个电视机的控制</p><p>首先是<code>TVReceiver</code>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TVReceiver</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 电视机打开了.. "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">" 电视机关闭了.. "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TVOnCommand</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TVOnCommand implements Command &#123;</span><br><span class="line">   &#x2F;&#x2F; 聚合TVReceiver</span><br><span class="line">   TVReceiver tv;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 构造器</span><br><span class="line">   public TVOnCommand(TVReceiver tv) &#123;</span><br><span class="line">      this.tv &#x3D; tv;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void execute() &#123;</span><br><span class="line">      &#x2F;&#x2F; 调用接收者的方法</span><br><span class="line">      tv.on();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void undo() &#123;</span><br><span class="line">      &#x2F;&#x2F; 调用接收者的方法</span><br><span class="line">      tv.off();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TVOffCommand</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TVOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 聚合TVReceiver</span></span><br><span class="line">   TVReceiver tv;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TVOffCommand</span><span class="params">(TVReceiver tv)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.tv = tv;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 调用接收者的方法</span></span><br><span class="line">      tv.off();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 调用接收者的方法</span></span><br><span class="line">      tv.on();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完这三个类就可以直接使用了，设置一下遥控器1号位控制电视机的相关操作就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"=========使用遥控器操作电视机=========="</span>);</span><br><span class="line"></span><br><span class="line">TVReceiver tvReceiver = <span class="keyword">new</span> TVReceiver();</span><br><span class="line">TVOffCommand tvOffCommand = <span class="keyword">new</span> TVOffCommand(tvReceiver);</span><br><span class="line">TVOnCommand tvOnCommand = <span class="keyword">new</span> TVOnCommand(tvReceiver);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给我们的遥控器设置命令, 比如 no = 1 是电视机的开和关的操作</span></span><br><span class="line">remoteController.setCommand(<span class="number">1</span>, tvOnCommand, tvOffCommand);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"--------按下电视机的开按钮-----------"</span>);</span><br><span class="line">remoteController.onButtonWasPushed(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"--------按下电视机的关按钮-----------"</span>);</span><br><span class="line">remoteController.offButtonWasPushed(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"--------按下撤销按钮-----------"</span>);</span><br><span class="line">remoteController.undoButtonWasPushed();</span><br></pre></td></tr></table></figure><p>这个设计模式确实牛逼，将命令的执行者和命令发出者进行了解耦，在命令发出之前，双方都是透明的，谁都不知道谁。</p><h2 id="3、命令模式在-Spring-框架-JdbcTemplate-应用的源码分析"><a href="#3、命令模式在-Spring-框架-JdbcTemplate-应用的源码分析" class="headerlink" title="3、命令模式在 Spring 框架 JdbcTemplate 应用的源码分析"></a>3、命令模式在 Spring 框架 JdbcTemplate 应用的源码分析</h2><p>Spring 框架的<code>JdbcTemplate</code>使用到了命令模式</p><p>在<code>JdbcTemplate</code>了类中的<code>query</code>方法里面有一个匿名内部类<code>QueryStatementCallback</code>，追踪<code>StatementCallback&lt;T&gt;</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplate</span> <span class="keyword">extends</span> <span class="title">JdbcAccessor</span> <span class="keyword">implements</span> <span class="title">JdbcOperations</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">   Assert.notNull(sql, <span class="string">"SQL must not be null"</span>);</span><br><span class="line">   Assert.notNull(rse, <span class="string">"ResultSetExtractor must not be null"</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Executing SQL query ["</span> + sql + <span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title">StatementCallback</span>&lt;<span class="title">T</span>&gt;, <span class="title">SqlProvider</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> T <span class="title">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">         ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            ResultSet rsToUse = rs;</span><br><span class="line">            <span class="keyword">if</span> (nativeJdbcExtractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">               rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rse.extractData(rsToUse);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.closeResultSet(rs);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> sql;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> execute(<span class="keyword">new</span> QueryStatementCallback());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StatementCallback&lt;T&gt;</code>接口就一个方法<code>T doInStatement(Statement stmt)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function">T <span class="title">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException, DataAccessException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ol><li>StatementCallback 接口 ,类似命令接口(Command)</li><li>class QueryStatementCallback implements StatementCallback<T>, SqlProvider , 匿名内部类， 实现了命令接口，同时也充当命令接收者.</T></li><li>命令调用者 是 JdbcTemplate , 其中 execute(StatementCallback<T> action) 方法中，调用action.doInStatement 方法. 不同的 实现 StatementCallback 接口的对象，对应不同的doInStatemnt 实现逻辑</T></li><li>另外实现 StatementCallback 命令接口的子类还有多个，例如QueryStatementCallback等</li></ol><p>这个源码分析举得例子有点牵强，没看懂，后期仔细领悟吧，不过上面的代码实现是看懂了的。</p><h2 id="4、-命令模式的注意事项和细节"><a href="#4、-命令模式的注意事项和细节" class="headerlink" title="4、 命令模式的注意事项和细节"></a>4、 命令模式的注意事项和细节</h2><ol><li>将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的 execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。</li><li>容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令</li><li>容易实现对请求的撤销和重做</li><li>命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意</li><li>空命令也是一种设计模式，它为我们 省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。</li><li>命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟 CMD（DOS 命令）订单的撤销/恢复、触发-反馈机制</li></ol><h1 id="十四、访问者设计模式"><a href="#十四、访问者设计模式" class="headerlink" title="十四、访问者设计模式"></a>十四、访问者设计模式</h1><h2 id="1、实际问题导出-8"><a href="#1、实际问题导出-8" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、完成测评系统需求"><a href="#1-、完成测评系统需求" class="headerlink" title="(1)、完成测评系统需求"></a>(1)、完成测评系统需求</h3><p>将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(评价 有不<br>同的种类，比如 成功、失败 等)</p><h3 id="2-、传统方案"><a href="#2-、传统方案" class="headerlink" title="(2)、传统方案"></a>(2)、传统方案</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200121101814.png" style="zoom:67%;"><h3 id="3-、传统方式的问题分析"><a href="#3-、传统方式的问题分析" class="headerlink" title="(3)、传统方式的问题分析"></a>(3)、传统方式的问题分析</h3><ol><li>如果系统比较小，还是ok的，但是考虑系统增加越来越多新的功能时，对代码改动较大，违反了ocp原则， 不利于维护</li><li>扩展性不好，比如 增加了 新的人员类型，或者管理方法，都不好做</li><li>引出我们会使用新的设计模式 – 访问者模式</li></ol><h2 id="2、-访问者模式"><a href="#2、-访问者模式" class="headerlink" title="2、 访问者模式"></a>2、 访问者模式</h2><h3 id="1-、基本介绍-16"><a href="#1-、基本介绍-16" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</li><li>主要将数据结构与数据操作分离，解决 数据结构和操作耦合性问题</li><li>访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口</li><li>访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作”污染”这些对象的类，可以选用访问者模式解决</li></ol><h3 id="2-、原理类图-6"><a href="#2-、原理类图-6" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200211101910.png" style="zoom:50%;"><p><strong>对原理类图的说明</strong>-即(访问者模式的角色及职责)</p><ol><li>Visitor 是抽象访问者，为该对象结构中的 ConcreteElement 的每一个类声明一个visit 操作</li><li>ConcreteVisitor ：是一个具体的访问值 实现每个有 Visitor 声明的操作，是每个操作实现的部分.</li><li>ObjectStructure 能枚举它的元素， 可以提供一个高层的接口，用来允许访问者访问元素</li><li>Element 定义一个 accept 方法，接收一个访问者对象</li><li>ConcreteElement 为具体元素，实现了 accept 方法</li></ol><h3 id="3-、应用实例要求-2"><a href="#3-、应用实例要求-2" class="headerlink" title="(3)、应用实例要求"></a>(3)、应用实例要求</h3><p>将人分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(评价 有不同<br>的种类，比如 成功、失败 等)，请使用访问者模式来说实现</p><h3 id="4-、UML类图分析-5"><a href="#4-、UML类图分析-5" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200211103638.png" style="zoom:67%;"><h3 id="5-、代码实现-6"><a href="#5-、代码实现-6" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p>先创建Person抽象类，提供一个对外访问的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//提供一个方法，让访问者可以访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Man和Woman类进行实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">        action.getManResult(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">        action.getWomanResult(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个抽象类Action，就是访问者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到男性 的测评</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到女的 测评</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种状态Success和Fail</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Success</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 男人给的评价该歌手成功 !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 女人给的评价该歌手成功 !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fail</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 男人给的评价该歌手失败 !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 女人给的评价该歌手失败 !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectStructure链表，管理着很多人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护了一个集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Person&gt; persons = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加到list</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        persons.add(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        persons.remove(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示测评情况</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Person p: persons) &#123;</span><br><span class="line">            p.accept(action);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建ObjectStructure</span></span><br><span class="line">   ObjectStructure objectStructure = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line"></span><br><span class="line">   objectStructure.attach(<span class="keyword">new</span> Man());</span><br><span class="line">   objectStructure.attach(<span class="keyword">new</span> Woman());</span><br><span class="line"></span><br><span class="line">   <span class="comment">//成功</span></span><br><span class="line">   Success success = <span class="keyword">new</span> Success();</span><br><span class="line">   objectStructure.display(success);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">   Fail fail = <span class="keyword">new</span> Fail();</span><br><span class="line">   objectStructure.display(fail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"> 男人给的评价该歌手成功 !</span><br><span class="line"> 女人给的评价该歌手成功 !</span><br><span class="line">===============</span><br><span class="line"> 男人给的评价该歌手失败 !</span><br><span class="line"> 女人给的评价该歌手失败 !</span><br></pre></td></tr></table></figure><p>这个设计模式的好处，如果加了一个状态比如说待定，只要继承Action接口即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">extends</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 男人给的评价是该歌手待定 .."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 女人给的评价是该歌手待定 .."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"=======给的是待定的测评========"</span>);</span><br><span class="line"></span><br><span class="line">Wait wait = <span class="keyword">new</span> Wait();</span><br><span class="line">objectStructure.display(wait);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">=======给的是待定的测评========</span><br><span class="line"> 男人给的评价是该歌手待定 ..</span><br><span class="line"> 女人给的评价是该歌手待定 ..</span><br></pre></td></tr></table></figure><h2 id="3、访问者模式的注意事项和细节"><a href="#3、访问者模式的注意事项和细节" class="headerlink" title="3、访问者模式的注意事项和细节"></a>3、访问者模式的注意事项和细节</h2><p><strong>这里使用了双分派</strong><br>说明</p><ol><li>这里我们使用到了双分派, 即首先在客户端程序中，将具体状态作为参数传递Woman中(第一次分派)</li><li>然后Woman 类调用作为参数的 “具体方法” 中方法getWomanResult, 同时将自己(this)作为参数传入，完成第二次的分派</li></ol><p><strong>优点</strong></p><ol><li>访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高</li><li>访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统</li></ol><p><strong>缺点</strong></p><ol><li>具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的, 这样造成了具体元素变更比较困难</li><li>违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素</li><li>因此， 如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么 访问者模式就是比较合适的.</li></ol><h1 id="十五、迭代器设计模式"><a href="#十五、迭代器设计模式" class="headerlink" title="十五、迭代器设计模式"></a>十五、迭代器设计模式</h1><h2 id="1、实际问题导出-9"><a href="#1、实际问题导出-9" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，<br>一个学院有多个系。(这个要求和 八、组合设计模式 里面提出的要求是一样的)如图：</p><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200222205545.png" style="zoom:80%;"><h2 id="2、迭代器模式"><a href="#2、迭代器模式" class="headerlink" title="2、迭代器模式"></a>2、迭代器模式</h2><h3 id="1-、基本介绍-17"><a href="#1-、基本介绍-17" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>迭代器模式（Iterator Pattern）是 常用的设计模式，属于行为型模式</li><li>如果我们的集合元素是用不同的方式实现的，<font color="red">有数组，有链表，还有 java 的集合类，或者还有其他方式</font>，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。</li><li>迭代器模式， 提供一种遍历集合元素的统一接口，用 一致的方法遍历集合元素，不需要知道 集合对象的底层表示，即：不暴露其内部的结构。</li></ol><p>多种存储方式，一套代码解决 –&gt; 迭代器模式</p><h3 id="2-、原理类图-7"><a href="#2-、原理类图-7" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200222210312.png" style="zoom: 50%;"><p>对原理类图的说明-即(迭代器模式的角色及职责)</p><ol><li>Iterator ： 迭代器接口，是系统提供，含义 hasNext, next, remove</li><li>ConcreteIterator : 具体的迭代器类，管理迭代</li><li>Aggregate :一个统一的聚合接口， 将客户端和具体聚合解耦</li><li>ConcreteAggreage : 具体的聚合持有对象集合， 并提供一个方法，返回一个迭代器， 该迭代器可以正确遍历集合</li><li>Client :客户端， 通过 Iterator 和 Aggregate 依赖子类</li></ol><h3 id="3-、应用实例要求-3"><a href="#3-、应用实例要求-3" class="headerlink" title="(3)、应用实例要求"></a>(3)、应用实例要求</h3><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，<br>一个学院有多个系。</p><h3 id="4-、UML类图分析-6"><a href="#4-、UML类图分析-6" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200222211204.png" style="zoom:80%;"><h3 id="5-、代码实现-7"><a href="#5-、代码实现-7" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p>这个设计模式没啥用，跳过</p><h1 id="十六、观察者设计模式"><a href="#十六、观察者设计模式" class="headerlink" title="十六、观察者设计模式"></a>十六、观察者设计模式</h1><h2 id="1、实际问题导出-10"><a href="#1、实际问题导出-10" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、天气预报项目需求"><a href="#1-、天气预报项目需求" class="headerlink" title="(1)、天气预报项目需求"></a>(1)、天气预报项目需求</h3><ol><li>气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。</li><li>需要 设计开放型 API，便于 其他第三方也能接入气象站获取数据。</li><li>提供温度、气压和湿度的接口</li><li>测量数据更新时，要能实时的通知给第三方</li></ol><h3 id="2-、传统方案-1"><a href="#2-、传统方案-1" class="headerlink" title="(2)、传统方案"></a>(2)、传统方案</h3><p>让气象台有信息变化的时候就使用update方法，推送给用户,</p><p>代码实现以下，看一下缺点</p><p>先写一个订阅用户，其中的update方法是由气象台来调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditions</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 温度，气压，湿度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用推送模式更新 天气情况，是由 WeatherData 来调用，</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">      <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">      <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">      display();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//显示</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"***Today mTemperature: "</span> + temperature + <span class="string">"***"</span>);</span><br><span class="line">      System.out.println(<span class="string">"***Today mPressure: "</span> + pressure + <span class="string">"***"</span>);</span><br><span class="line">      System.out.println(<span class="string">"***Today mHumidity: "</span> + humidity + <span class="string">"***"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是气象台的数据改变时，调用setdata方法，然后订阅订阅者的update，这样聚集了大量的不同订阅者对象在类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> temperatrue;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">   <span class="keyword">private</span> CurrentConditions currentConditions;</span><br><span class="line">   <span class="comment">//加入新的第三方</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">(CurrentConditions currentConditions)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.currentConditions = currentConditions;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> temperatrue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> pressure;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> humidity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用 接入方的 update</span></span><br><span class="line">      currentConditions.update(getTemperature(), getPressure(), getHumidity());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//当数据有更新时，就调用 setData</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.temperatrue = temperature;</span><br><span class="line">      <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">      <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">      <span class="comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span></span><br><span class="line">      dataChange();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建接入方 currentConditions</span></span><br><span class="line">      CurrentConditions currentConditions = <span class="keyword">new</span> CurrentConditions();</span><br><span class="line">      <span class="comment">//创建 WeatherData 并将 接入方 currentConditions 传递到 WeatherData中</span></span><br><span class="line">      WeatherData weatherData = <span class="keyword">new</span> WeatherData(currentConditions);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//更新天气情况</span></span><br><span class="line">      weatherData.setData(<span class="number">30</span>, <span class="number">150</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//天气情况变化</span></span><br><span class="line">      System.out.println(<span class="string">"============天气情况变化============="</span>);</span><br><span class="line">      weatherData.setData(<span class="number">40</span>, <span class="number">160</span>, <span class="number">20</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">***Today mTemperature: <span class="number">30.0</span>***</span><br><span class="line">***Today mPressure: <span class="number">150.0</span>***</span><br><span class="line">***Today mHumidity: <span class="number">40.0</span>***</span><br><span class="line">============天气情况变化=============</span><br><span class="line">***Today mTemperature: <span class="number">40.0</span>***</span><br><span class="line">***Today mPressure: <span class="number">160.0</span>***</span><br><span class="line">***Today mHumidity: <span class="number">20.0</span>***</span><br></pre></td></tr></table></figure><h3 id="3-、传统方式的问题分析-1"><a href="#3-、传统方式的问题分析-1" class="headerlink" title="(3)、传统方式的问题分析"></a>(3)、传统方式的问题分析</h3><ol><li>其他第三方接入气象站获取数据的问题</li><li>无法在运行时动态的添加第三方(在 WeatherData 中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到 dataChange, 不利于维护，也不是动态加入)</li><li>违反 ocp 原则=&gt;观察者模式</li></ol><h2 id="2、观察者模式"><a href="#2、观察者模式" class="headerlink" title="2、观察者模式"></a>2、观察者模式</h2><h3 id="1-、基本介绍-18"><a href="#1-、基本介绍-18" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>观察者模式类似订牛奶业务</li><li>奶站/气象局：Subject</li><li>用户/第三方网站：Observer</li></ol><ul><li>Subject：登记注册、移除和通知</li></ul><ol><li>registerObserver 注册</li><li>removeObserver 移除</li><li>notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送，看具体需求定</li></ol><ul><li>Observer：接收输入</li></ul><p>观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为 Subject，依赖的对象为 Observer，Subject通知 Observer 变化,比如这里的奶站是 Subject，是 1 的一方。用户时 Observer，是多的一方。</p><h3 id="2-、UML类图分析-2"><a href="#2-、UML类图分析-2" class="headerlink" title="(2)、UML类图分析"></a>(2)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200222215005.png" style="zoom:67%;"><h3 id="3-、代码实现-1"><a href="#3-、代码实现-1" class="headerlink" title="(3)、代码实现"></a>(3)、代码实现</h3><p>首先写一个观察者接口，所有要实现订阅功能的类都去实现它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者接口，有观察者来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CurrentConditions直接从上面照抄</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditions</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 温度，气压，湿度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">      <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">      <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">      display();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 显示</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"***Today mTemperature: "</span> + temperature + <span class="string">"***"</span>);</span><br><span class="line">      System.out.println(<span class="string">"***Today mPressure: "</span> + pressure + <span class="string">"***"</span>);</span><br><span class="line">      System.out.println(<span class="string">"***Today mHumidity: "</span> + humidity + <span class="string">"***"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写一个Subject接口，所有要实现发布功能的类都要有这三个方法，订阅 移除 通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口, 让WeatherData 来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WeatherData继承Subject接口，重写三个方法，然后其中有一个链表，对所有的订阅者进行遍历链表通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> temperatrue;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">   <span class="comment">//观察者集合</span></span><br><span class="line">   <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//加入新的第三方</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> temperatrue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> pressure;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> humidity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//当数据有更新时，就调用 setData</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.temperatrue = temperature;</span><br><span class="line">      <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">      <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">      <span class="comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span></span><br><span class="line">      notifyObservers();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注册一个观察者</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">      observers.add(o);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//移除一个观察者</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(observers.contains(o)) &#123;</span><br><span class="line">         observers.remove(o);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历所有的观察者，并通知</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++) &#123;</span><br><span class="line">         observers.get(i).update(<span class="keyword">this</span>.temperatrue, <span class="keyword">this</span>.pressure, <span class="keyword">this</span>.humidity);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的可扩展性很好，其他网站要调用，直接实现Observer接口，并进行注册就可以使用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建一个WeatherData</span></span><br><span class="line">   WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">   <span class="comment">//创建观察者</span></span><br><span class="line">   CurrentConditions currentConditions = <span class="keyword">new</span> CurrentConditions();</span><br><span class="line">   BaiduSite baiduSite = <span class="keyword">new</span> BaiduSite();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注册到weatherData</span></span><br><span class="line">   weatherData.registerObserver(currentConditions);</span><br><span class="line">   weatherData.registerObserver(baiduSite);</span><br><span class="line">   <span class="comment">//测试</span></span><br><span class="line">   System.out.println(<span class="string">"通知各个注册的观察者, 看看信息"</span>);</span><br><span class="line">   weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   weatherData.removeObserver(currentConditions);</span><br><span class="line">   <span class="comment">//测试</span></span><br><span class="line">   System.out.println();</span><br><span class="line">   System.out.println(<span class="string">"通知各个注册的观察者, 看看信息"</span>);</span><br><span class="line">   weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、观察者模式在-JDK-应用的源码分析"><a href="#3、观察者模式在-JDK-应用的源码分析" class="headerlink" title="3、观察者模式在 JDK 应用的源码分析"></a>3、观察者模式在 JDK 应用的源码分析</h2><p> Jdk 的 Observable 类就使用了观察者模式</p><p>进入Observable类，可以看到其中维护了一个Vector，和list基本一样，线程安全而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后其中也有注册，注销，通知方法，基本一模一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">        obs.addElement(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>模式角色分析</p><ol><li>Observable 的作用和地位等价于 我们前面讲过 Subject</li><li>Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理 Observer 的方法add.. delete .. notify…</li><li>Observer 的作用和地位等价于我们前面讲过的 Observer, 有 update</li><li>Observable 和 Observer 的使用方法和前面讲过的一样，只是 Observable 是类，通过继承来实现观察者模式</li></ol><h1 id="十七、中介者设计模式"><a href="#十七、中介者设计模式" class="headerlink" title="十七、中介者设计模式"></a>十七、中介者设计模式</h1><h2 id="1、实际问题导出-11"><a href="#1、实际问题导出-11" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、智能家庭项目需求"><a href="#1-、智能家庭项目需求" class="headerlink" title="(1)、智能家庭项目需求"></a>(1)、智能家庭项目需求</h3><p>智能家庭项目：</p><ol><li>智能家庭包括各种设备，闹钟、咖啡机、电视机、窗帘 等</li><li>主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作，比如流程为：闹铃响起-&gt;咖啡机开始做咖啡-&gt;窗帘自动落下-&gt;电视机开始播放</li></ol><h3 id="2-、传统方案-2"><a href="#2-、传统方案-2" class="headerlink" title="(2)、传统方案"></a>(2)、传统方案</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200223103053.png" style="zoom:67%;"><h3 id="3-、传统的方式的问题分析"><a href="#3-、传统的方式的问题分析" class="headerlink" title="(3)、传统的方式的问题分析"></a>(3)、传统的方式的问题分析</h3><ol><li>当各电器对象有多种状态改变时，相互之间的调用关系会比较复杂</li><li>各个 电器对象彼此联系，你中有我，我中有你，不利于松耦合.</li><li>各个电器对象之间所传递的消息(参数)，容易混乱</li><li>当系统增加一个新的电器对象时，或者执行流程改变时，代码的可维护性、扩展性都不理想<br><font color="red">考虑中介者模式</font></li></ol><h2 id="2、中介者模式"><a href="#2、中介者模式" class="headerlink" title="2、中介者模式"></a>2、中介者模式</h2><h3 id="1-、基本介绍-19"><a href="#1-、基本介绍-19" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>中介者模式（Mediator Pattern），用一个 中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其 耦合松散，而且可以独立地改变它们之间的交互</li><li>中介者模式属于行为型模式，使代码易于维护</li><li>比如 MVC 模式，C（Controller 控制器）是 M（Model 模型）和 V（View 视图）的中介者，在前后端交互时起到了中间人的作用</li></ol><h3 id="2-、原理类图-8"><a href="#2-、原理类图-8" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200223102842.png" style="zoom:67%;"><p>对原理类图的说明-即(中介者模式的角色及职责)</p><ol><li>Mediator 就是抽象中介者,定义了同事对象到中介者对象的接口</li><li>Colleague 是抽象功能类</li><li>ConcreteMediator 具体的中介者对象, 实现抽象方法, 他需要知道所有的具体的功能类,即以一个集合来管理HashMap,并接受某个同事对象消息，完成相应的任务</li><li>ConcreteColleague 具体的功能类，会有很多, <font color="red">每个功能只知道自己的行为，而不了解其他功能类的行为(方法)，在自身的构造方法里面会使用依赖Mediator中介者对象，将自身放进ConcreteMediator的HashMap去管理</font></li></ol><h3 id="3-、应用实例要求-4"><a href="#3-、应用实例要求-4" class="headerlink" title="(3)、应用实例要求"></a>(3)、应用实例要求</h3><p>完成前面的智能家庭的项目，使用中介者模式</p><h3 id="4-、UML类图分析-7"><a href="#4-、UML类图分析-7" class="headerlink" title="(4)、UML类图分析"></a>(4)、UML类图分析</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200223105320.png" style="zoom:80%;"><h3 id="5-、代码实现-8"><a href="#5-、代码实现-8" class="headerlink" title="(5)、代码实现"></a>(5)、代码实现</h3><p>代码过于复杂，了解思想即可</p><h2 id="3、中介者模式的注意事项和细节"><a href="#3、中介者模式的注意事项和细节" class="headerlink" title="3、中介者模式的注意事项和细节"></a>3、中介者模式的注意事项和细节</h2><ol><li>多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构，进行解耦</li><li>减少类间依赖，降低了耦合，符合迪米特原则</li><li>中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响</li><li>如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意</li></ol><h1 id="十七、备忘录设计模式"><a href="#十七、备忘录设计模式" class="headerlink" title="十七、备忘录设计模式"></a>十七、备忘录设计模式</h1><h2 id="1、实际问题导出-12"><a href="#1、实际问题导出-12" class="headerlink" title="1、实际问题导出"></a>1、实际问题导出</h2><h3 id="1-、游戏角色状态恢复需求"><a href="#1-、游戏角色状态恢复需求" class="headerlink" title="(1)、游戏角色状态恢复需求"></a>(1)、游戏角色状态恢复需求</h3><p>游戏角色有攻击力和防御力，在大战 Boss 前保存自身的状态(攻击力和防御力)，当大战 Boss 后攻击力和防御<br>力下降，从备忘录对象恢复到大战前的状态，就是要恢复一个对象原先的状态，游戏存档回档功能</p><h3 id="2-、传统方案-3"><a href="#2-、传统方案-3" class="headerlink" title="(2)、传统方案"></a>(2)、传统方案</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200223110914.png" style="zoom:50%;">传统方案就是倒酱油，每次再创建一个对象，拷贝所有的属性和状态，再拷贝回去<h3 id="3-、传统的方式的问题分析-1"><a href="#3-、传统的方式的问题分析-1" class="headerlink" title="(3)、传统的方式的问题分析"></a>(3)、传统的方式的问题分析</h3><ol><li>一个对象，就对应一个保存对象状态的对象， 这样当我们游戏的对象很多时，不利于管理，开销也很大.</li><li>传统的方式是简单地做备份，new 出另外一个对象出来，再把需要备份的数据放到这个新对象，但这就暴露了对象内部的细节</li><li>解决方案： =&gt;  备忘录模式</li></ol><h2 id="2、备忘录模式"><a href="#2、备忘录模式" class="headerlink" title="2、备忘录模式"></a>2、备忘录模式</h2><h3 id="1-、基本介绍-20"><a href="#1-、基本介绍-20" class="headerlink" title="(1)、基本介绍"></a>(1)、基本介绍</h3><ol><li>备忘录模式（Memento Pattern）在 不破坏封装性的前提下，捕获 一个对象的内部状态，并在该对象之外保存这个状态。这样以后就 可将该对象恢复到原先保存的状态</li><li>可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作</li><li>备忘录模式属于行为型模式</li></ol><h3 id="2-、原理类图-9"><a href="#2-、原理类图-9" class="headerlink" title="(2)、原理类图"></a>(2)、原理类图</h3><img src="/2020/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QQ截图20200223111242.png" style="zoom:80%;"><p>对原理类图的说明-即(备忘录模式的角色及职责)</p><ol><li>originator : 对象(需要保存状态的对象)</li><li>Memento ： 备忘录对象,负责保存好记录，即 Originator 内部状态</li><li>Caretaker: 守护者对象,负责保存多个备忘录对象， 使用集合管理，提高效率</li><li>说明：如果希望保存多个 originator 对象的不同时间的状态，也可以，只需要使用 HashMap &lt;String, 集合&gt;改进一下即可</li></ol><h3 id="3-、原理代码实现"><a href="#3-、原理代码实现" class="headerlink" title="(3)、原理代码实现"></a>(3)、原理代码实现</h3><p>首先写一个要保存的类，主要是两个方法，存档和回档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String state;<span class="comment">//状态信息</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//编写一个方法，可以保存一个状态对象 Memento，因此编写一个方法，返回 Memento</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过备忘录对象，恢复状态</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">      state = memento.getState();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个备忘录类，构造方法传进了存的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Caretaker一个管理状态类，设计一个ArrayList链表，存放所有的状态（能回到游戏的任意档）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在List 集合中会有很多的备忘录对象</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">      mementoList.add(memento);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取到第index个Originator 的 备忘录对象(即保存状态)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">      Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">      originator.setState(<span class="string">" 状态#1 攻击力 100 "</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//保存了当前的状态</span></span><br><span class="line">      caretaker.add(originator.saveStateMemento());</span><br><span class="line"></span><br><span class="line">      originator.setState(<span class="string">" 状态#2 攻击力 80 "</span>);</span><br><span class="line"></span><br><span class="line">      caretaker.add(originator.saveStateMemento());</span><br><span class="line"></span><br><span class="line">      originator.setState(<span class="string">" 状态#3 攻击力 50 "</span>);</span><br><span class="line">      caretaker.add(originator.saveStateMemento());</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"当前的状态是 ="</span> + originator.getState());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//希望得到状态 1, 将 originator 恢复到状态1</span></span><br><span class="line"></span><br><span class="line">      originator.getStateFromMemento(caretaker.get(<span class="number">0</span>));</span><br><span class="line">      System.out.println(<span class="string">"恢复到状态1 , 当前的状态是"</span>);</span><br><span class="line">      System.out.println(<span class="string">"当前的状态是 ="</span> + originator.getState());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">当前的状态是 = 状态#3 攻击力 50 </span><br><span class="line">恢复到状态<span class="number">1</span> , 当前的状态是</span><br><span class="line">当前的状态是 = 状态#1 攻击力 100</span><br></pre></td></tr></table></figure><h2 id="3、备忘录模式的注意事项和细节"><a href="#3、备忘录模式的注意事项和细节" class="headerlink" title="3、备忘录模式的注意事项和细节"></a>3、备忘录模式的注意事项和细节</h2><ol><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li><li>实现了信息的封装，使得用户不需要关心状态的保存细节</li><li>如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存, 这个需要注意</li><li>适用的应用场景：<ul><li>后悔药。 </li><li>打游戏时的存档。</li><li>Windows 里的 ctri + z。 </li><li>IE 中的后退。 </li><li>数据库的事务管理</li></ul></li><li>为了节约内存，<font color="red">备忘录模式可以和原型模式配合使用</font></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSe </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
